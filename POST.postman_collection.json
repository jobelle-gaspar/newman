{
	"info": {
		"_postman_id": "56dd03e8-f91a-4182-9661-63c0c3d537a4",
		"name": "POST",
		"schema": "https://schema.getpostman.com/json/collection/v2.1.0/collection.json"
	},
	"item": [
		{
			"name": "INSTA VIDEO - Create, Update and Delete Record",
			"item": [
				{
					"name": "BOSS login",
					"event": [
						{
							"listen": "test",
							"script": {
								"exec": [
									"pm.test(\"Status code is 200\", function () {",
									"    pm.response.to.have.status(200);",
									"});",
									""
								],
								"type": "text/javascript"
							}
						}
					],
					"request": {
						"method": "POST",
						"header": [
							{
								"warning": "This is a duplicate header and will be overridden by the Content-Type header generated by Postman.",
								"key": "Content-Type",
								"value": "application/x-www-form-urlencoded",
								"type": "text"
							}
						],
						"body": {
							"mode": "urlencoded",
							"urlencoded": [
								{
									"key": "username",
									"value": "dumbanddummy1+brooke@gmail.com",
									"description": "dumbanddummy1+brooke@gmail.com",
									"type": "text"
								},
								{
									"key": "password",
									"value": "hypetap1",
									"type": "text"
								},
								{
									"key": "remember-me",
									"value": "true",
									"type": "text"
								}
							]
						},
						"url": {
							"raw": "{{test}}login",
							"host": [
								"{{test}}login"
							]
						}
					},
					"response": []
				},
				{
					"name": "Records Before (requires date range)",
					"event": [
						{
							"listen": "test",
							"script": {
								"exec": [
									"var responseBody = pm.response.json();",
									"",
									"if(pm.response.code==200)",
									"{",
									"    if(responseBody.object.length==0)",
									"    {",
									"        pm.test(\"Status 200 no records returned for postId \" + pm.request.url.path[2]);",
									"    }",
									"    else",
									"    {",
									"        //saves number of records returned to be able to check if number has increased after POST, (add new record) call",
									"        pm.variables.set(\"totalRecordsBefore\", responseBody.object.length);",
									"",
									"        pm.test(\"Status 200, for postId \" + pm.request.url.path[2]);",
									"",
									"        //both dates has to be given for call to work",
									"        pm.test(\"Records returned: \" + responseBody.object.length+ \". Records are within date range: \"+pm.request.url.query.toObject().from+\" - \"+pm.request.url.query.toObject().to, function(){",
									"            pm.expect(withinDates(pm.request.url.query.toObject().from, pm.request.url.query.toObject().to)).to.equal(true);",
									"        })",
									"",
									"    }",
									"}",
									"else if(pm.response.code==404)",
									"{",
									"    pm.test(\"Post id not found\", function(){",
									"        pm.expect(responseBody.object).to.equal(null);",
									"    })",
									"",
									"}",
									"else if (pm.response.code == 403) ",
									"{",
									"    pm.test(\"Unauthorised to make call, only allowed for hypetap\");",
									"}",
									"",
									"//-------------Functions",
									"",
									"function withinDates(from, to)",
									"{",
									"    for(let i =0; i<responseBody.object.length; ++i)",
									"    {",
									"        if( (new Date(responseBody.object[i].dateCreated).getTime()< new Date(from).getTime() ) &&",
									"            ( new Date(responseBody.object[i].dateCreated).getTime() >new Date(to).getTime() ) )",
									"        {",
									"            return false;",
									"        }",
									"    }",
									"    return true;",
									"",
									"}",
									""
								],
								"type": "text/javascript"
							}
						}
					],
					"request": {
						"method": "GET",
						"header": [],
						"url": {
							"raw": "{{test}}post/{{postIdInstaVIDEO}}/record?from=2014-12-31&to={{dateNow}}",
							"host": [
								"{{test}}post"
							],
							"path": [
								"{{postIdInstaVIDEO}}",
								"record"
							],
							"query": [
								{
									"key": "from",
									"value": "2014-12-31"
								},
								{
									"key": "to",
									"value": "{{dateNow}}",
									"description": "set in pre test script of current folder"
								}
							]
						}
					},
					"response": []
				},
				{
					"name": "Create Record ({postId}/record)",
					"event": [
						{
							"listen": "test",
							"script": {
								"exec": [
									"var responseBody = pm.response.json();",
									"var requestBody = JSON.parse(pm.request.body.raw);",
									"",
									"//runns regardless of status",
									"pm.test(\"Required fields, impressions, views, reach and recordDate are provided\", function(){",
									"    pm.expect(requestBody.record.impressions).to.not.equal(undefined);",
									"    pm.expect(requestBody.record.views).to.not.equal(undefined);",
									"    pm.expect(requestBody.record.reach).to.not.equal(undefined);",
									"    pm.expect(requestBody.recordDate).to.not.equal(undefined);",
									"})",
									"",
									"if(pm.response.code==200)",
									"{",
									"    //save request to be ale to confirm that it was added with the correct data. ",
									"    //records are not allowed to be for the same date, so date is unique",
									"    pm.variables.set(\"newRecord\", requestBody);",
									"",
									"    pm.test(\"Status 200. Returns post corresponding to given postId \"+ pm.request.url.path[2], function(){",
									"        pm.expect( pm.request.url.path[2]).to.equal(responseBody.object.id);",
									"    })",
									"",
									"    //the new record has to be after the post date",
									"    //need to convert dates to be able to compare since they are of the type string",
									"    pm.test(\"The new record is after post date. The date of added record \" + requestBody.recordDate, function(){",
									"        pm.expect(new Date(requestBody.recordDate).getTime()> new Date(responseBody.object.datePosted).getTime() ).to.equal(true);",
									"    })",
									"",
									"}",
									"else if(pm.response.code==400)",
									"{",
									"    //The requested record date cannot be set to before the post date or to the same record date of the last update,",
									"    //(if an update has been made previously).",
									"    // will not update if post source = OTHER",
									"    if(responseBody.notes.userMessage!=undefined)",
									"    {",
									"        pm.test(\"Status 400, userMessage: \"+ responseBody.notes.userMessage, function(){",
									"            pm.expect(responseBody.notes.userMessage).to.be.oneOf([",
									"                                                            \"Cannot update posts fetched via APIs\",",
									"                                                            \"A record must have a date\",",
									"                                                            \"Record must be after post date\",",
									"                                                            \"Post already has a record for that date\",",
									"                                                            \"Can't update automatically fetched records\",",
									"                                                            \"Views must be greater than 0\",",
									"                                                            \"Impressions must be greater than 0\",",
									"                                                            \"Reach must be greater than 0\",",
									"                                                            \"Reach cannot be higher than impressions\",",
									"                                                            \"Likes cannot be higher than reach\",",
									"                                                            \"Record platform does not match post platform\",",
									"                                                            \"Saves cannot be higher than reach\",",
									"                                                            \"Views must equal impressions\",",
									"                                                            \"Views must be greater than or equal to reach\"]);",
									"        })",
									"    }",
									"    else if(responseBody.object===null )",
									"    {",
									"        pm.test(\"Platform is required, make sure it's valid\");",
									"    }",
									"}",
									"else if (pm.response.code == 403) ",
									"{",
									"    pm.test(\"Unauthorised to make call, only allowed for hypetap\");",
									"}",
									"",
									"//---------------Functions",
									""
								],
								"type": "text/javascript"
							}
						}
					],
					"request": {
						"method": "POST",
						"header": [],
						"body": {
							"mode": "raw",
							"raw": "{\n  \"record\": {\n    \"platform\": \"INSTAGRAM\",\n    \"comments\": 100,\n    \"likes\": 100,\n    \"impressions\": 100,\n    \"reach\": 100,\n    \"views\":100,\n    \"saves\": 100\n  },\n  \"recordDate\": \"2021-09-15\"\n}",
							"options": {
								"raw": {
									"language": "json"
								}
							}
						},
						"url": {
							"raw": "{{test}}post/{{postIdInstaVIDEO}}/record",
							"host": [
								"{{test}}post"
							],
							"path": [
								"{{postIdInstaVIDEO}}",
								"record"
							]
						}
					},
					"response": []
				},
				{
					"name": "Records After (requires date range)",
					"event": [
						{
							"listen": "test",
							"script": {
								"exec": [
									"var responseBody = pm.response.json();",
									"",
									"if(pm.response.code==200)",
									"{",
									"    if(responseBody.object.length==0)",
									"    {",
									"        pm.test(\"Status 200 no records returned for postId \" + pm.request.url.path[2]);",
									"    }",
									"    else",
									"    {",
									"",
									"        pm.test(\"Status 200, for postId \" + pm.request.url.path[2]);",
									"",
									"        //both dates has to be given for call to work",
									"        pm.test(\"Records returned: \" + responseBody.object.length+ \". Records are within date range: \"+pm.request.url.query.toObject().from+\" - \"+pm.request.url.query.toObject().to, function(){",
									"            pm.expect(withinDates(pm.request.url.query.toObject().from, pm.request.url.query.toObject().to)).to.equal(true);",
									"        })",
									"",
									"        pm.test(\"Records have increase by one\", function(){",
									"            pm.expect(pm.variables.get(\"totalRecordsBefore\")+1).to.equal(responseBody.object.length)",
									"        })",
									"        //validates if record exist and if it contains the same values given POST call",
									"        //also saves recordID to be able to delete it ",
									"        pm.test(\"The new record has been added and contains the same values given in POST call\", function(){",
									"            pm.expect(validateNewRecord( responseBody.object, pm.variables.get(\"newRecord\")) ).to.equal(true);",
									"        })",
									"    }",
									"}",
									"else if(pm.response.code==404)",
									"{",
									"    pm.test(\"Post id not found\", function(){",
									"        pm.expect(responseBody.object).to.equal(null);",
									"    })",
									"",
									"}",
									"else if (pm.response.code == 403) ",
									"{",
									"    pm.test(\"Unauthorised to make call, only allowed for hypetap\");",
									"}",
									"",
									"//-------------Functions",
									"",
									"function withinDates(from, to)",
									"{",
									"    for(let i =0; i<responseBody.object.length; ++i)",
									"    {",
									"        if( (new Date(responseBody.object[i].dateCreated).getTime()< new Date(from).getTime() ) &&",
									"            ( new Date(responseBody.object[i].dateCreated).getTime() >new Date(to).getTime() ) )",
									"        {",
									"            return false;",
									"        }",
									"    }",
									"    return true;",
									"",
									"}",
									"// checks if the new record, (from reuest in POST call), exist and if the data match",
									"function validateNewRecord(list, record)",
									"{",
									"    count=0;",
									"    for(let i=0; i<list.length; ++i)",
									"    {",
									"        //generate new dates to be able to convert string to date format",
									"        //if they are equal then it's the same record. Only one record can exist for one date",
									"        if(new Date(list[i].dateCreated).getTime() === new Date(record.recordDate).getTime())",
									"        {",
									"           pm.environment.set(\"recordBeforeUpdate\",list[i]);",
									"            //saves id to be able to delete record ",
									"            pm.variables.set(\"newRecordId\", list[i].id);",
									"",
									"            count+= 1;",
									"            //if likes is given and it's not the same value as response then return false, data doesn't match",
									"            if( (record.record.likes!=undefined) && (record.record.likes!=list[i].likes) )",
									"            {",
									"                return false;",
									"            }",
									"            else if( (record.record.comments!=undefined) && (record.record.comments!=list[i].comments) )",
									"            {",
									"                return false;",
									"            }",
									"            else if( (record.record.impressions!=undefined) && (record.record.impressions!=list[i].impressions) )",
									"            {",
									"                return false;",
									"            }",
									"            else if( (record.record.reach!=undefined) && (record.record.reach!=list[i].reach) )",
									"            {",
									"                return false;",
									"            }",
									"            else if( (record.record.views!=undefined) && (record.record.views!=list[i].views) )",
									"            {",
									"                return false;",
									"            }",
									"            else if( (record.record.saves!=undefined) && (record.record.saves!=list[i].saves) )",
									"            {",
									"                return false;",
									"            }                     ",
									"        }",
									"    }",
									"    //count will increase by one if function finds the new record date in the returned list",
									"    //function will return false if record is not found, (count==0) ",
									"    if(count>0)",
									"    {",
									"        return true;    //record exist and all fields match",
									"    }",
									"    return false;    //record not found",
									"}"
								],
								"type": "text/javascript"
							}
						}
					],
					"request": {
						"method": "GET",
						"header": [],
						"url": {
							"raw": "{{test}}post/{{postIdInstaVIDEO}}/record?from=2014-12-31&to={{dateNow}}",
							"host": [
								"{{test}}post"
							],
							"path": [
								"{{postIdInstaVIDEO}}",
								"record"
							],
							"query": [
								{
									"key": "from",
									"value": "2014-12-31"
								},
								{
									"key": "to",
									"value": "{{dateNow}}",
									"description": "set in pre test script of current folder"
								}
							]
						}
					},
					"response": []
				},
				{
					"name": "Update recordId",
					"event": [
						{
							"listen": "test",
							"script": {
								"exec": [
									"// will only update existing record ids",
									"// returns post and lates record even if no update was done",
									"",
									"var responseBody = pm.response.json();",
									"var requestBody = JSON.parse(pm.request.body.raw);",
									"",
									"//runns regardless of status",
									"pm.test(\"Required fields, impressions, views and reach are provided\", function(){",
									"    pm.expect(requestBody.record.impressions).to.not.equal(undefined);",
									"    pm.expect(requestBody.record.views).to.not.equal(undefined);",
									"    pm.expect(requestBody.record.reach).to.not.equal(undefined);",
									"})",
									"",
									"//save request to be able to validate if changes were made in get call",
									"pm.variables.set(\"updateRequest\", requestBody);",
									"",
									"// response from this call only shows the lates record so need to validate with another GET call ",
									"// to make sure an uoriginalRecord",
									"if(pm.response.code==200)",
									"{",
									"",
									"    //platform is not returned in get calls",
									"    //saving it from the request here so that it can be used in the revert PUT call",
									"    pm.environment.set(\"platform\", requestBody.record.platform);",
									"",
									"",
									"    // check if all fields have been updated",
									"    // record date is not required, will update existing record and keep old date in non is given",
									"    pm.test(\"Status 200 for recordId \"+ pm.request.url.path[4])",
									"}",
									"else if(pm.response.code==400)",
									"{",
									"    //The requested record date cannot be set to before the post date or to the same record date of the last update,",
									"    //(if an update has been made previously).",
									"    // will not update if post source = OTHER",
									"    if(responseBody.notes.userMessage!=undefined)",
									"    {",
									"        pm.test(\"Status 400, userMessage: \"+ responseBody.notes.userMessage, function(){",
									"            pm.expect(responseBody.notes.userMessage).to.be.oneOf([\"Record must be after post date\",",
									"                                                            \"Post already has a record for that date\",",
									"                                                            \"Can't update automatically fetched records\",",
									"                                                            \"Views must be greater than 0\",",
									"                                                            \"Impressions must be greater than 0\",",
									"                                                            \"Reach must be greater than 0\",",
									"                                                            \"Reach cannot be higher than impressions\",",
									"                                                            \"Likes cannot be higher than reach\",",
									"                                                            \"Record platform does not match post platform\",",
									"                                                            \"Saves cannot be higher than reach\",",
									"                                                            \"Views must be greater than or equal to reach\"]);",
									"        })",
									"    }",
									"    else if(responseBody.object===null )",
									"    {",
									"        pm.test(\"Platform is required, make sure it's valid\");",
									"    }",
									"}",
									"else if(pm.response.code==404)",
									"{",
									"    pm.test(\"Post id not found\", function(){",
									"        pm.expect(responseBody.object).to.equal(null);",
									"    })",
									"",
									"}",
									"else if (pm.response.code == 403) ",
									"{",
									"    pm.test(\"Unauthorised to make call, only allowed for hypetap\");",
									"}",
									"",
									"//---------------Functions",
									"",
									"function updateSuccessful()",
									"{",
									"    //not undefined means it was given in the request",
									"    if( (requestBody.record.likes !=undefined) &&",
									"        (responseBody.object.latestRecord.likes != requestBody.record.likes) )",
									"    {",
									"        return false;",
									"    }",
									"    else if( (requestBody.record.comments !=undefined) &&",
									"        (responseBody.object.latestRecord.comments != requestBody.record.comments) )",
									"    {",
									"        return false;",
									"    }",
									"    else if( (requestBody.record.impressions !=undefined) &&",
									"        (responseBody.object.latestRecord.impressions != requestBody.record.impressions) )",
									"    {",
									"        return false;",
									"    }    ",
									"    else if( (requestBody.record.reach !=undefined) &&",
									"        (responseBody.object.latestRecord.reach != requestBody.record.reach) )",
									"    {",
									"        return false;",
									"    }",
									"        else if( (requestBody.record.views !=undefined) &&",
									"        (responseBody.object.latestRecord.views != requestBody.record.views) )",
									"    {",
									"        return false;",
									"    }   ",
									"        else if( (requestBody.record.saves !=undefined)  &&",
									"        (responseBody.object.latestRecord.saves != requestBody.record.saves) )",
									"    {",
									"        return false;",
									"    }",
									"    else",
									"    {",
									"        return true;",
									"    }    ",
									"}",
									"",
									""
								],
								"type": "text/javascript"
							}
						},
						{
							"listen": "prerequest",
							"script": {
								"exec": [
									"pm.environment.set(\"updateNewRecordId\", pm.environment.get('recordBeforeUpdate').id)"
								],
								"type": "text/javascript"
							}
						}
					],
					"request": {
						"method": "PUT",
						"header": [],
						"body": {
							"mode": "raw",
							"raw": "{\n  \"record\": {\n    \"platform\": \"INSTAGRAM\",\n    \"comments\": 200,\n    \"likes\": 200,\n    \"impressions\": 200,\n    \"reach\": 200,\n    \"views\": 200,\n    \"saves\":200\n  }\n}",
							"options": {
								"raw": {
									"language": "json"
								}
							}
						},
						"url": {
							"raw": "{{test}}post/{{postIdInstaVIDEO}}/record/{{updateNewRecordId}}",
							"host": [
								"{{test}}post"
							],
							"path": [
								"{{postIdInstaVIDEO}}",
								"record",
								"{{updateNewRecordId}}"
							]
						}
					},
					"response": []
				},
				{
					"name": "Verify updates",
					"event": [
						{
							"listen": "test",
							"script": {
								"exec": [
									"var responseBody = pm.response.json();",
									"",
									"if(pm.response.code==200)",
									"{",
									"    ",
									"    if(responseBody.object.length==0)",
									"    {",
									"        pm.test(\"Status 200 no records returned\");",
									"    }",
									"    else",
									"    {        ",
									"        //if a record is found",
									"        //check if changes have been made from PUT call",
									"        if(getRecord()!=undefined)",
									"        {",
									"            pm.test(\"Update was successful\", function(){",
									"                pm.expect(updateSuccessful()).to.equal(true);",
									"            })",
									"        }",
									"        //will fail if this test is called without the collection runner",
									"        else",
									"        {",
									"            pm.test(\"No record found with given recordId from PUT call\", function(){",
									"                pm.expect(getRecord()).to.not.equal(undefined);",
									"            })",
									"",
									"        }",
									"",
									"        pm.test(\"Status 200, posts are within date range: \"+pm.request.url.query.toObject().from+\" - \"+pm.request.url.query.toObject().to, function(){",
									"            pm.expect(withinDates(pm.request.url.query.toObject().from, pm.request.url.query.toObject().to)).to.equal(true);",
									"        })",
									"    }",
									"}",
									"else if(pm.response.code==404)",
									"{",
									"    pm.test(\"Post id not found\", function(){",
									"        pm.expect(responseBody.object).to.equal(null);",
									"    })",
									"",
									"}",
									"else if (pm.response.code == 403) ",
									"{",
									"    pm.test(\"Unauthorised to make call, only allowed for hypetap\");",
									"}",
									"",
									"//-------------Functions",
									"",
									"function withinDates(from, to)",
									"{",
									"    for(let i =0; i<responseBody.object.length; ++i)",
									"    {",
									"        if(responseBody.object.dateCreated< from &&",
									"            responseBody.object.dateCreated>to)",
									"        {",
									"            return false;",
									"        }",
									"    }",
									"    return true;",
									"}",
									"",
									"//find record we're trying to update in PUT call",
									"function getRecord()",
									"{",
									"    for(let i = 0; i< responseBody.object.length; ++i)",
									"    {",
									"        if(responseBody.object[i].id == pm.variables.get(\"newRecordId\"))",
									"        {",
									"            return  responseBody.object[i];  //retun record if found",
									"        }",
									"    }",
									"}",
									"",
									"// variable \"updateRequest\" contains request from PUT call",
									"//getRecord() returns the record id, (from the response), which we tried to update in PUT call",
									"function updateSuccessful()",
									"{",
									"    //not undefined means it was given in the request",
									"    // field will be undefined in request if not given",
									"    if( (pm.variables.get(\"updateRequest\").record.likes !=undefined) &&",
									"        (getRecord().likes != pm.variables.get(\"updateRequest\").record.likes) )",
									"    {",
									"        return false;",
									"    }",
									"    else if( (pm.variables.get(\"updateRequest\").record.comments !=undefined) &&",
									"        (getRecord().comments != pm.variables.get(\"updateRequest\").record.comments) )",
									"    {",
									"        return false;",
									"    }",
									"    else if( (pm.variables.get(\"updateRequest\").record.impressions !=undefined) &&",
									"        (getRecord().impressions != pm.variables.get(\"updateRequest\").record.impressions) )",
									"    {",
									"        return false;",
									"    }    ",
									"    else if( (pm.variables.get(\"updateRequest\").record.reach !=undefined) &&",
									"        (getRecord().reach != pm.variables.get(\"updateRequest\").record.reach) )",
									"    {",
									"        return false;",
									"    }",
									"        else if( (pm.variables.get(\"updateRequest\").record.views !=undefined) &&",
									"        (getRecord().views != pm.variables.get(\"updateRequest\").record.views) )",
									"    {",
									"        return false;",
									"    }   ",
									"        else if( (pm.variables.get(\"updateRequest\").record.saves !=undefined)  &&",
									"        (getRecord().saves != pm.variables.get(\"updateRequest\").record.saves) )",
									"    {",
									"        return false;",
									"    }",
									"    else",
									"    {",
									"        return true;",
									"    }    ",
									"}",
									"",
									""
								],
								"type": "text/javascript"
							}
						}
					],
					"request": {
						"method": "GET",
						"header": [],
						"url": {
							"raw": "{{test}}post/{{postIdInstaVIDEO}}/record?from=2014-12-31&to={{dateNow}}",
							"host": [
								"{{test}}post"
							],
							"path": [
								"{{postIdInstaVIDEO}}",
								"record"
							],
							"query": [
								{
									"key": "from",
									"value": "2014-12-31"
								},
								{
									"key": "to",
									"value": "{{dateNow}}"
								}
							]
						}
					},
					"response": []
				},
				{
					"name": "Revert updates",
					"event": [
						{
							"listen": "test",
							"script": {
								"exec": [
									"// will only update existing record ids",
									"// returns post and lates record even if no update was done",
									"",
									"var responseBody = pm.response.json();",
									"var requestBody = JSON.parse(pm.request.body.raw);",
									"",
									"pm.test(\"Required fields, impressions, views and reach are provided\", function(){",
									"    pm.expect(requestBody.record.impressions).to.not.equal(undefined);",
									"    pm.expect(requestBody.record.views).to.not.equal(undefined);",
									"    pm.expect(requestBody.record.reach).to.not.equal(undefined);",
									"})",
									"",
									"",
									"// response from this call only shows the lates record so need to validate with another GET call ",
									"// to make sure an update was made",
									"if(pm.response.code==200)",
									"{",
									"    //save request to be able to validate if changes were made in get call",
									"    pm.variables.set(\"updateRequest\", requestBody);",
									"",
									"    // check if all fields have been updated",
									"    // record date is not required, will update existing record and keep old date in non is given",
									"    pm.test(\"Status 200 for recordId \"+ pm.request.url.path[4])",
									"}",
									"else if(pm.response.code==400)",
									"{",
									"    //The requested record date cannot be set to before the post date or to the same record date of the last update,",
									"    //(if an update has been made previously).",
									"    // will not update if post source = OTHER",
									"    if(responseBody.notes.userMessage!=undefined)",
									"    {",
									"        pm.test(\"Status 400, userMessage: \"+ responseBody.notes.userMessage, function(){",
									"            pm.expect(responseBody.notes.userMessage).to.be.oneOf([\"Record must be after post date\",",
									"                                                            \"Post already has a record for that date\",",
									"                                                            \"Can't update automatically fetched records\",",
									"                                                            \"Views must be greater than 0\",",
									"                                                            \"Impressions must be greater than 0\",",
									"                                                            \"Reach must be greater than 0\",",
									"                                                            \"Reach cannot be higher than impressions\",",
									"                                                            \"Likes cannot be higher than reach\",",
									"                                                            \"Record platform does not match post platform\",",
									"                                                            \"Saves cannot be higher than reach\",",
									"                                                            \"Views must be greater than or equal to reach\"]);",
									"        })",
									"    }",
									"    else if(responseBody.object===null )",
									"    {",
									"        pm.test(\"Platform is required, make sure it's valid\");",
									"    }",
									"}",
									"else if(pm.response.code==404)",
									"{",
									"    pm.test(\"Post id not found\", function(){",
									"        pm.expect(responseBody.object).to.equal(null);",
									"    })",
									"",
									"}",
									"else if (pm.response.code == 403) ",
									"{",
									"    pm.test(\"Unauthorised to make call, only allowed for hypetap\");",
									"}",
									"",
									"//---------------Functions",
									""
								],
								"type": "text/javascript"
							}
						},
						{
							"listen": "prerequest",
							"script": {
								"exec": [
									"pm.environment.set(\"comments\", pm.environment.get('recordBeforeUpdate').comments)",
									"pm.environment.set(\"likes\",pm.environment.get('recordBeforeUpdate').likes)",
									"pm.environment.set(\"impressions\", pm.environment.get('recordBeforeUpdate').impressions)",
									"pm.environment.set(\"reach\", pm.environment.get('recordBeforeUpdate').reach)",
									"pm.environment.set(\"views\", pm.environment.get('recordBeforeUpdate').views)",
									"pm.environment.set(\"saves\", pm.environment.get('recordBeforeUpdate').saves)",
									"",
									"pm.environment.set(\"recordDate\",pm.environment.get('recordBeforeUpdate').dateCreated)",
									"//pm.environment.set(\"platform\", JSON.parse(pm.environment.get('platform')))",
									"",
									"",
									""
								],
								"type": "text/javascript"
							}
						}
					],
					"request": {
						"method": "PUT",
						"header": [],
						"body": {
							"mode": "raw",
							"raw": "{\n  \"record\": {\n    \"platform\": \"{{platform}}\",\n    \"comments\": {{comments}},\n    \"likes\": {{likes}},\n    \"impressions\": {{impressions}},\n    \"reach\": {{reach}},\n    \"views\": {{views}},\n    \"saves\":{{saves}}\n  }\n}",
							"options": {
								"raw": {
									"language": "json"
								}
							}
						},
						"url": {
							"raw": "{{test}}post/{{postIdInstaVIDEO}}/record/{{updateNewRecordId}}",
							"host": [
								"{{test}}post"
							],
							"path": [
								"{{postIdInstaVIDEO}}",
								"record",
								"{{updateNewRecordId}}"
							]
						}
					},
					"response": []
				},
				{
					"name": "Verify updates",
					"event": [
						{
							"listen": "test",
							"script": {
								"exec": [
									"var responseBody = pm.response.json();",
									"",
									"if(pm.response.code==200)",
									"{",
									"    ",
									"    if(responseBody.object.length==0)",
									"    {",
									"        pm.test(\"Status 200 no records returned\");",
									"    }",
									"    else",
									"    {        ",
									"        //if a record is found",
									"        //check if changes have been made from PUT call",
									"        if(getRecord()!=undefined)",
									"        {",
									"            pm.test(\"Update was successful\", function(){",
									"                pm.expect(updateSuccessful()).to.equal(true);",
									"            })",
									"        }",
									"        //will fail if this test is called without the collection runner",
									"        else",
									"        {",
									"            pm.test(\"No record found with given recordId from PUT call\", function(){",
									"                pm.expect(getRecord()).to.not.equal(undefined);",
									"            })",
									"",
									"        }",
									"",
									"        pm.test(\"Status 200, posts are within date range: \"+pm.request.url.query.toObject().from+\" - \"+pm.request.url.query.toObject().to, function(){",
									"            pm.expect(withinDates(pm.request.url.query.toObject().from, pm.request.url.query.toObject().to)).to.equal(true);",
									"        })",
									"    }",
									"}",
									"else if(pm.response.code==404)",
									"{",
									"    pm.test(\"Post id not found\", function(){",
									"        pm.expect(responseBody.object).to.equal(null);",
									"    })",
									"",
									"}",
									"else if (pm.response.code == 403) ",
									"{",
									"    pm.test(\"Unauthorised to make call, only allowed for hypetap\");",
									"}",
									"",
									"//-------------Functions",
									"",
									"function withinDates(from, to)",
									"{",
									"    for(let i =0; i<responseBody.object.length; ++i)",
									"    {",
									"        if(responseBody.object.dateCreated< from &&",
									"            responseBody.object.dateCreated>to)",
									"        {",
									"            return false;",
									"        }",
									"    }",
									"    return true;",
									"}",
									"",
									"//find record we're trying to update in PUT call",
									"function getRecord()",
									"{",
									"    for(let i = 0; i< responseBody.object.length; ++i)",
									"    {",
									"        if(responseBody.object[i].id == pm.variables.get(\"newRecordId\"))",
									"        {",
									"            return  responseBody.object[i];  //retun record if found",
									"        }",
									"    }",
									"}",
									"",
									"// variable \"updateRequest\" contains request from PUT call",
									"//getRecord() returns the record id, (from the response), which we tried to update in PUT call",
									"function updateSuccessful()",
									"{",
									"    //not undefined means it was given in the request",
									"    // field will be undefined in request if not given",
									"    if( (pm.variables.get(\"updateRequest\").record.likes !=undefined) &&",
									"        (getRecord().likes != pm.variables.get(\"updateRequest\").record.likes) )",
									"    {",
									"        return false;",
									"    }",
									"    else if( (pm.variables.get(\"updateRequest\").record.comments !=undefined) &&",
									"        (getRecord().comments != pm.variables.get(\"updateRequest\").record.comments) )",
									"    {",
									"        return false;",
									"    }",
									"    else if( (pm.variables.get(\"updateRequest\").record.impressions !=undefined) &&",
									"        (getRecord().impressions != pm.variables.get(\"updateRequest\").record.impressions) )",
									"    {",
									"        return false;",
									"    }    ",
									"    else if( (pm.variables.get(\"updateRequest\").record.reach !=undefined) &&",
									"        (getRecord().reach != pm.variables.get(\"updateRequest\").record.reach) )",
									"    {",
									"        return false;",
									"    }",
									"        else if( (pm.variables.get(\"updateRequest\").record.views !=undefined) &&",
									"        (getRecord().views != pm.variables.get(\"updateRequest\").record.views) )",
									"    {",
									"        return false;",
									"    }   ",
									"        else if( (pm.variables.get(\"updateRequest\").record.saves !=undefined)  &&",
									"        (getRecord().saves != pm.variables.get(\"updateRequest\").record.saves) )",
									"    {",
									"        return false;",
									"    }",
									"    else",
									"    {",
									"        return true;",
									"    }    ",
									"}",
									"",
									""
								],
								"type": "text/javascript"
							}
						}
					],
					"request": {
						"method": "GET",
						"header": [],
						"url": {
							"raw": "{{test}}post/{{postIdInstaVIDEO}}/record?from=2014-12-31&to={{dateNow}}",
							"host": [
								"{{test}}post"
							],
							"path": [
								"{{postIdInstaVIDEO}}",
								"record"
							],
							"query": [
								{
									"key": "from",
									"value": "2014-12-31"
								},
								{
									"key": "to",
									"value": "{{dateNow}}"
								}
							]
						}
					},
					"response": []
				},
				{
					"name": "Delete Record ({postId}/record/{recordId})",
					"event": [
						{
							"listen": "test",
							"script": {
								"exec": [
									"// Will not delete for a post with PostSource set to OTHER as record data is not applicable to those posts.",
									"",
									"if(pm.response.code==200)",
									"{",
									"    pm.test(\"Status 200. Deleted record with id \"+ pm.request.url.path[4]);",
									"}",
									"else if (pm.response.code == 403) ",
									"{",
									"    pm.test(\"Unauthorised to make call, only allowed for hypetap\");",
									"}"
								],
								"type": "text/javascript"
							}
						}
					],
					"request": {
						"method": "DELETE",
						"header": [],
						"body": {
							"mode": "raw",
							"raw": ""
						},
						"url": {
							"raw": "{{test}}post/{{postIdInstaVIDEO}}/record/{{newRecordId}}",
							"host": [
								"{{test}}post"
							],
							"path": [
								"{{postIdInstaVIDEO}}",
								"record",
								"{{newRecordId}}"
							]
						}
					},
					"response": []
				},
				{
					"name": "Records After (requires date range)",
					"event": [
						{
							"listen": "test",
							"script": {
								"exec": [
									"var responseBody = pm.response.json();",
									"",
									"if(pm.response.code==200)",
									"{",
									"    if(responseBody.object.length==0)",
									"    {",
									"        pm.test(\"Status 200 no records returned for postId \" + pm.request.url.path[2]);",
									"    }",
									"    else",
									"    {",
									"",
									"        pm.test(\"Status 200, for postId \" + pm.request.url.path[2]);",
									"",
									"        //both dates has to be given for call to work",
									"        pm.test(\"Records returned: \" + responseBody.object.length+ \". Records are within date range: \"+pm.request.url.query.toObject().from+\" - \"+pm.request.url.query.toObject().to, function(){",
									"            pm.expect(withinDates(pm.request.url.query.toObject().from, pm.request.url.query.toObject().to)).to.equal(true);",
									"        })",
									"",
									"        pm.test(\"Records have decrease by one, (total is same as before POST call)\", function(){",
									"            pm.expect(pm.variables.get(\"totalRecordsBefore\")).to.equal(responseBody.object.length)",
									"        })",
									"",
									"        pm.test(\"Record doesn't exist, was deleted successfuly\", function(){",
									"            pm.expect(recordExist( responseBody.object, pm.variables.get(\"newRecordId\")) ).to.equal(false);",
									"        })",
									"    }",
									"}",
									"else if(pm.response.code==404)",
									"{",
									"    pm.test(\"Post id not found\", function(){",
									"        pm.expect(responseBody.object).to.equal(null);",
									"    })",
									"",
									"}",
									"else if (pm.response.code == 403) ",
									"{",
									"    pm.test(\"Unauthorised to make call, only allowed for hypetap\");",
									"}",
									"",
									"//-------------Functions",
									"",
									"function withinDates(from, to)",
									"{",
									"    for(let i =0; i<responseBody.object.length; ++i)",
									"    {",
									"        if( (new Date(responseBody.object[i].dateCreated).getTime()< new Date(from).getTime() ) &&",
									"            ( new Date(responseBody.object[i].dateCreated).getTime() >new Date(to).getTime() ) )",
									"        {",
									"            return false;",
									"        }",
									"    }",
									"    return true;",
									"",
									"}",
									"// checks if the new record, (from reuest in POST call), exist and if the data match",
									"function recordExist(list, recordId)",
									"{",
									"    for(let i=0; i<list.length; ++i)",
									"    {",
									"        ",
									"        if(recordId==list[i].id)",
									"        {",
									"            return true;",
									"        }",
									"",
									"    }",
									"    return false;    //record not found",
									"}"
								],
								"type": "text/javascript"
							}
						}
					],
					"request": {
						"method": "GET",
						"header": [],
						"url": {
							"raw": "{{test}}post/{{postIdInstaVIDEO}}/record?from=2014-12-31&to={{dateNow}}",
							"host": [
								"{{test}}post"
							],
							"path": [
								"{{postIdInstaVIDEO}}",
								"record"
							],
							"query": [
								{
									"key": "from",
									"value": "2014-12-31"
								},
								{
									"key": "to",
									"value": "{{dateNow}}",
									"description": "set in pre test script of current folder"
								}
							]
						}
					},
					"response": []
				}
			],
			"event": [
				{
					"listen": "prerequest",
					"script": {
						"type": "text/javascript",
						"exec": [
							"//sets variable \"dateNow\"  with current date",
							"//GET records requires a date range",
							"month = '' + (new Date().getMonth() + 1)",
							"if(month.length<2 )",
							"{",
							"    month='0'+month;",
							"}",
							"",
							"if(new Date().getDate().length<2 )",
							"{",
							"    day='0'+new Date().getDate();",
							"}",
							"else ",
							"{",
							"    day=new Date().getDate();",
							"}",
							"",
							"date = [ new Date().getFullYear(), month, day].join('-');",
							"",
							"pm.variables.set(\"dateNow\", date);"
						]
					}
				},
				{
					"listen": "test",
					"script": {
						"type": "text/javascript",
						"exec": [
							""
						]
					}
				}
			]
		},
		{
			"name": "NEG INSTA VIDEO - Create, Update and Delete Record -- 0 data",
			"item": [
				{
					"name": "BOSS login",
					"event": [
						{
							"listen": "test",
							"script": {
								"exec": [
									"pm.test(\"Status code is 200\", function () {",
									"    pm.response.to.have.status(200);",
									"});",
									""
								],
								"type": "text/javascript"
							}
						}
					],
					"request": {
						"method": "POST",
						"header": [
							{
								"warning": "This is a duplicate header and will be overridden by the Content-Type header generated by Postman.",
								"key": "Content-Type",
								"value": "application/x-www-form-urlencoded",
								"type": "text"
							}
						],
						"body": {
							"mode": "urlencoded",
							"urlencoded": [
								{
									"key": "username",
									"value": "dumbanddummy1+brooke@gmail.com",
									"description": "dumbanddummy1+brooke@gmail.com",
									"type": "text"
								},
								{
									"key": "password",
									"value": "hypetap1",
									"type": "text"
								},
								{
									"key": "remember-me",
									"value": "true",
									"type": "text"
								}
							]
						},
						"url": {
							"raw": "{{test}}login",
							"host": [
								"{{test}}login"
							]
						}
					},
					"response": []
				},
				{
					"name": "Records Before (requires date range)",
					"event": [
						{
							"listen": "test",
							"script": {
								"exec": [
									"var responseBody = pm.response.json();",
									"",
									"if(pm.response.code==200)",
									"{",
									"    if(responseBody.object.length==0)",
									"    {",
									"        pm.test(\"Status 200 no records returned for postId \" + pm.request.url.path[2]);",
									"    }",
									"    else",
									"    {",
									"        //saves number of records returned to be able to check if number has increased after POST, (add new record) call",
									"        pm.variables.set(\"totalRecordsBefore\", responseBody.object.length);",
									"",
									"        pm.test(\"Status 200, for postId \" + pm.request.url.path[2]);",
									"",
									"        //both dates has to be given for call to work",
									"        pm.test(\"Records returned: \" + responseBody.object.length+ \". Records are within date range: \"+pm.request.url.query.toObject().from+\" - \"+pm.request.url.query.toObject().to, function(){",
									"            pm.expect(withinDates(pm.request.url.query.toObject().from, pm.request.url.query.toObject().to)).to.equal(true);",
									"        })",
									"",
									"    }",
									"}",
									"else if(pm.response.code==404)",
									"{",
									"    pm.test(\"Post id not found\", function(){",
									"        pm.expect(responseBody.object).to.equal(null);",
									"    })",
									"",
									"}",
									"else if (pm.response.code == 403) ",
									"{",
									"    pm.test(\"Unauthorised to make call, only allowed for hypetap\");",
									"}",
									"",
									"//-------------Functions",
									"",
									"function withinDates(from, to)",
									"{",
									"    for(let i =0; i<responseBody.object.length; ++i)",
									"    {",
									"        if( (new Date(responseBody.object[i].dateCreated).getTime()< new Date(from).getTime() ) &&",
									"            ( new Date(responseBody.object[i].dateCreated).getTime() >new Date(to).getTime() ) )",
									"        {",
									"            return false;",
									"        }",
									"    }",
									"    return true;",
									"",
									"}",
									""
								],
								"type": "text/javascript"
							}
						}
					],
					"request": {
						"method": "GET",
						"header": [],
						"url": {
							"raw": "{{test}}post/{{postIdInstaVIDEO}}/record?from=2014-12-31&to={{dateNow}}",
							"host": [
								"{{test}}post"
							],
							"path": [
								"{{postIdInstaVIDEO}}",
								"record"
							],
							"query": [
								{
									"key": "from",
									"value": "2014-12-31"
								},
								{
									"key": "to",
									"value": "{{dateNow}}",
									"description": "set in pre test script of current folder"
								}
							]
						}
					},
					"response": []
				},
				{
					"name": "Create Record ({postId}/record)",
					"event": [
						{
							"listen": "test",
							"script": {
								"exec": [
									"var responseBody = pm.response.json();",
									"var requestBody = JSON.parse(pm.request.body.raw);",
									"",
									"//runns regardless of status",
									"pm.test(\"Required fields, impressions, views, reach and recordDate are provided\", function(){",
									"    pm.expect(requestBody.record.impressions).to.not.equal(undefined);",
									"    pm.expect(requestBody.record.views).to.not.equal(undefined);",
									"    pm.expect(requestBody.record.reach).to.not.equal(undefined);",
									"    pm.expect(requestBody.recordDate).to.not.equal(undefined);",
									"})",
									"",
									"if(pm.response.code==200)",
									"{",
									"    //save request to be ale to confirm that it was added with the correct data. ",
									"    //records are not allowed to be for the same date, so date is unique",
									"    pm.variables.set(\"newRecord\", requestBody);",
									"",
									"    pm.test(\"Status 200. Returns post corresponding to given postId \"+ pm.request.url.path[2], function(){",
									"        pm.expect( pm.request.url.path[2]).to.equal(responseBody.object.id);",
									"    })",
									"",
									"    //the new record has to be after the post date",
									"    //need to convert dates to be able to compare since they are of the type string",
									"    pm.test(\"The new record is after post date. The date of added record \" + requestBody.recordDate, function(){",
									"        pm.expect(new Date(requestBody.recordDate).getTime()> new Date(responseBody.object.datePosted).getTime() ).to.equal(true);",
									"    })",
									"",
									"}",
									"else if(pm.response.code==400)",
									"{",
									"    //The requested record date cannot be set to before the post date or to the same record date of the last update,",
									"    //(if an update has been made previously).",
									"    // will not update if post source = OTHER",
									"    if(responseBody.notes.userMessage!=undefined)",
									"    {",
									"        pm.test(\"Status 400, userMessage: \"+ responseBody.notes.userMessage, function(){",
									"            pm.expect(responseBody.notes.userMessage).to.be.oneOf([",
									"                                                            \"Cannot update posts fetched via APIs\",",
									"                                                            \"A record must have a date\",",
									"                                                            \"Record must be after post date\",",
									"                                                            \"Post already has a record for that date\",",
									"                                                            \"Can't update automatically fetched records\",",
									"                                                            \"Views must be greater than 0\",",
									"                                                            \"Impressions must be greater than 0\",",
									"                                                            \"Reach must be greater than 0\",",
									"                                                            \"Reach cannot be higher than impressions\",",
									"                                                            \"Likes cannot be higher than reach\",",
									"                                                            \"Record platform does not match post platform\",",
									"                                                            \"Saves cannot be higher than reach\",",
									"                                                            \"Views must equal impressions\",",
									"                                                            \"Views must be greater than or equal to reach\"]);",
									"        })",
									"    }",
									"    else if(responseBody.object===null )",
									"    {",
									"        pm.test(\"Platform is required, make sure it's valid\");",
									"    }",
									"}",
									"else if (pm.response.code == 403) ",
									"{",
									"    pm.test(\"Unauthorised to make call, only allowed for hypetap\");",
									"}",
									"",
									"//---------------Functions",
									""
								],
								"type": "text/javascript"
							}
						}
					],
					"request": {
						"method": "POST",
						"header": [],
						"body": {
							"mode": "raw",
							"raw": "{\n  \"record\": {\n    \"platform\": \"INSTAGRAM\",\n    \"comments\": \"\",\n    \"likes\": \"\",\n    \"impressions\": \"\",\n    \"reach\": \"\",\n    \"views\":\"\",\n    \"saves\": \"\"\n  },\n  \"recordDate\": \"2021-09-15\"\n}",
							"options": {
								"raw": {
									"language": "json"
								}
							}
						},
						"url": {
							"raw": "{{test}}post/{{postIdInstaVIDEO}}/record",
							"host": [
								"{{test}}post"
							],
							"path": [
								"{{postIdInstaVIDEO}}",
								"record"
							]
						}
					},
					"response": []
				},
				{
					"name": "Records After (requires date range)",
					"event": [
						{
							"listen": "test",
							"script": {
								"exec": [
									"var responseBody = pm.response.json();",
									"",
									"if(pm.response.code==200)",
									"{",
									"    if(responseBody.object.length==0)",
									"    {",
									"        pm.test(\"Status 200 no records returned for postId \" + pm.request.url.path[2]);",
									"    }",
									"    else",
									"    {",
									"",
									"        pm.test(\"Status 200, for postId \" + pm.request.url.path[2]);",
									"",
									"        //both dates has to be given for call to work",
									"        pm.test(\"Records returned: \" + responseBody.object.length+ \". Records are within date range: \"+pm.request.url.query.toObject().from+\" - \"+pm.request.url.query.toObject().to, function(){",
									"            pm.expect(withinDates(pm.request.url.query.toObject().from, pm.request.url.query.toObject().to)).to.equal(true);",
									"        })",
									"",
									"        pm.test(\"Records have not increase\", function(){",
									"            pm.expect(pm.variables.get(\"totalRecordsBefore\")).to.equal(responseBody.object.length)",
									"        })",
									"",
									"    }",
									"}",
									"else if(pm.response.code==404)",
									"{",
									"    pm.test(\"Post id not found\", function(){",
									"        pm.expect(responseBody.object).to.equal(null);",
									"    })",
									"",
									"}",
									"else if (pm.response.code == 403) ",
									"{",
									"    pm.test(\"Unauthorised to make call, only allowed for hypetap\");",
									"}",
									"",
									"//-------------Functions",
									"",
									"function withinDates(from, to)",
									"{",
									"    for(let i =0; i<responseBody.object.length; ++i)",
									"    {",
									"        if( (new Date(responseBody.object[i].dateCreated).getTime()< new Date(from).getTime() ) &&",
									"            ( new Date(responseBody.object[i].dateCreated).getTime() >new Date(to).getTime() ) )",
									"        {",
									"            return false;",
									"        }",
									"    }",
									"    return true;",
									"",
									"}",
									"// checks if the new record, (from reuest in POST call), exist and if the data match",
									"function validateNewRecord(list, record)",
									"{",
									"    count=0;",
									"    for(let i=0; i<list.length; ++i)",
									"    {",
									"        //generate new dates to be able to convert string to date format",
									"        //if they are equal then it's the same record. Only one record can exist for one date",
									"        if(new Date(list[i].dateCreated).getTime() === new Date(record.recordDate).getTime())",
									"        {",
									"           pm.environment.set(\"recordBeforeUpdate\",list[i]);",
									"            //saves id to be able to delete record ",
									"            pm.variables.set(\"newRecordId\", list[i].id);",
									"",
									"            count+= 1;",
									"            //if likes is given and it's not the same value as response then return false, data doesn't match",
									"            if( (record.record.likes!=undefined) && (record.record.likes!=list[i].likes) )",
									"            {",
									"                return false;",
									"            }",
									"            else if( (record.record.comments!=undefined) && (record.record.comments!=list[i].comments) )",
									"            {",
									"                return false;",
									"            }",
									"            else if( (record.record.impressions!=undefined) && (record.record.impressions!=list[i].impressions) )",
									"            {",
									"                return false;",
									"            }",
									"            else if( (record.record.reach!=undefined) && (record.record.reach!=list[i].reach) )",
									"            {",
									"                return false;",
									"            }",
									"            else if( (record.record.views!=undefined) && (record.record.views!=list[i].views) )",
									"            {",
									"                return false;",
									"            }",
									"            else if( (record.record.saves!=undefined) && (record.record.saves!=list[i].saves) )",
									"            {",
									"                return false;",
									"            }                     ",
									"        }",
									"    }",
									"    //count will increase by one if function finds the new record date in the returned list",
									"    //function will return false if record is not found, (count==0) ",
									"    if(count>0)",
									"    {",
									"        return true;    //record exist and all fields match",
									"    }",
									"    return false;    //record not found",
									"}"
								],
								"type": "text/javascript"
							}
						}
					],
					"request": {
						"method": "GET",
						"header": [],
						"url": {
							"raw": "{{test}}post/{{postIdInstaVIDEO}}/record?from=2014-12-31&to={{dateNow}}",
							"host": [
								"{{test}}post"
							],
							"path": [
								"{{postIdInstaVIDEO}}",
								"record"
							],
							"query": [
								{
									"key": "from",
									"value": "2014-12-31"
								},
								{
									"key": "to",
									"value": "{{dateNow}}",
									"description": "set in pre test script of current folder"
								}
							]
						}
					},
					"response": []
				}
			],
			"event": [
				{
					"listen": "prerequest",
					"script": {
						"type": "text/javascript",
						"exec": [
							"//sets variable \"dateNow\"  with current date",
							"//GET records requires a date range",
							"month = '' + (new Date().getMonth() + 1)",
							"if(month.length<2 )",
							"{",
							"    month='0'+month;",
							"}",
							"",
							"if(new Date().getDate().length<2 )",
							"{",
							"    day='0'+new Date().getDate();",
							"}",
							"else ",
							"{",
							"    day=new Date().getDate();",
							"}",
							"",
							"date = [ new Date().getFullYear(), month, day].join('-');",
							"",
							"pm.variables.set(\"dateNow\", date);"
						]
					}
				},
				{
					"listen": "test",
					"script": {
						"type": "text/javascript",
						"exec": [
							""
						]
					}
				}
			]
		},
		{
			"name": "IGTV - Create, Update and Delete Record",
			"item": [
				{
					"name": "BOSS login",
					"event": [
						{
							"listen": "test",
							"script": {
								"exec": [
									"pm.test(\"Status code is 200\", function () {",
									"    pm.response.to.have.status(200);",
									"});",
									""
								],
								"type": "text/javascript"
							}
						}
					],
					"request": {
						"method": "POST",
						"header": [
							{
								"warning": "This is a duplicate header and will be overridden by the Content-Type header generated by Postman.",
								"key": "Content-Type",
								"value": "application/x-www-form-urlencoded",
								"type": "text"
							}
						],
						"body": {
							"mode": "urlencoded",
							"urlencoded": [
								{
									"key": "username",
									"value": "dumbanddummy1+brooke@gmail.com",
									"description": "dumbanddummy1+brooke@gmail.com",
									"type": "text"
								},
								{
									"key": "password",
									"value": "hypetap1",
									"type": "text"
								},
								{
									"key": "remember-me",
									"value": "true",
									"type": "text"
								}
							]
						},
						"url": {
							"raw": "{{test}}login",
							"host": [
								"{{test}}login"
							]
						}
					},
					"response": []
				},
				{
					"name": "Records Before (requires date range)",
					"event": [
						{
							"listen": "test",
							"script": {
								"exec": [
									"var responseBody = pm.response.json();",
									"",
									"if(pm.response.code==200)",
									"{",
									"    if(responseBody.object.length==0)",
									"    {",
									"        pm.test(\"Status 200 no records returned for postId \" + pm.request.url.path[2]);",
									"    }",
									"    else",
									"    {",
									"        //saves number of records returned to be able to check if number has increased after POST, (add new record) call",
									"        pm.variables.set(\"totalRecordsBefore\", responseBody.object.length);",
									"",
									"        pm.test(\"Status 200, for postId \" + pm.request.url.path[2]);",
									"",
									"        //both dates has to be given for call to work",
									"        pm.test(\"Records returned: \" + responseBody.object.length+ \". Records are within date range: \"+pm.request.url.query.toObject().from+\" - \"+pm.request.url.query.toObject().to, function(){",
									"            pm.expect(withinDates(pm.request.url.query.toObject().from, pm.request.url.query.toObject().to)).to.equal(true);",
									"        })",
									"",
									"    }",
									"}",
									"else if(pm.response.code==404)",
									"{",
									"    pm.test(\"Post id not found\", function(){",
									"        pm.expect(responseBody.object).to.equal(null);",
									"    })",
									"",
									"}",
									"else if (pm.response.code == 403) ",
									"{",
									"    pm.test(\"Unauthorised to make call, only allowed for hypetap\");",
									"}",
									"",
									"//-------------Functions",
									"",
									"function withinDates(from, to)",
									"{",
									"    for(let i =0; i<responseBody.object.length; ++i)",
									"    {",
									"        if( (new Date(responseBody.object[i].dateCreated).getTime()< new Date(from).getTime() ) &&",
									"            ( new Date(responseBody.object[i].dateCreated).getTime() >new Date(to).getTime() ) )",
									"        {",
									"            return false;",
									"        }",
									"    }",
									"    return true;",
									"",
									"}",
									""
								],
								"type": "text/javascript"
							}
						}
					],
					"request": {
						"method": "GET",
						"header": [],
						"url": {
							"raw": "{{test}}post/{{postIdIGTV}}/record?from=2014-12-31&to={{dateNow}}",
							"host": [
								"{{test}}post"
							],
							"path": [
								"{{postIdIGTV}}",
								"record"
							],
							"query": [
								{
									"key": "from",
									"value": "2014-12-31"
								},
								{
									"key": "to",
									"value": "{{dateNow}}",
									"description": "set in pre test script of current folder"
								}
							]
						}
					},
					"response": []
				},
				{
					"name": "Create Record ({postId}/record)",
					"event": [
						{
							"listen": "test",
							"script": {
								"exec": [
									"var responseBody = pm.response.json();",
									"var requestBody = JSON.parse(pm.request.body.raw);",
									"",
									"//runns regardless of status",
									"pm.test(\"Required fields, impressions, views, reach and recordDate are provided\", function(){",
									"    pm.expect(requestBody.record.impressions).to.not.equal(undefined);",
									"    pm.expect(requestBody.record.views).to.not.equal(undefined);",
									"    pm.expect(requestBody.record.reach).to.not.equal(undefined);",
									"    pm.expect(requestBody.recordDate).to.not.equal(undefined);",
									"})",
									"",
									"if(pm.response.code==200)",
									"{",
									"    //save request to be ale to confirm that it was added with the correct data. ",
									"    //records are not allowed to be for the same date, so date is unique",
									"    pm.variables.set(\"newRecord\", requestBody);",
									"",
									"    pm.test(\"Status 200. Returns post corresponding to given postId \"+ pm.request.url.path[2], function(){",
									"        pm.expect( pm.request.url.path[2]).to.equal(responseBody.object.id);",
									"    })",
									"",
									"    //the new record has to be after the post date",
									"    //need to convert dates to be able to compare since they are of the type string",
									"    pm.test(\"The new record is after post date. The date of added record \" + requestBody.recordDate, function(){",
									"        pm.expect(new Date(requestBody.recordDate).getTime()> new Date(responseBody.object.datePosted).getTime() ).to.equal(true);",
									"    })",
									"",
									"}",
									"else if(pm.response.code==400)",
									"{",
									"    //The requested record date cannot be set to before the post date or to the same record date of the last update,",
									"    //(if an update has been made previously).",
									"    // will not update if post source = OTHER",
									"    if(responseBody.notes.userMessage!=undefined)",
									"    {",
									"        pm.test(\"Status 400, userMessage: \"+ responseBody.notes.userMessage, function(){",
									"            pm.expect(responseBody.notes.userMessage).to.be.oneOf([",
									"                                                            \"Cannot update posts fetched via APIs\",",
									"                                                            \"A record must have a date\",",
									"                                                            \"Record must be after post date\",",
									"                                                            \"Post already has a record for that date\",",
									"                                                            \"Can't update automatically fetched records\",",
									"                                                            \"Views must be greater than 0\",",
									"                                                            \"Impressions must be greater than 0\",",
									"                                                            \"Reach must be greater than 0\",",
									"                                                            \"Reach cannot be higher than impressions\",",
									"                                                            \"Likes cannot be higher than reach\",",
									"                                                            \"Record platform does not match post platform\",",
									"                                                            \"Saves cannot be higher than reach\",",
									"                                                            \"Views must equal impressions\",",
									"                                                            \"Views must be greater than or equal to reach\"]);",
									"        })",
									"    }",
									"    else if(responseBody.object===null )",
									"    {",
									"        pm.test(\"Platform is required, make sure it's valid\");",
									"    }",
									"}",
									"else if (pm.response.code == 403) ",
									"{",
									"    pm.test(\"Unauthorised to make call, only allowed for hypetap\");",
									"}",
									"",
									"//---------------Functions",
									""
								],
								"type": "text/javascript"
							}
						}
					],
					"request": {
						"method": "POST",
						"header": [],
						"body": {
							"mode": "raw",
							"raw": "{\n  \"record\": {\n    \"platform\": \"INSTAGRAM\",\n    \"comments\": 100,\n    \"likes\": 100,\n    \"impressions\": 100,\n    \"reach\": 100,\n    \"views\":100,\n    \"saves\": 100\n  },\n  \"recordDate\": \"2021-09-15\"\n}",
							"options": {
								"raw": {
									"language": "json"
								}
							}
						},
						"url": {
							"raw": "{{test}}post/{{postIdIGTV}}/record",
							"host": [
								"{{test}}post"
							],
							"path": [
								"{{postIdIGTV}}",
								"record"
							]
						}
					},
					"response": []
				},
				{
					"name": "Records After (requires date range)",
					"event": [
						{
							"listen": "test",
							"script": {
								"exec": [
									"var responseBody = pm.response.json();",
									"",
									"if(pm.response.code==200)",
									"{",
									"    if(responseBody.object.length==0)",
									"    {",
									"        pm.test(\"Status 200 no records returned for postId \" + pm.request.url.path[2]);",
									"    }",
									"    else",
									"    {",
									"",
									"        pm.test(\"Status 200, for postId \" + pm.request.url.path[2]);",
									"",
									"        //both dates has to be given for call to work",
									"        pm.test(\"Records returned: \" + responseBody.object.length+ \". Records are within date range: \"+pm.request.url.query.toObject().from+\" - \"+pm.request.url.query.toObject().to, function(){",
									"            pm.expect(withinDates(pm.request.url.query.toObject().from, pm.request.url.query.toObject().to)).to.equal(true);",
									"        })",
									"",
									"        pm.test(\"Records have increase by one\", function(){",
									"            pm.expect(pm.variables.get(\"totalRecordsBefore\")+1).to.equal(responseBody.object.length)",
									"        })",
									"        //validates if record exist and if it contains the same values given POST call",
									"        //also saves recordID to be able to delete it ",
									"        pm.test(\"The new record has been added and contains the same values given in POST call\", function(){",
									"            pm.expect(validateNewRecord( responseBody.object, pm.variables.get(\"newRecord\")) ).to.equal(true);",
									"        })",
									"    }",
									"}",
									"else if(pm.response.code==404)",
									"{",
									"    pm.test(\"Post id not found\", function(){",
									"        pm.expect(responseBody.object).to.equal(null);",
									"    })",
									"",
									"}",
									"else if (pm.response.code == 403) ",
									"{",
									"    pm.test(\"Unauthorised to make call, only allowed for hypetap\");",
									"}",
									"",
									"//-------------Functions",
									"",
									"function withinDates(from, to)",
									"{",
									"    for(let i =0; i<responseBody.object.length; ++i)",
									"    {",
									"        if( (new Date(responseBody.object[i].dateCreated).getTime()< new Date(from).getTime() ) &&",
									"            ( new Date(responseBody.object[i].dateCreated).getTime() >new Date(to).getTime() ) )",
									"        {",
									"            return false;",
									"        }",
									"    }",
									"    return true;",
									"",
									"}",
									"// checks if the new record, (from reuest in POST call), exist and if the data match",
									"function validateNewRecord(list, record)",
									"{",
									"    count=0;",
									"    for(let i=0; i<list.length; ++i)",
									"    {",
									"        //generate new dates to be able to convert string to date format",
									"        //if they are equal then it's the same record. Only one record can exist for one date",
									"        if(new Date(list[i].dateCreated).getTime() === new Date(record.recordDate).getTime())",
									"        {",
									"           pm.environment.set(\"recordBeforeUpdate\",list[i]);",
									"            //saves id to be able to delete record ",
									"            pm.variables.set(\"newRecordId\", list[i].id);",
									"",
									"            count+= 1;",
									"            //if likes is given and it's not the same value as response then return false, data doesn't match",
									"            if( (record.record.likes!=undefined) && (record.record.likes!=list[i].likes) )",
									"            {",
									"                return false;",
									"            }",
									"            else if( (record.record.comments!=undefined) && (record.record.comments!=list[i].comments) )",
									"            {",
									"                return false;",
									"            }",
									"            else if( (record.record.impressions!=undefined) && (record.record.impressions!=list[i].impressions) )",
									"            {",
									"                return false;",
									"            }",
									"            else if( (record.record.reach!=undefined) && (record.record.reach!=list[i].reach) )",
									"            {",
									"                return false;",
									"            }",
									"            else if( (record.record.views!=undefined) && (record.record.views!=list[i].views) )",
									"            {",
									"                return false;",
									"            }",
									"            else if( (record.record.saves!=undefined) && (record.record.saves!=list[i].saves) )",
									"            {",
									"                return false;",
									"            }                     ",
									"        }",
									"    }",
									"    //count will increase by one if function finds the new record date in the returned list",
									"    //function will return false if record is not found, (count==0) ",
									"    if(count>0)",
									"    {",
									"        return true;    //record exist and all fields match",
									"    }",
									"    return false;    //record not found",
									"}"
								],
								"type": "text/javascript"
							}
						}
					],
					"request": {
						"method": "GET",
						"header": [],
						"url": {
							"raw": "{{test}}post/{{postIdIGTV}}/record?from=2014-12-31&to={{dateNow}}",
							"host": [
								"{{test}}post"
							],
							"path": [
								"{{postIdIGTV}}",
								"record"
							],
							"query": [
								{
									"key": "from",
									"value": "2014-12-31"
								},
								{
									"key": "to",
									"value": "{{dateNow}}",
									"description": "set in pre test script of current folder"
								}
							]
						}
					},
					"response": []
				},
				{
					"name": "Update recordId",
					"event": [
						{
							"listen": "test",
							"script": {
								"exec": [
									"// will only update existing record ids",
									"// returns post and lates record even if no update was done",
									"",
									"var responseBody = pm.response.json();",
									"var requestBody = JSON.parse(pm.request.body.raw);",
									"",
									"//runns regardless of status",
									"pm.test(\"Required fields, impressions, views and reach are provided\", function(){",
									"    pm.expect(requestBody.record.impressions).to.not.equal(undefined);",
									"    pm.expect(requestBody.record.views).to.not.equal(undefined);",
									"    pm.expect(requestBody.record.reach).to.not.equal(undefined);",
									"})",
									"",
									"//save request to be able to validate if changes were made in get call",
									"pm.variables.set(\"updateRequest\", requestBody);",
									"",
									"// response from this call only shows the lates record so need to validate with another GET call ",
									"// to make sure an uoriginalRecord",
									"if(pm.response.code==200)",
									"{",
									"",
									"    //platform is not returned in get calls",
									"    //saving it from the request here so that it can be used in the revert PUT call",
									"    pm.environment.set(\"platform\", requestBody.record.platform);",
									"",
									"",
									"    // check if all fields have been updated",
									"    // record date is not required, will update existing record and keep old date in non is given",
									"    pm.test(\"Status 200 for recordId \"+ pm.request.url.path[4])",
									"}",
									"else if(pm.response.code==400)",
									"{",
									"    //The requested record date cannot be set to before the post date or to the same record date of the last update,",
									"    //(if an update has been made previously).",
									"    // will not update if post source = OTHER",
									"    if(responseBody.notes.userMessage!=undefined)",
									"    {",
									"        pm.test(\"Status 400, userMessage: \"+ responseBody.notes.userMessage, function(){",
									"            pm.expect(responseBody.notes.userMessage).to.be.oneOf([\"Record must be after post date\",",
									"                                                            \"Post already has a record for that date\",",
									"                                                            \"Can't update automatically fetched records\",",
									"                                                            \"Views must be greater than 0\",",
									"                                                            \"Impressions must be greater than 0\",",
									"                                                            \"Reach must be greater than 0\",",
									"                                                            \"Reach cannot be higher than impressions\",",
									"                                                            \"Likes cannot be higher than reach\",",
									"                                                            \"Record platform does not match post platform\",",
									"                                                            \"Saves cannot be higher than reach\",",
									"                                                            \"Views must be greater than or equal to reach\"]);",
									"        })",
									"    }",
									"    else if(responseBody.object===null )",
									"    {",
									"        pm.test(\"Platform is required, make sure it's valid\");",
									"    }",
									"}",
									"else if(pm.response.code==404)",
									"{",
									"    pm.test(\"Post id not found\", function(){",
									"        pm.expect(responseBody.object).to.equal(null);",
									"    })",
									"",
									"}",
									"else if (pm.response.code == 403) ",
									"{",
									"    pm.test(\"Unauthorised to make call, only allowed for hypetap\");",
									"}",
									"",
									"//---------------Functions",
									"",
									"function updateSuccessful()",
									"{",
									"    //not undefined means it was given in the request",
									"    if( (requestBody.record.likes !=undefined) &&",
									"        (responseBody.object.latestRecord.likes != requestBody.record.likes) )",
									"    {",
									"        return false;",
									"    }",
									"    else if( (requestBody.record.comments !=undefined) &&",
									"        (responseBody.object.latestRecord.comments != requestBody.record.comments) )",
									"    {",
									"        return false;",
									"    }",
									"    else if( (requestBody.record.impressions !=undefined) &&",
									"        (responseBody.object.latestRecord.impressions != requestBody.record.impressions) )",
									"    {",
									"        return false;",
									"    }    ",
									"    else if( (requestBody.record.reach !=undefined) &&",
									"        (responseBody.object.latestRecord.reach != requestBody.record.reach) )",
									"    {",
									"        return false;",
									"    }",
									"        else if( (requestBody.record.views !=undefined) &&",
									"        (responseBody.object.latestRecord.views != requestBody.record.views) )",
									"    {",
									"        return false;",
									"    }   ",
									"        else if( (requestBody.record.saves !=undefined)  &&",
									"        (responseBody.object.latestRecord.saves != requestBody.record.saves) )",
									"    {",
									"        return false;",
									"    }",
									"    else",
									"    {",
									"        return true;",
									"    }    ",
									"}",
									"",
									""
								],
								"type": "text/javascript"
							}
						},
						{
							"listen": "prerequest",
							"script": {
								"exec": [
									"pm.environment.set(\"updateNewRecordId\", pm.environment.get('recordBeforeUpdate').id)"
								],
								"type": "text/javascript"
							}
						}
					],
					"request": {
						"method": "PUT",
						"header": [],
						"body": {
							"mode": "raw",
							"raw": "{\n  \"record\": {\n    \"platform\": \"INSTAGRAM\",\n    \"comments\": 200,\n    \"likes\": 200,\n    \"impressions\": 200,\n    \"reach\": 200,\n    \"views\": 200,\n    \"saves\":200\n  }\n}",
							"options": {
								"raw": {
									"language": "json"
								}
							}
						},
						"url": {
							"raw": "{{test}}post/{{postIdIGTV}}/record/{{updateNewRecordId}}",
							"host": [
								"{{test}}post"
							],
							"path": [
								"{{postIdIGTV}}",
								"record",
								"{{updateNewRecordId}}"
							]
						}
					},
					"response": []
				},
				{
					"name": "Verify updates",
					"event": [
						{
							"listen": "test",
							"script": {
								"exec": [
									"var responseBody = pm.response.json();",
									"",
									"if(pm.response.code==200)",
									"{",
									"    ",
									"    if(responseBody.object.length==0)",
									"    {",
									"        pm.test(\"Status 200 no records returned\");",
									"    }",
									"    else",
									"    {        ",
									"        //if a record is found",
									"        //check if changes have been made from PUT call",
									"        if(getRecord()!=undefined)",
									"        {",
									"            pm.test(\"Update was successful\", function(){",
									"                pm.expect(updateSuccessful()).to.equal(true);",
									"            })",
									"        }",
									"        //will fail if this test is called without the collection runner",
									"        else",
									"        {",
									"            pm.test(\"No record found with given recordId from PUT call\", function(){",
									"                pm.expect(getRecord()).to.not.equal(undefined);",
									"            })",
									"",
									"        }",
									"",
									"        pm.test(\"Status 200, posts are within date range: \"+pm.request.url.query.toObject().from+\" - \"+pm.request.url.query.toObject().to, function(){",
									"            pm.expect(withinDates(pm.request.url.query.toObject().from, pm.request.url.query.toObject().to)).to.equal(true);",
									"        })",
									"    }",
									"}",
									"else if(pm.response.code==404)",
									"{",
									"    pm.test(\"Post id not found\", function(){",
									"        pm.expect(responseBody.object).to.equal(null);",
									"    })",
									"",
									"}",
									"else if (pm.response.code == 403) ",
									"{",
									"    pm.test(\"Unauthorised to make call, only allowed for hypetap\");",
									"}",
									"",
									"//-------------Functions",
									"",
									"function withinDates(from, to)",
									"{",
									"    for(let i =0; i<responseBody.object.length; ++i)",
									"    {",
									"        if(responseBody.object.dateCreated< from &&",
									"            responseBody.object.dateCreated>to)",
									"        {",
									"            return false;",
									"        }",
									"    }",
									"    return true;",
									"}",
									"",
									"//find record we're trying to update in PUT call",
									"function getRecord()",
									"{",
									"    for(let i = 0; i< responseBody.object.length; ++i)",
									"    {",
									"        if(responseBody.object[i].id == pm.variables.get(\"newRecordId\"))",
									"        {",
									"            return  responseBody.object[i];  //retun record if found",
									"        }",
									"    }",
									"}",
									"",
									"// variable \"updateRequest\" contains request from PUT call",
									"//getRecord() returns the record id, (from the response), which we tried to update in PUT call",
									"function updateSuccessful()",
									"{",
									"    //not undefined means it was given in the request",
									"    // field will be undefined in request if not given",
									"    if( (pm.variables.get(\"updateRequest\").record.likes !=undefined) &&",
									"        (getRecord().likes != pm.variables.get(\"updateRequest\").record.likes) )",
									"    {",
									"        return false;",
									"    }",
									"    else if( (pm.variables.get(\"updateRequest\").record.comments !=undefined) &&",
									"        (getRecord().comments != pm.variables.get(\"updateRequest\").record.comments) )",
									"    {",
									"        return false;",
									"    }",
									"    else if( (pm.variables.get(\"updateRequest\").record.impressions !=undefined) &&",
									"        (getRecord().impressions != pm.variables.get(\"updateRequest\").record.impressions) )",
									"    {",
									"        return false;",
									"    }    ",
									"    else if( (pm.variables.get(\"updateRequest\").record.reach !=undefined) &&",
									"        (getRecord().reach != pm.variables.get(\"updateRequest\").record.reach) )",
									"    {",
									"        return false;",
									"    }",
									"        else if( (pm.variables.get(\"updateRequest\").record.views !=undefined) &&",
									"        (getRecord().views != pm.variables.get(\"updateRequest\").record.views) )",
									"    {",
									"        return false;",
									"    }   ",
									"        else if( (pm.variables.get(\"updateRequest\").record.saves !=undefined)  &&",
									"        (getRecord().saves != pm.variables.get(\"updateRequest\").record.saves) )",
									"    {",
									"        return false;",
									"    }",
									"    else",
									"    {",
									"        return true;",
									"    }    ",
									"}",
									"",
									""
								],
								"type": "text/javascript"
							}
						}
					],
					"request": {
						"method": "GET",
						"header": [],
						"url": {
							"raw": "{{test}}post/{{postIdIGTV}}/record?from=2014-12-31&to={{dateNow}}",
							"host": [
								"{{test}}post"
							],
							"path": [
								"{{postIdIGTV}}",
								"record"
							],
							"query": [
								{
									"key": "from",
									"value": "2014-12-31"
								},
								{
									"key": "to",
									"value": "{{dateNow}}"
								}
							]
						}
					},
					"response": []
				},
				{
					"name": "Revert updates",
					"event": [
						{
							"listen": "test",
							"script": {
								"exec": [
									"// will only update existing record ids",
									"// returns post and lates record even if no update was done",
									"",
									"var responseBody = pm.response.json();",
									"var requestBody = JSON.parse(pm.request.body.raw);",
									"",
									"pm.test(\"Required fields, impressions, views and reach are provided\", function(){",
									"    pm.expect(requestBody.record.impressions).to.not.equal(undefined);",
									"    pm.expect(requestBody.record.views).to.not.equal(undefined);",
									"    pm.expect(requestBody.record.reach).to.not.equal(undefined);",
									"})",
									"",
									"",
									"// response from this call only shows the lates record so need to validate with another GET call ",
									"// to make sure an update was made",
									"if(pm.response.code==200)",
									"{",
									"    //save request to be able to validate if changes were made in get call",
									"    pm.variables.set(\"updateRequest\", requestBody);",
									"",
									"    // check if all fields have been updated",
									"    // record date is not required, will update existing record and keep old date in non is given",
									"    pm.test(\"Status 200 for recordId \"+ pm.request.url.path[4])",
									"}",
									"else if(pm.response.code==400)",
									"{",
									"    //The requested record date cannot be set to before the post date or to the same record date of the last update,",
									"    //(if an update has been made previously).",
									"    // will not update if post source = OTHER",
									"    if(responseBody.notes.userMessage!=undefined)",
									"    {",
									"        pm.test(\"Status 400, userMessage: \"+ responseBody.notes.userMessage, function(){",
									"            pm.expect(responseBody.notes.userMessage).to.be.oneOf([\"Record must be after post date\",",
									"                                                            \"Post already has a record for that date\",",
									"                                                            \"Can't update automatically fetched records\",",
									"                                                            \"Views must be greater than 0\",",
									"                                                            \"Impressions must be greater than 0\",",
									"                                                            \"Reach must be greater than 0\",",
									"                                                            \"Reach cannot be higher than impressions\",",
									"                                                            \"Likes cannot be higher than reach\",",
									"                                                            \"Record platform does not match post platform\",",
									"                                                            \"Saves cannot be higher than reach\",",
									"                                                            \"Views must be greater than or equal to reach\"]);",
									"        })",
									"    }",
									"    else if(responseBody.object===null )",
									"    {",
									"        pm.test(\"Platform is required, make sure it's valid\");",
									"    }",
									"}",
									"else if(pm.response.code==404)",
									"{",
									"    pm.test(\"Post id not found\", function(){",
									"        pm.expect(responseBody.object).to.equal(null);",
									"    })",
									"",
									"}",
									"else if (pm.response.code == 403) ",
									"{",
									"    pm.test(\"Unauthorised to make call, only allowed for hypetap\");",
									"}",
									"",
									"//---------------Functions",
									""
								],
								"type": "text/javascript"
							}
						},
						{
							"listen": "prerequest",
							"script": {
								"exec": [
									"pm.environment.set(\"comments\", pm.environment.get('recordBeforeUpdate').comments)",
									"pm.environment.set(\"likes\",pm.environment.get('recordBeforeUpdate').likes)",
									"pm.environment.set(\"impressions\", pm.environment.get('recordBeforeUpdate').impressions)",
									"pm.environment.set(\"reach\", pm.environment.get('recordBeforeUpdate').reach)",
									"pm.environment.set(\"views\", pm.environment.get('recordBeforeUpdate').views)",
									"pm.environment.set(\"saves\", pm.environment.get('recordBeforeUpdate').saves)",
									"",
									"pm.environment.set(\"recordDate\",pm.environment.get('recordBeforeUpdate').dateCreated)",
									"//pm.environment.set(\"platform\", JSON.parse(pm.environment.get('platform')))",
									"",
									"",
									""
								],
								"type": "text/javascript"
							}
						}
					],
					"request": {
						"method": "PUT",
						"header": [],
						"body": {
							"mode": "raw",
							"raw": "{\n  \"record\": {\n    \"platform\": \"{{platform}}\",\n    \"comments\": {{comments}},\n    \"likes\": {{likes}},\n    \"impressions\": {{impressions}},\n    \"reach\": {{reach}},\n    \"views\": {{views}},\n    \"saves\":{{saves}}\n  }\n}",
							"options": {
								"raw": {
									"language": "json"
								}
							}
						},
						"url": {
							"raw": "{{test}}post/{{postIdIGTV}}/record/{{updateNewRecordId}}",
							"host": [
								"{{test}}post"
							],
							"path": [
								"{{postIdIGTV}}",
								"record",
								"{{updateNewRecordId}}"
							]
						}
					},
					"response": []
				},
				{
					"name": "Verify updates",
					"event": [
						{
							"listen": "test",
							"script": {
								"exec": [
									"var responseBody = pm.response.json();",
									"",
									"if(pm.response.code==200)",
									"{",
									"    ",
									"    if(responseBody.object.length==0)",
									"    {",
									"        pm.test(\"Status 200 no records returned\");",
									"    }",
									"    else",
									"    {        ",
									"        //if a record is found",
									"        //check if changes have been made from PUT call",
									"        if(getRecord()!=undefined)",
									"        {",
									"            pm.test(\"Update was successful\", function(){",
									"                pm.expect(updateSuccessful()).to.equal(true);",
									"            })",
									"        }",
									"        //will fail if this test is called without the collection runner",
									"        else",
									"        {",
									"            pm.test(\"No record found with given recordId from PUT call\", function(){",
									"                pm.expect(getRecord()).to.not.equal(undefined);",
									"            })",
									"",
									"        }",
									"",
									"        pm.test(\"Status 200, posts are within date range: \"+pm.request.url.query.toObject().from+\" - \"+pm.request.url.query.toObject().to, function(){",
									"            pm.expect(withinDates(pm.request.url.query.toObject().from, pm.request.url.query.toObject().to)).to.equal(true);",
									"        })",
									"    }",
									"}",
									"else if(pm.response.code==404)",
									"{",
									"    pm.test(\"Post id not found\", function(){",
									"        pm.expect(responseBody.object).to.equal(null);",
									"    })",
									"",
									"}",
									"else if (pm.response.code == 403) ",
									"{",
									"    pm.test(\"Unauthorised to make call, only allowed for hypetap\");",
									"}",
									"",
									"//-------------Functions",
									"",
									"function withinDates(from, to)",
									"{",
									"    for(let i =0; i<responseBody.object.length; ++i)",
									"    {",
									"        if(responseBody.object.dateCreated< from &&",
									"            responseBody.object.dateCreated>to)",
									"        {",
									"            return false;",
									"        }",
									"    }",
									"    return true;",
									"}",
									"",
									"//find record we're trying to update in PUT call",
									"function getRecord()",
									"{",
									"    for(let i = 0; i< responseBody.object.length; ++i)",
									"    {",
									"        if(responseBody.object[i].id == pm.variables.get(\"newRecordId\"))",
									"        {",
									"            return  responseBody.object[i];  //retun record if found",
									"        }",
									"    }",
									"}",
									"",
									"// variable \"updateRequest\" contains request from PUT call",
									"//getRecord() returns the record id, (from the response), which we tried to update in PUT call",
									"function updateSuccessful()",
									"{",
									"    //not undefined means it was given in the request",
									"    // field will be undefined in request if not given",
									"    if( (pm.variables.get(\"updateRequest\").record.likes !=undefined) &&",
									"        (getRecord().likes != pm.variables.get(\"updateRequest\").record.likes) )",
									"    {",
									"        return false;",
									"    }",
									"    else if( (pm.variables.get(\"updateRequest\").record.comments !=undefined) &&",
									"        (getRecord().comments != pm.variables.get(\"updateRequest\").record.comments) )",
									"    {",
									"        return false;",
									"    }",
									"    else if( (pm.variables.get(\"updateRequest\").record.impressions !=undefined) &&",
									"        (getRecord().impressions != pm.variables.get(\"updateRequest\").record.impressions) )",
									"    {",
									"        return false;",
									"    }    ",
									"    else if( (pm.variables.get(\"updateRequest\").record.reach !=undefined) &&",
									"        (getRecord().reach != pm.variables.get(\"updateRequest\").record.reach) )",
									"    {",
									"        return false;",
									"    }",
									"        else if( (pm.variables.get(\"updateRequest\").record.views !=undefined) &&",
									"        (getRecord().views != pm.variables.get(\"updateRequest\").record.views) )",
									"    {",
									"        return false;",
									"    }   ",
									"        else if( (pm.variables.get(\"updateRequest\").record.saves !=undefined)  &&",
									"        (getRecord().saves != pm.variables.get(\"updateRequest\").record.saves) )",
									"    {",
									"        return false;",
									"    }",
									"    else",
									"    {",
									"        return true;",
									"    }    ",
									"}",
									"",
									""
								],
								"type": "text/javascript"
							}
						}
					],
					"request": {
						"method": "GET",
						"header": [],
						"url": {
							"raw": "{{test}}post/{{postIdIGTV}}/record?from=2014-12-31&to={{dateNow}}",
							"host": [
								"{{test}}post"
							],
							"path": [
								"{{postIdIGTV}}",
								"record"
							],
							"query": [
								{
									"key": "from",
									"value": "2014-12-31"
								},
								{
									"key": "to",
									"value": "{{dateNow}}"
								}
							]
						}
					},
					"response": []
				},
				{
					"name": "Delete Record ({postId}/record/{recordId})",
					"event": [
						{
							"listen": "test",
							"script": {
								"exec": [
									"// Will not delete for a post with PostSource set to OTHER as record data is not applicable to those posts.",
									"",
									"if(pm.response.code==200)",
									"{",
									"    pm.test(\"Status 200. Deleted record with id \"+ pm.request.url.path[4]);",
									"}",
									"else if (pm.response.code == 403) ",
									"{",
									"    pm.test(\"Unauthorised to make call, only allowed for hypetap\");",
									"}"
								],
								"type": "text/javascript"
							}
						}
					],
					"request": {
						"method": "DELETE",
						"header": [],
						"body": {
							"mode": "raw",
							"raw": ""
						},
						"url": {
							"raw": "{{test}}post/{{postIdIGTV}}/record/{{newRecordId}}",
							"host": [
								"{{test}}post"
							],
							"path": [
								"{{postIdIGTV}}",
								"record",
								"{{newRecordId}}"
							]
						}
					},
					"response": []
				},
				{
					"name": "Records After (requires date range)",
					"event": [
						{
							"listen": "test",
							"script": {
								"exec": [
									"var responseBody = pm.response.json();",
									"",
									"if(pm.response.code==200)",
									"{",
									"    if(responseBody.object.length==0)",
									"    {",
									"        pm.test(\"Status 200 no records returned for postId \" + pm.request.url.path[2]);",
									"    }",
									"    else",
									"    {",
									"",
									"        pm.test(\"Status 200, for postId \" + pm.request.url.path[2]);",
									"",
									"        //both dates has to be given for call to work",
									"        pm.test(\"Records returned: \" + responseBody.object.length+ \". Records are within date range: \"+pm.request.url.query.toObject().from+\" - \"+pm.request.url.query.toObject().to, function(){",
									"            pm.expect(withinDates(pm.request.url.query.toObject().from, pm.request.url.query.toObject().to)).to.equal(true);",
									"        })",
									"",
									"        pm.test(\"Records have decrease by one, (total is same as before POST call)\", function(){",
									"            pm.expect(pm.variables.get(\"totalRecordsBefore\")).to.equal(responseBody.object.length)",
									"        })",
									"",
									"        pm.test(\"Record doesn't exist, was deleted successfuly\", function(){",
									"            pm.expect(recordExist( responseBody.object, pm.variables.get(\"newRecordId\")) ).to.equal(false);",
									"        })",
									"    }",
									"}",
									"else if(pm.response.code==404)",
									"{",
									"    pm.test(\"Post id not found\", function(){",
									"        pm.expect(responseBody.object).to.equal(null);",
									"    })",
									"",
									"}",
									"else if (pm.response.code == 403) ",
									"{",
									"    pm.test(\"Unauthorised to make call, only allowed for hypetap\");",
									"}",
									"",
									"//-------------Functions",
									"",
									"function withinDates(from, to)",
									"{",
									"    for(let i =0; i<responseBody.object.length; ++i)",
									"    {",
									"        if( (new Date(responseBody.object[i].dateCreated).getTime()< new Date(from).getTime() ) &&",
									"            ( new Date(responseBody.object[i].dateCreated).getTime() >new Date(to).getTime() ) )",
									"        {",
									"            return false;",
									"        }",
									"    }",
									"    return true;",
									"",
									"}",
									"// checks if the new record, (from reuest in POST call), exist and if the data match",
									"function recordExist(list, recordId)",
									"{",
									"    for(let i=0; i<list.length; ++i)",
									"    {",
									"        ",
									"        if(recordId==list[i].id)",
									"        {",
									"            return true;",
									"        }",
									"",
									"    }",
									"    return false;    //record not found",
									"}"
								],
								"type": "text/javascript"
							}
						}
					],
					"request": {
						"method": "GET",
						"header": [],
						"url": {
							"raw": "{{test}}post/{{postIdIGTV}}/record?from=2014-12-31&to={{dateNow}}",
							"host": [
								"{{test}}post"
							],
							"path": [
								"{{postIdIGTV}}",
								"record"
							],
							"query": [
								{
									"key": "from",
									"value": "2014-12-31"
								},
								{
									"key": "to",
									"value": "{{dateNow}}",
									"description": "set in pre test script of current folder"
								}
							]
						}
					},
					"response": []
				}
			],
			"event": [
				{
					"listen": "prerequest",
					"script": {
						"type": "text/javascript",
						"exec": [
							"//sets variable \"dateNow\"  with current date",
							"//GET records requires a date range",
							"month = '' + (new Date().getMonth() + 1)",
							"if(month.length<2 )",
							"{",
							"    month='0'+month;",
							"}",
							"",
							"if(new Date().getDate().length<2 )",
							"{",
							"    day='0'+new Date().getDate();",
							"}",
							"else ",
							"{",
							"    day=new Date().getDate();",
							"}",
							"",
							"date = [ new Date().getFullYear(), month, day].join('-');",
							"",
							"pm.variables.set(\"dateNow\", date);"
						]
					}
				},
				{
					"listen": "test",
					"script": {
						"type": "text/javascript",
						"exec": [
							""
						]
					}
				}
			]
		},
		{
			"name": "BUG IGTV - Create, Update and Delete Record",
			"item": [
				{
					"name": "BOSS login",
					"event": [
						{
							"listen": "test",
							"script": {
								"exec": [
									"pm.test(\"Status code is 200\", function () {",
									"    pm.response.to.have.status(200);",
									"});",
									""
								],
								"type": "text/javascript"
							}
						}
					],
					"request": {
						"method": "POST",
						"header": [
							{
								"warning": "This is a duplicate header and will be overridden by the Content-Type header generated by Postman.",
								"key": "Content-Type",
								"value": "application/x-www-form-urlencoded",
								"type": "text"
							}
						],
						"body": {
							"mode": "urlencoded",
							"urlencoded": [
								{
									"key": "username",
									"value": "dumbanddummy1+brooke@gmail.com",
									"description": "dumbanddummy1+brooke@gmail.com",
									"type": "text"
								},
								{
									"key": "password",
									"value": "hypetap1",
									"type": "text"
								},
								{
									"key": "remember-me",
									"value": "true",
									"type": "text"
								}
							]
						},
						"url": {
							"raw": "{{test}}login",
							"host": [
								"{{test}}login"
							]
						}
					},
					"response": []
				},
				{
					"name": "Records Before (requires date range)",
					"event": [
						{
							"listen": "test",
							"script": {
								"exec": [
									"var responseBody = pm.response.json();",
									"",
									"if(pm.response.code==200)",
									"{",
									"    if(responseBody.object.length==0)",
									"    {",
									"        pm.test(\"Status 200 no records returned for postId \" + pm.request.url.path[2]);",
									"    }",
									"    else",
									"    {",
									"        //saves number of records returned to be able to check if number has increased after POST, (add new record) call",
									"        pm.variables.set(\"totalRecordsBefore\", responseBody.object.length);",
									"",
									"        pm.test(\"Status 200, for postId \" + pm.request.url.path[2]);",
									"",
									"        //both dates has to be given for call to work",
									"        pm.test(\"Records returned: \" + responseBody.object.length+ \". Records are within date range: \"+pm.request.url.query.toObject().from+\" - \"+pm.request.url.query.toObject().to, function(){",
									"            pm.expect(withinDates(pm.request.url.query.toObject().from, pm.request.url.query.toObject().to)).to.equal(true);",
									"        })",
									"",
									"    }",
									"}",
									"else if(pm.response.code==404)",
									"{",
									"    pm.test(\"Post id not found\", function(){",
									"        pm.expect(responseBody.object).to.equal(null);",
									"    })",
									"",
									"}",
									"else if (pm.response.code == 403) ",
									"{",
									"    pm.test(\"Unauthorised to make call, only allowed for hypetap\");",
									"}",
									"",
									"//-------------Functions",
									"",
									"function withinDates(from, to)",
									"{",
									"    for(let i =0; i<responseBody.object.length; ++i)",
									"    {",
									"        if( (new Date(responseBody.object[i].dateCreated).getTime()< new Date(from).getTime() ) &&",
									"            ( new Date(responseBody.object[i].dateCreated).getTime() >new Date(to).getTime() ) )",
									"        {",
									"            return false;",
									"        }",
									"    }",
									"    return true;",
									"",
									"}",
									""
								],
								"type": "text/javascript"
							}
						}
					],
					"request": {
						"method": "GET",
						"header": [],
						"url": {
							"raw": "{{test}}post/{{postIdIGTV}}/record?from=2014-12-31&to={{dateNow}}",
							"host": [
								"{{test}}post"
							],
							"path": [
								"{{postIdIGTV}}",
								"record"
							],
							"query": [
								{
									"key": "from",
									"value": "2014-12-31"
								},
								{
									"key": "to",
									"value": "{{dateNow}}",
									"description": "set in pre test script of current folder"
								}
							]
						}
					},
					"response": []
				},
				{
					"name": "Create Record ({postId}/record)",
					"event": [
						{
							"listen": "test",
							"script": {
								"exec": [
									"var responseBody = pm.response.json();",
									"var requestBody = JSON.parse(pm.request.body.raw);",
									"",
									"//runns regardless of status",
									"pm.test(\"Required fields, impressions, views, reach and recordDate are provided\", function(){",
									"    pm.expect(requestBody.record.impressions).to.not.equal(undefined);",
									"    pm.expect(requestBody.record.views).to.not.equal(undefined);",
									"    pm.expect(requestBody.record.reach).to.not.equal(undefined);",
									"    pm.expect(requestBody.recordDate).to.not.equal(undefined);",
									"})",
									"",
									"if(pm.response.code==200)",
									"{",
									"    //save request to be ale to confirm that it was added with the correct data. ",
									"    //records are not allowed to be for the same date, so date is unique",
									"    pm.variables.set(\"newRecord\", requestBody);",
									"",
									"    pm.test(\"Status 200. Returns post corresponding to given postId \"+ pm.request.url.path[2], function(){",
									"        pm.expect( pm.request.url.path[2]).to.equal(responseBody.object.id);",
									"    })",
									"",
									"    //the new record has to be after the post date",
									"    //need to convert dates to be able to compare since they are of the type string",
									"    pm.test(\"The new record is after post date. The date of added record \" + requestBody.recordDate, function(){",
									"        pm.expect(new Date(requestBody.recordDate).getTime()> new Date(responseBody.object.datePosted).getTime() ).to.equal(true);",
									"    })",
									"",
									"}",
									"else if(pm.response.code==400)",
									"{",
									"    //The requested record date cannot be set to before the post date or to the same record date of the last update,",
									"    //(if an update has been made previously).",
									"    // will not update if post source = OTHER",
									"    if(responseBody.notes.userMessage!=undefined)",
									"    {",
									"        pm.test(\"Status 400, userMessage: \"+ responseBody.notes.userMessage, function(){",
									"            pm.expect(responseBody.notes.userMessage).to.be.oneOf([",
									"                                                            \"Cannot update posts fetched via APIs\",",
									"                                                            \"A record must have a date\",",
									"                                                            \"Record must be after post date\",",
									"                                                            \"Post already has a record for that date\",",
									"                                                            \"Can't update automatically fetched records\",",
									"                                                            \"Views must be greater than 0\",",
									"                                                            \"Impressions must be greater than 0\",",
									"                                                            \"Reach must be greater than 0\",",
									"                                                            \"Reach cannot be higher than impressions\",",
									"                                                            \"Likes cannot be higher than reach\",",
									"                                                            \"Record platform does not match post platform\",",
									"                                                            \"Saves cannot be higher than reach\",",
									"                                                            \"Views must equal impressions\",",
									"                                                            \"Views must be greater than or equal to reach\"]);",
									"        })",
									"    }",
									"    else if(responseBody.object===null )",
									"    {",
									"        pm.test(\"Platform is required, make sure it's valid\");",
									"    }",
									"}",
									"else if (pm.response.code == 403) ",
									"{",
									"    pm.test(\"Unauthorised to make call, only allowed for hypetap\");",
									"}",
									"",
									"//---------------Functions",
									""
								],
								"type": "text/javascript"
							}
						}
					],
					"request": {
						"method": "POST",
						"header": [],
						"body": {
							"mode": "raw",
							"raw": "{\n  \"record\": {\n    \"platform\": \"INSTAGRAM\",\n    \"comments\": 100,\n    \"likes\": 100,\n    \"impressions\": 100,\n    \"reach\": 100,\n    \"views\":100,\n    \"saves\": 100\n  },\n  \"recordDate\": \"2021-09-15\"\n}",
							"options": {
								"raw": {
									"language": "json"
								}
							}
						},
						"url": {
							"raw": "{{test}}post/{{postIdIGTV}}/record",
							"host": [
								"{{test}}post"
							],
							"path": [
								"{{postIdIGTV}}",
								"record"
							]
						}
					},
					"response": []
				},
				{
					"name": "Records After (requires date range)",
					"event": [
						{
							"listen": "test",
							"script": {
								"exec": [
									"var responseBody = pm.response.json();",
									"",
									"if(pm.response.code==200)",
									"{",
									"    if(responseBody.object.length==0)",
									"    {",
									"        pm.test(\"Status 200 no records returned for postId \" + pm.request.url.path[2]);",
									"    }",
									"    else",
									"    {",
									"",
									"        pm.test(\"Status 200, for postId \" + pm.request.url.path[2]);",
									"",
									"        //both dates has to be given for call to work",
									"        pm.test(\"Records returned: \" + responseBody.object.length+ \". Records are within date range: \"+pm.request.url.query.toObject().from+\" - \"+pm.request.url.query.toObject().to, function(){",
									"            pm.expect(withinDates(pm.request.url.query.toObject().from, pm.request.url.query.toObject().to)).to.equal(true);",
									"        })",
									"",
									"        pm.test(\"Records have increase by one\", function(){",
									"            pm.expect(pm.variables.get(\"totalRecordsBefore\")+1).to.equal(responseBody.object.length)",
									"        })",
									"        //validates if record exist and if it contains the same values given POST call",
									"        //also saves recordID to be able to delete it ",
									"        pm.test(\"The new record has been added and contains the same values given in POST call\", function(){",
									"            pm.expect(validateNewRecord( responseBody.object, pm.variables.get(\"newRecord\")) ).to.equal(true);",
									"        })",
									"    }",
									"}",
									"else if(pm.response.code==404)",
									"{",
									"    pm.test(\"Post id not found\", function(){",
									"        pm.expect(responseBody.object).to.equal(null);",
									"    })",
									"",
									"}",
									"else if (pm.response.code == 403) ",
									"{",
									"    pm.test(\"Unauthorised to make call, only allowed for hypetap\");",
									"}",
									"",
									"//-------------Functions",
									"",
									"function withinDates(from, to)",
									"{",
									"    for(let i =0; i<responseBody.object.length; ++i)",
									"    {",
									"        if( (new Date(responseBody.object[i].dateCreated).getTime()< new Date(from).getTime() ) &&",
									"            ( new Date(responseBody.object[i].dateCreated).getTime() >new Date(to).getTime() ) )",
									"        {",
									"            return false;",
									"        }",
									"    }",
									"    return true;",
									"",
									"}",
									"// checks if the new record, (from reuest in POST call), exist and if the data match",
									"function validateNewRecord(list, record)",
									"{",
									"    count=0;",
									"    for(let i=0; i<list.length; ++i)",
									"    {",
									"        //generate new dates to be able to convert string to date format",
									"        //if they are equal then it's the same record. Only one record can exist for one date",
									"        if(new Date(list[i].dateCreated).getTime() === new Date(record.recordDate).getTime())",
									"        {",
									"           pm.environment.set(\"recordBeforeUpdate\",list[i]);",
									"            //saves id to be able to delete record ",
									"            pm.variables.set(\"newRecordId\", list[i].id);",
									"",
									"            count+= 1;",
									"            //if likes is given and it's not the same value as response then return false, data doesn't match",
									"            if( (record.record.likes!=undefined) && (record.record.likes!=list[i].likes) )",
									"            {",
									"                return false;",
									"            }",
									"            else if( (record.record.comments!=undefined) && (record.record.comments!=list[i].comments) )",
									"            {",
									"                return false;",
									"            }",
									"            else if( (record.record.impressions!=undefined) && (record.record.impressions!=list[i].impressions) )",
									"            {",
									"                return false;",
									"            }",
									"            else if( (record.record.reach!=undefined) && (record.record.reach!=list[i].reach) )",
									"            {",
									"                return false;",
									"            }",
									"            else if( (record.record.views!=undefined) && (record.record.views!=list[i].views) )",
									"            {",
									"                return false;",
									"            }",
									"            else if( (record.record.saves!=undefined) && (record.record.saves!=list[i].saves) )",
									"            {",
									"                return false;",
									"            }                     ",
									"        }",
									"    }",
									"    //count will increase by one if function finds the new record date in the returned list",
									"    //function will return false if record is not found, (count==0) ",
									"    if(count>0)",
									"    {",
									"        return true;    //record exist and all fields match",
									"    }",
									"    return false;    //record not found",
									"}"
								],
								"type": "text/javascript"
							}
						}
					],
					"request": {
						"method": "GET",
						"header": [],
						"url": {
							"raw": "{{test}}post/{{postIdIGTV}}/record?from=2014-12-31&to={{dateNow}}",
							"host": [
								"{{test}}post"
							],
							"path": [
								"{{postIdIGTV}}",
								"record"
							],
							"query": [
								{
									"key": "from",
									"value": "2014-12-31"
								},
								{
									"key": "to",
									"value": "{{dateNow}}",
									"description": "set in pre test script of current folder"
								}
							]
						}
					},
					"response": []
				},
				{
					"name": "BUG Update recordId - Views less than reach, not equal to impressions",
					"event": [
						{
							"listen": "test",
							"script": {
								"exec": [
									"// will only update existing record ids",
									"// returns post and lates record even if no update was done",
									"",
									"var responseBody = pm.response.json();",
									"var requestBody = JSON.parse(pm.request.body.raw);",
									"",
									"//runns regardless of status",
									"pm.test(\"Required fields, impressions, views and reach are provided\", function(){",
									"    pm.expect(requestBody.record.impressions).to.not.equal(undefined);",
									"    pm.expect(requestBody.record.views).to.not.equal(undefined);",
									"    pm.expect(requestBody.record.reach).to.not.equal(undefined);",
									"})",
									"",
									"//from delivery team-> views = impressions on video content",
									"// and views should not b less than reach",
									"pm.test(\"BUG - Views are not less than reach and views is equal to impressions\", function(){",
									"    pm.expect((requestBody.record.views)- (requestBody.record.reach)).to.be.above(0);",
									"    pm.expect(responseBody.record.views).to.equal(requestBody.record.impressions);",
									"})",
									"",
									"//save request to be able to validate if changes were made in get call",
									"pm.variables.set(\"updateRequest\", requestBody);",
									"",
									"// response from this call only shows the lates record so need to validate with another GET call ",
									"// to make sure an uoriginalRecord",
									"if(pm.response.code==200)",
									"{",
									"",
									"    //platform is not returned in get calls",
									"    //saving it from the request here so that it can be used in the revert PUT call",
									"    pm.environment.set(\"platform\", requestBody.record.platform);",
									"",
									"",
									"    // check if all fields have been updated",
									"    // record date is not required, will update existing record and keep old date in non is given",
									"    pm.test(\"Status 200 for recordId \"+ pm.request.url.path[4])",
									"}",
									"else if(pm.response.code==400)",
									"{",
									"    //The requested record date cannot be set to before the post date or to the same record date of the last update,",
									"    //(if an update has been made previously).",
									"    // will not update if post source = OTHER",
									"    if(responseBody.notes.userMessage!=undefined)",
									"    {",
									"        pm.test(\"Status 400, userMessage: \"+ responseBody.notes.userMessage, function(){",
									"            pm.expect(responseBody.notes.userMessage).to.be.oneOf([\"Record must be after post date\",",
									"                                                            \"Post already has a record for that date\",",
									"                                                            \"Can't update automatically fetched records\",",
									"                                                            \"Views must be greater than 0\",",
									"                                                            \"Impressions must be greater than 0\",",
									"                                                            \"Reach must be greater than 0\",",
									"                                                            \"Reach cannot be higher than impressions\",",
									"                                                            \"Likes cannot be higher than reach\",",
									"                                                            \"Record platform does not match post platform\",",
									"                                                            \"Saves cannot be higher than reach\",",
									"                                                            \"Views must be greater than or equal to reach\"]);",
									"        })",
									"    }",
									"    else if(responseBody.object===null )",
									"    {",
									"        pm.test(\"Platform is required, make sure it's valid\");",
									"    }",
									"}",
									"else if(pm.response.code==404)",
									"{",
									"    pm.test(\"Post id not found\", function(){",
									"        pm.expect(responseBody.object).to.equal(null);",
									"    })",
									"",
									"}",
									"else if (pm.response.code == 403) ",
									"{",
									"    pm.test(\"Unauthorised to make call, only allowed for hypetap\");",
									"}",
									"",
									"//---------------Functions",
									"",
									"function updateSuccessful()",
									"{",
									"    //not undefined means it was given in the request",
									"    if( (requestBody.record.likes !=undefined) &&",
									"        (responseBody.object.latestRecord.likes != requestBody.record.likes) )",
									"    {",
									"        return false;",
									"    }",
									"    else if( (requestBody.record.comments !=undefined) &&",
									"        (responseBody.object.latestRecord.comments != requestBody.record.comments) )",
									"    {",
									"        return false;",
									"    }",
									"    else if( (requestBody.record.impressions !=undefined) &&",
									"        (responseBody.object.latestRecord.impressions != requestBody.record.impressions) )",
									"    {",
									"        return false;",
									"    }    ",
									"    else if( (requestBody.record.reach !=undefined) &&",
									"        (responseBody.object.latestRecord.reach != requestBody.record.reach) )",
									"    {",
									"        return false;",
									"    }",
									"        else if( (requestBody.record.views !=undefined) &&",
									"        (responseBody.object.latestRecord.views != requestBody.record.views) )",
									"    {",
									"        return false;",
									"    }   ",
									"        else if( (requestBody.record.saves !=undefined)  &&",
									"        (responseBody.object.latestRecord.saves != requestBody.record.saves) )",
									"    {",
									"        return false;",
									"    }",
									"    else",
									"    {",
									"        return true;",
									"    }    ",
									"}",
									"",
									""
								],
								"type": "text/javascript"
							}
						},
						{
							"listen": "prerequest",
							"script": {
								"exec": [
									"pm.environment.set(\"updateNewRecordId\", pm.environment.get('recordBeforeUpdate').id)"
								],
								"type": "text/javascript"
							}
						}
					],
					"request": {
						"method": "PUT",
						"header": [],
						"body": {
							"mode": "raw",
							"raw": "{\n  \"record\": {\n    \"platform\": \"INSTAGRAM\",\n    \"comments\": 100,\n    \"likes\": 100,\n    \"impressions\": 110,\n    \"reach\": 100,\n    \"views\": 90,\n    \"saves\":100\n  }\n}",
							"options": {
								"raw": {
									"language": "json"
								}
							}
						},
						"url": {
							"raw": "{{test}}post/{{postIdIGTV}}/record/{{updateNewRecordId}}",
							"host": [
								"{{test}}post"
							],
							"path": [
								"{{postIdIGTV}}",
								"record",
								"{{updateNewRecordId}}"
							]
						}
					},
					"response": []
				},
				{
					"name": "Verify updates",
					"event": [
						{
							"listen": "test",
							"script": {
								"exec": [
									"var responseBody = pm.response.json();",
									"",
									"if(pm.response.code==200)",
									"{",
									"    ",
									"    if(responseBody.object.length==0)",
									"    {",
									"        pm.test(\"Status 200 no records returned\");",
									"    }",
									"    else",
									"    {        ",
									"        //if a record is found",
									"        //check if changes have been made from PUT call",
									"        if(getRecord()!=undefined)",
									"        {",
									"            pm.test(\"Update was successful\", function(){",
									"                pm.expect(updateSuccessful()).to.equal(true);",
									"            })",
									"        }",
									"        //will fail if this test is called without the collection runner",
									"        else",
									"        {",
									"            pm.test(\"No record found with given recordId from PUT call\", function(){",
									"                pm.expect(getRecord()).to.not.equal(undefined);",
									"            })",
									"",
									"        }",
									"",
									"        pm.test(\"Status 200, posts are within date range: \"+pm.request.url.query.toObject().from+\" - \"+pm.request.url.query.toObject().to, function(){",
									"            pm.expect(withinDates(pm.request.url.query.toObject().from, pm.request.url.query.toObject().to)).to.equal(true);",
									"        })",
									"    }",
									"}",
									"else if(pm.response.code==404)",
									"{",
									"    pm.test(\"Post id not found\", function(){",
									"        pm.expect(responseBody.object).to.equal(null);",
									"    })",
									"",
									"}",
									"else if (pm.response.code == 403) ",
									"{",
									"    pm.test(\"Unauthorised to make call, only allowed for hypetap\");",
									"}",
									"",
									"//-------------Functions",
									"",
									"function withinDates(from, to)",
									"{",
									"    for(let i =0; i<responseBody.object.length; ++i)",
									"    {",
									"        if(responseBody.object.dateCreated< from &&",
									"            responseBody.object.dateCreated>to)",
									"        {",
									"            return false;",
									"        }",
									"    }",
									"    return true;",
									"}",
									"",
									"//find record we're trying to update in PUT call",
									"function getRecord()",
									"{",
									"    for(let i = 0; i< responseBody.object.length; ++i)",
									"    {",
									"        if(responseBody.object[i].id == pm.variables.get(\"newRecordId\"))",
									"        {",
									"            return  responseBody.object[i];  //retun record if found",
									"        }",
									"    }",
									"}",
									"",
									"// variable \"updateRequest\" contains request from PUT call",
									"//getRecord() returns the record id, (from the response), which we tried to update in PUT call",
									"function updateSuccessful()",
									"{",
									"    //not undefined means it was given in the request",
									"    // field will be undefined in request if not given",
									"    if( (pm.variables.get(\"updateRequest\").record.likes !=undefined) &&",
									"        (getRecord().likes != pm.variables.get(\"updateRequest\").record.likes) )",
									"    {",
									"        return false;",
									"    }",
									"    else if( (pm.variables.get(\"updateRequest\").record.comments !=undefined) &&",
									"        (getRecord().comments != pm.variables.get(\"updateRequest\").record.comments) )",
									"    {",
									"        return false;",
									"    }",
									"    else if( (pm.variables.get(\"updateRequest\").record.impressions !=undefined) &&",
									"        (getRecord().impressions != pm.variables.get(\"updateRequest\").record.impressions) )",
									"    {",
									"        return false;",
									"    }    ",
									"    else if( (pm.variables.get(\"updateRequest\").record.reach !=undefined) &&",
									"        (getRecord().reach != pm.variables.get(\"updateRequest\").record.reach) )",
									"    {",
									"        return false;",
									"    }",
									"        else if( (pm.variables.get(\"updateRequest\").record.views !=undefined) &&",
									"        (getRecord().views != pm.variables.get(\"updateRequest\").record.views) )",
									"    {",
									"        return false;",
									"    }   ",
									"        else if( (pm.variables.get(\"updateRequest\").record.saves !=undefined)  &&",
									"        (getRecord().saves != pm.variables.get(\"updateRequest\").record.saves) )",
									"    {",
									"        return false;",
									"    }",
									"    else",
									"    {",
									"        return true;",
									"    }    ",
									"}",
									"",
									""
								],
								"type": "text/javascript"
							}
						}
					],
					"request": {
						"method": "GET",
						"header": [],
						"url": {
							"raw": "{{test}}post/{{postIdIGTV}}/record?from=2014-12-31&to={{dateNow}}",
							"host": [
								"{{test}}post"
							],
							"path": [
								"{{postIdIGTV}}",
								"record"
							],
							"query": [
								{
									"key": "from",
									"value": "2014-12-31"
								},
								{
									"key": "to",
									"value": "{{dateNow}}"
								}
							]
						}
					},
					"response": []
				},
				{
					"name": "Revert updates",
					"event": [
						{
							"listen": "test",
							"script": {
								"exec": [
									"// will only update existing record ids",
									"// returns post and lates record even if no update was done",
									"",
									"var responseBody = pm.response.json();",
									"var requestBody = JSON.parse(pm.request.body.raw);",
									"",
									"pm.test(\"Required fields, impressions, views and reach are provided\", function(){",
									"    pm.expect(requestBody.record.impressions).to.not.equal(undefined);",
									"    pm.expect(requestBody.record.views).to.not.equal(undefined);",
									"    pm.expect(requestBody.record.reach).to.not.equal(undefined);",
									"})",
									"",
									"",
									"// response from this call only shows the lates record so need to validate with another GET call ",
									"// to make sure an update was made",
									"if(pm.response.code==200)",
									"{",
									"    //save request to be able to validate if changes were made in get call",
									"    pm.variables.set(\"updateRequest\", requestBody);",
									"",
									"    // check if all fields have been updated",
									"    // record date is not required, will update existing record and keep old date in non is given",
									"    pm.test(\"Status 200 for recordId \"+ pm.request.url.path[4])",
									"}",
									"else if(pm.response.code==400)",
									"{",
									"    //The requested record date cannot be set to before the post date or to the same record date of the last update,",
									"    //(if an update has been made previously).",
									"    // will not update if post source = OTHER",
									"    if(responseBody.notes.userMessage!=undefined)",
									"    {",
									"        pm.test(\"Status 400, userMessage: \"+ responseBody.notes.userMessage, function(){",
									"            pm.expect(responseBody.notes.userMessage).to.be.oneOf([\"Record must be after post date\",",
									"                                                            \"Post already has a record for that date\",",
									"                                                            \"Can't update automatically fetched records\",",
									"                                                            \"Views must be greater than 0\",",
									"                                                            \"Impressions must be greater than 0\",",
									"                                                            \"Reach must be greater than 0\",",
									"                                                            \"Reach cannot be higher than impressions\",",
									"                                                            \"Likes cannot be higher than reach\",",
									"                                                            \"Record platform does not match post platform\",",
									"                                                            \"Saves cannot be higher than reach\",",
									"                                                            \"Views must be greater than or equal to reach\"]);",
									"        })",
									"    }",
									"    else if(responseBody.object===null )",
									"    {",
									"        pm.test(\"Platform is required, make sure it's valid\");",
									"    }",
									"}",
									"else if(pm.response.code==404)",
									"{",
									"    pm.test(\"Post id not found\", function(){",
									"        pm.expect(responseBody.object).to.equal(null);",
									"    })",
									"",
									"}",
									"else if (pm.response.code == 403) ",
									"{",
									"    pm.test(\"Unauthorised to make call, only allowed for hypetap\");",
									"}",
									"",
									"//---------------Functions",
									""
								],
								"type": "text/javascript"
							}
						},
						{
							"listen": "prerequest",
							"script": {
								"exec": [
									"pm.environment.set(\"comments\", pm.environment.get('recordBeforeUpdate').comments)",
									"pm.environment.set(\"likes\",pm.environment.get('recordBeforeUpdate').likes)",
									"pm.environment.set(\"impressions\", pm.environment.get('recordBeforeUpdate').impressions)",
									"pm.environment.set(\"reach\", pm.environment.get('recordBeforeUpdate').reach)",
									"pm.environment.set(\"views\", pm.environment.get('recordBeforeUpdate').views)",
									"pm.environment.set(\"saves\", pm.environment.get('recordBeforeUpdate').saves)",
									"",
									"pm.environment.set(\"recordDate\",pm.environment.get('recordBeforeUpdate').dateCreated)",
									"//pm.environment.set(\"platform\", JSON.parse(pm.environment.get('platform')))",
									"",
									"",
									""
								],
								"type": "text/javascript"
							}
						}
					],
					"request": {
						"method": "PUT",
						"header": [],
						"body": {
							"mode": "raw",
							"raw": "{\n  \"record\": {\n    \"platform\": \"{{platform}}\",\n    \"comments\": {{comments}},\n    \"likes\": {{likes}},\n    \"impressions\": {{impressions}},\n    \"reach\": {{reach}},\n    \"views\": {{views}},\n    \"saves\":{{saves}}\n  }\n}",
							"options": {
								"raw": {
									"language": "json"
								}
							}
						},
						"url": {
							"raw": "{{test}}post/{{postIdIGTV}}/record/{{updateNewRecordId}}",
							"host": [
								"{{test}}post"
							],
							"path": [
								"{{postIdIGTV}}",
								"record",
								"{{updateNewRecordId}}"
							]
						}
					},
					"response": []
				},
				{
					"name": "Verify updates",
					"event": [
						{
							"listen": "test",
							"script": {
								"exec": [
									"var responseBody = pm.response.json();",
									"",
									"if(pm.response.code==200)",
									"{",
									"    ",
									"    if(responseBody.object.length==0)",
									"    {",
									"        pm.test(\"Status 200 no records returned\");",
									"    }",
									"    else",
									"    {        ",
									"        //if a record is found",
									"        //check if changes have been made from PUT call",
									"        if(getRecord()!=undefined)",
									"        {",
									"            pm.test(\"Update was successful\", function(){",
									"                pm.expect(updateSuccessful()).to.equal(true);",
									"            })",
									"        }",
									"        //will fail if this test is called without the collection runner",
									"        else",
									"        {",
									"            pm.test(\"No record found with given recordId from PUT call\", function(){",
									"                pm.expect(getRecord()).to.not.equal(undefined);",
									"            })",
									"",
									"        }",
									"",
									"        pm.test(\"Status 200, posts are within date range: \"+pm.request.url.query.toObject().from+\" - \"+pm.request.url.query.toObject().to, function(){",
									"            pm.expect(withinDates(pm.request.url.query.toObject().from, pm.request.url.query.toObject().to)).to.equal(true);",
									"        })",
									"    }",
									"}",
									"else if(pm.response.code==404)",
									"{",
									"    pm.test(\"Post id not found\", function(){",
									"        pm.expect(responseBody.object).to.equal(null);",
									"    })",
									"",
									"}",
									"else if (pm.response.code == 403) ",
									"{",
									"    pm.test(\"Unauthorised to make call, only allowed for hypetap\");",
									"}",
									"",
									"//-------------Functions",
									"",
									"function withinDates(from, to)",
									"{",
									"    for(let i =0; i<responseBody.object.length; ++i)",
									"    {",
									"        if(responseBody.object.dateCreated< from &&",
									"            responseBody.object.dateCreated>to)",
									"        {",
									"            return false;",
									"        }",
									"    }",
									"    return true;",
									"}",
									"",
									"//find record we're trying to update in PUT call",
									"function getRecord()",
									"{",
									"    for(let i = 0; i< responseBody.object.length; ++i)",
									"    {",
									"        if(responseBody.object[i].id == pm.variables.get(\"newRecordId\"))",
									"        {",
									"            return  responseBody.object[i];  //retun record if found",
									"        }",
									"    }",
									"}",
									"",
									"// variable \"updateRequest\" contains request from PUT call",
									"//getRecord() returns the record id, (from the response), which we tried to update in PUT call",
									"function updateSuccessful()",
									"{",
									"    //not undefined means it was given in the request",
									"    // field will be undefined in request if not given",
									"    if( (pm.variables.get(\"updateRequest\").record.likes !=undefined) &&",
									"        (getRecord().likes != pm.variables.get(\"updateRequest\").record.likes) )",
									"    {",
									"        return false;",
									"    }",
									"    else if( (pm.variables.get(\"updateRequest\").record.comments !=undefined) &&",
									"        (getRecord().comments != pm.variables.get(\"updateRequest\").record.comments) )",
									"    {",
									"        return false;",
									"    }",
									"    else if( (pm.variables.get(\"updateRequest\").record.impressions !=undefined) &&",
									"        (getRecord().impressions != pm.variables.get(\"updateRequest\").record.impressions) )",
									"    {",
									"        return false;",
									"    }    ",
									"    else if( (pm.variables.get(\"updateRequest\").record.reach !=undefined) &&",
									"        (getRecord().reach != pm.variables.get(\"updateRequest\").record.reach) )",
									"    {",
									"        return false;",
									"    }",
									"        else if( (pm.variables.get(\"updateRequest\").record.views !=undefined) &&",
									"        (getRecord().views != pm.variables.get(\"updateRequest\").record.views) )",
									"    {",
									"        return false;",
									"    }   ",
									"        else if( (pm.variables.get(\"updateRequest\").record.saves !=undefined)  &&",
									"        (getRecord().saves != pm.variables.get(\"updateRequest\").record.saves) )",
									"    {",
									"        return false;",
									"    }",
									"    else",
									"    {",
									"        return true;",
									"    }    ",
									"}",
									"",
									""
								],
								"type": "text/javascript"
							}
						}
					],
					"request": {
						"method": "GET",
						"header": [],
						"url": {
							"raw": "{{test}}post/{{postIdIGTV}}/record?from=2014-12-31&to={{dateNow}}",
							"host": [
								"{{test}}post"
							],
							"path": [
								"{{postIdIGTV}}",
								"record"
							],
							"query": [
								{
									"key": "from",
									"value": "2014-12-31"
								},
								{
									"key": "to",
									"value": "{{dateNow}}"
								}
							]
						}
					},
					"response": []
				},
				{
					"name": "Delete Record ({postId}/record/{recordId})",
					"event": [
						{
							"listen": "test",
							"script": {
								"exec": [
									"// Will not delete for a post with PostSource set to OTHER as record data is not applicable to those posts.",
									"",
									"if(pm.response.code==200)",
									"{",
									"    pm.test(\"Status 200. Deleted record with id \"+ pm.request.url.path[4]);",
									"}",
									"else if (pm.response.code == 403) ",
									"{",
									"    pm.test(\"Unauthorised to make call, only allowed for hypetap\");",
									"}"
								],
								"type": "text/javascript"
							}
						}
					],
					"request": {
						"method": "DELETE",
						"header": [],
						"body": {
							"mode": "raw",
							"raw": ""
						},
						"url": {
							"raw": "{{test}}post/{{postIdIGTV}}/record/{{newRecordId}}",
							"host": [
								"{{test}}post"
							],
							"path": [
								"{{postIdIGTV}}",
								"record",
								"{{newRecordId}}"
							]
						}
					},
					"response": []
				},
				{
					"name": "Records After (requires date range)",
					"event": [
						{
							"listen": "test",
							"script": {
								"exec": [
									"var responseBody = pm.response.json();",
									"",
									"if(pm.response.code==200)",
									"{",
									"    if(responseBody.object.length==0)",
									"    {",
									"        pm.test(\"Status 200 no records returned for postId \" + pm.request.url.path[2]);",
									"    }",
									"    else",
									"    {",
									"",
									"        pm.test(\"Status 200, for postId \" + pm.request.url.path[2]);",
									"",
									"        //both dates has to be given for call to work",
									"        pm.test(\"Records returned: \" + responseBody.object.length+ \". Records are within date range: \"+pm.request.url.query.toObject().from+\" - \"+pm.request.url.query.toObject().to, function(){",
									"            pm.expect(withinDates(pm.request.url.query.toObject().from, pm.request.url.query.toObject().to)).to.equal(true);",
									"        })",
									"",
									"        pm.test(\"Records have decrease by one, (total is same as before POST call)\", function(){",
									"            pm.expect(pm.variables.get(\"totalRecordsBefore\")).to.equal(responseBody.object.length)",
									"        })",
									"",
									"        pm.test(\"Record doesn't exist, was deleted successfuly\", function(){",
									"            pm.expect(recordExist( responseBody.object, pm.variables.get(\"newRecordId\")) ).to.equal(false);",
									"        })",
									"    }",
									"}",
									"else if(pm.response.code==404)",
									"{",
									"    pm.test(\"Post id not found\", function(){",
									"        pm.expect(responseBody.object).to.equal(null);",
									"    })",
									"",
									"}",
									"else if (pm.response.code == 403) ",
									"{",
									"    pm.test(\"Unauthorised to make call, only allowed for hypetap\");",
									"}",
									"",
									"//-------------Functions",
									"",
									"function withinDates(from, to)",
									"{",
									"    for(let i =0; i<responseBody.object.length; ++i)",
									"    {",
									"        if( (new Date(responseBody.object[i].dateCreated).getTime()< new Date(from).getTime() ) &&",
									"            ( new Date(responseBody.object[i].dateCreated).getTime() >new Date(to).getTime() ) )",
									"        {",
									"            return false;",
									"        }",
									"    }",
									"    return true;",
									"",
									"}",
									"// checks if the new record, (from reuest in POST call), exist and if the data match",
									"function recordExist(list, recordId)",
									"{",
									"    for(let i=0; i<list.length; ++i)",
									"    {",
									"        ",
									"        if(recordId==list[i].id)",
									"        {",
									"            return true;",
									"        }",
									"",
									"    }",
									"    return false;    //record not found",
									"}"
								],
								"type": "text/javascript"
							}
						}
					],
					"request": {
						"method": "GET",
						"header": [],
						"url": {
							"raw": "{{test}}post/{{postIdIGTV}}/record?from=2014-12-31&to={{dateNow}}",
							"host": [
								"{{test}}post"
							],
							"path": [
								"{{postIdIGTV}}",
								"record"
							],
							"query": [
								{
									"key": "from",
									"value": "2014-12-31"
								},
								{
									"key": "to",
									"value": "{{dateNow}}",
									"description": "set in pre test script of current folder"
								}
							]
						}
					},
					"response": []
				}
			],
			"event": [
				{
					"listen": "prerequest",
					"script": {
						"type": "text/javascript",
						"exec": [
							"//sets variable \"dateNow\"  with current date",
							"//GET records requires a date range",
							"month = '' + (new Date().getMonth() + 1)",
							"if(month.length<2 )",
							"{",
							"    month='0'+month;",
							"}",
							"",
							"if(new Date().getDate().length<2 )",
							"{",
							"    day='0'+new Date().getDate();",
							"}",
							"else ",
							"{",
							"    day=new Date().getDate();",
							"}",
							"",
							"date = [ new Date().getFullYear(), month, day].join('-');",
							"",
							"pm.variables.set(\"dateNow\", date);"
						]
					}
				},
				{
					"listen": "test",
					"script": {
						"type": "text/javascript",
						"exec": [
							""
						]
					}
				}
			]
		},
		{
			"name": "NEG IGTV - Create, Update and Delete Record",
			"item": [
				{
					"name": "BOSS login",
					"event": [
						{
							"listen": "test",
							"script": {
								"exec": [
									"pm.test(\"Status code is 200\", function () {",
									"    pm.response.to.have.status(200);",
									"});",
									""
								],
								"type": "text/javascript"
							}
						}
					],
					"request": {
						"method": "POST",
						"header": [
							{
								"warning": "This is a duplicate header and will be overridden by the Content-Type header generated by Postman.",
								"key": "Content-Type",
								"value": "application/x-www-form-urlencoded",
								"type": "text"
							}
						],
						"body": {
							"mode": "urlencoded",
							"urlencoded": [
								{
									"key": "username",
									"value": "dumbanddummy1+brooke@gmail.com",
									"description": "dumbanddummy1+brooke@gmail.com",
									"type": "text"
								},
								{
									"key": "password",
									"value": "hypetap1",
									"type": "text"
								},
								{
									"key": "remember-me",
									"value": "true",
									"type": "text"
								}
							]
						},
						"url": {
							"raw": "{{test}}login",
							"host": [
								"{{test}}login"
							]
						}
					},
					"response": []
				},
				{
					"name": "Records Before (requires date range)",
					"event": [
						{
							"listen": "test",
							"script": {
								"exec": [
									"var responseBody = pm.response.json();",
									"",
									"if(pm.response.code==200)",
									"{",
									"    if(responseBody.object.length==0)",
									"    {",
									"        pm.test(\"Status 200 no records returned for postId \" + pm.request.url.path[2]);",
									"    }",
									"    else",
									"    {",
									"        //saves number of records returned to be able to check if number has increased after POST, (add new record) call",
									"        pm.variables.set(\"totalRecordsBefore\", responseBody.object.length);",
									"",
									"        pm.test(\"Status 200, for postId \" + pm.request.url.path[2]);",
									"",
									"        //both dates has to be given for call to work",
									"        pm.test(\"Records returned: \" + responseBody.object.length+ \". Records are within date range: \"+pm.request.url.query.toObject().from+\" - \"+pm.request.url.query.toObject().to, function(){",
									"            pm.expect(withinDates(pm.request.url.query.toObject().from, pm.request.url.query.toObject().to)).to.equal(true);",
									"        })",
									"",
									"    }",
									"}",
									"else if(pm.response.code==404)",
									"{",
									"    pm.test(\"Post id not found\", function(){",
									"        pm.expect(responseBody.object).to.equal(null);",
									"    })",
									"",
									"}",
									"else if (pm.response.code == 403) ",
									"{",
									"    pm.test(\"Unauthorised to make call, only allowed for hypetap\");",
									"}",
									"",
									"//-------------Functions",
									"",
									"function withinDates(from, to)",
									"{",
									"    for(let i =0; i<responseBody.object.length; ++i)",
									"    {",
									"        if( (new Date(responseBody.object[i].dateCreated).getTime()< new Date(from).getTime() ) &&",
									"            ( new Date(responseBody.object[i].dateCreated).getTime() >new Date(to).getTime() ) )",
									"        {",
									"            return false;",
									"        }",
									"    }",
									"    return true;",
									"",
									"}",
									""
								],
								"type": "text/javascript"
							}
						}
					],
					"request": {
						"method": "GET",
						"header": [],
						"url": {
							"raw": "{{test}}post/{{postIdIGTV}}/record?from=2014-12-31&to={{dateNow}}",
							"host": [
								"{{test}}post"
							],
							"path": [
								"{{postIdIGTV}}",
								"record"
							],
							"query": [
								{
									"key": "from",
									"value": "2014-12-31"
								},
								{
									"key": "to",
									"value": "{{dateNow}}",
									"description": "set in pre test script of current folder"
								}
							]
						}
					},
					"response": []
				},
				{
					"name": "Create Record ({postId}/record)",
					"event": [
						{
							"listen": "test",
							"script": {
								"exec": [
									"var responseBody = pm.response.json();",
									"var requestBody = JSON.parse(pm.request.body.raw);",
									"",
									"//runns regardless of status",
									"pm.test(\"Required fields, impressions, views, reach and recordDate are provided\", function(){",
									"    pm.expect(requestBody.record.impressions).to.not.equal(undefined);",
									"    pm.expect(requestBody.record.views).to.not.equal(undefined);",
									"    pm.expect(requestBody.record.reach).to.not.equal(undefined);",
									"    pm.expect(requestBody.recordDate).to.not.equal(undefined);",
									"})",
									"",
									"if(pm.response.code==200)",
									"{",
									"    //save request to be ale to confirm that it was added with the correct data. ",
									"    //records are not allowed to be for the same date, so date is unique",
									"    pm.variables.set(\"newRecord\", requestBody);",
									"",
									"    pm.test(\"Status 200. Returns post corresponding to given postId \"+ pm.request.url.path[2], function(){",
									"        pm.expect( pm.request.url.path[2]).to.equal(responseBody.object.id);",
									"    })",
									"",
									"    //the new record has to be after the post date",
									"    //need to convert dates to be able to compare since they are of the type string",
									"    pm.test(\"The new record is after post date. The date of added record \" + requestBody.recordDate, function(){",
									"        pm.expect(new Date(requestBody.recordDate).getTime()> new Date(responseBody.object.datePosted).getTime() ).to.equal(true);",
									"    })",
									"",
									"}",
									"else if(pm.response.code==400)",
									"{",
									"    //The requested record date cannot be set to before the post date or to the same record date of the last update,",
									"    //(if an update has been made previously).",
									"    // will not update if post source = OTHER",
									"    if(responseBody.notes.userMessage!=undefined)",
									"    {",
									"        pm.test(\"Status 400, userMessage: \"+ responseBody.notes.userMessage, function(){",
									"            pm.expect(responseBody.notes.userMessage).to.be.oneOf([",
									"                                                            \"Cannot update posts fetched via APIs\",",
									"                                                            \"A record must have a date\",",
									"                                                            \"Record must be after post date\",",
									"                                                            \"Post already has a record for that date\",",
									"                                                            \"Can't update automatically fetched records\",",
									"                                                            \"Views must be greater than 0\",",
									"                                                            \"Impressions must be greater than 0\",",
									"                                                            \"Reach must be greater than 0\",",
									"                                                            \"Reach cannot be higher than impressions\",",
									"                                                            \"Likes cannot be higher than reach\",",
									"                                                            \"Record platform does not match post platform\",",
									"                                                            \"Saves cannot be higher than reach\",",
									"                                                            \"Views must equal impressions\",",
									"                                                            \"Views must be greater than or equal to reach\"]);",
									"        })",
									"    }",
									"    else if(responseBody.object===null )",
									"    {",
									"        pm.test(\"Platform is required, make sure it's valid\");",
									"    }",
									"}",
									"else if (pm.response.code == 403) ",
									"{",
									"    pm.test(\"Unauthorised to make call, only allowed for hypetap\");",
									"}",
									"",
									"//---------------Functions",
									""
								],
								"type": "text/javascript"
							}
						}
					],
					"request": {
						"method": "POST",
						"header": [],
						"body": {
							"mode": "raw",
							"raw": "{\n  \"record\": {\n    \"platform\": \"INSTAGRAM\",\n    \"comments\": 1580,\n    \"likes\": 15800,\n    \"impressions\": 15800000,\n    \"reach\": 160000000,\n    \"views\":15800000,\n    \"saves\": 8413\n  },\n  \"recordDate\": \"2021-09-15\"\n}",
							"options": {
								"raw": {
									"language": "json"
								}
							}
						},
						"url": {
							"raw": "{{test}}post/{{postIdIGTV}}/record",
							"host": [
								"{{test}}post"
							],
							"path": [
								"{{postIdIGTV}}",
								"record"
							]
						}
					},
					"response": []
				},
				{
					"name": "Records After (requires date range)",
					"event": [
						{
							"listen": "test",
							"script": {
								"exec": [
									"var responseBody = pm.response.json();",
									"",
									"if(pm.response.code==200)",
									"{",
									"    if(responseBody.object.length==0)",
									"    {",
									"        pm.test(\"Status 200 no records returned for postId \" + pm.request.url.path[2]);",
									"    }",
									"    else",
									"    {",
									"",
									"        pm.test(\"Status 200, for postId \" + pm.request.url.path[2]);",
									"",
									"        //both dates has to be given for call to work",
									"        pm.test(\"Records returned: \" + responseBody.object.length+ \". Records are within date range: \"+pm.request.url.query.toObject().from+\" - \"+pm.request.url.query.toObject().to, function(){",
									"            pm.expect(withinDates(pm.request.url.query.toObject().from, pm.request.url.query.toObject().to)).to.equal(true);",
									"        })",
									"",
									"        pm.test(\"Records have not increase\", function(){",
									"            pm.expect(pm.variables.get(\"totalRecordsBefore\")).to.equal(responseBody.object.length)",
									"        })",
									"    }",
									"}",
									"else if(pm.response.code==404)",
									"{",
									"    pm.test(\"Post id not found\", function(){",
									"        pm.expect(responseBody.object).to.equal(null);",
									"    })",
									"",
									"}",
									"else if (pm.response.code == 403) ",
									"{",
									"    pm.test(\"Unauthorised to make call, only allowed for hypetap\");",
									"}",
									"",
									"//-------------Functions",
									"",
									"function withinDates(from, to)",
									"{",
									"    for(let i =0; i<responseBody.object.length; ++i)",
									"    {",
									"        if( (new Date(responseBody.object[i].dateCreated).getTime()< new Date(from).getTime() ) &&",
									"            ( new Date(responseBody.object[i].dateCreated).getTime() >new Date(to).getTime() ) )",
									"        {",
									"            return false;",
									"        }",
									"    }",
									"    return true;",
									"",
									"}",
									"// checks if the new record, (from reuest in POST call), exist and if the data match",
									"function validateNewRecord(list, record)",
									"{",
									"    count=0;",
									"    for(let i=0; i<list.length; ++i)",
									"    {",
									"        //generate new dates to be able to convert string to date format",
									"        //if they are equal then it's the same record. Only one record can exist for one date",
									"        if(new Date(list[i].dateCreated).getTime() === new Date(record.recordDate).getTime())",
									"        {",
									"           pm.environment.set(\"recordBeforeUpdate\",list[i]);",
									"            //saves id to be able to delete record ",
									"            pm.variables.set(\"newRecordId\", list[i].id);",
									"",
									"            count+= 1;",
									"            //if likes is given and it's not the same value as response then return false, data doesn't match",
									"            if( (record.record.likes!=undefined) && (record.record.likes!=list[i].likes) )",
									"            {",
									"                return false;",
									"            }",
									"            else if( (record.record.comments!=undefined) && (record.record.comments!=list[i].comments) )",
									"            {",
									"                return false;",
									"            }",
									"            else if( (record.record.impressions!=undefined) && (record.record.impressions!=list[i].impressions) )",
									"            {",
									"                return false;",
									"            }",
									"            else if( (record.record.reach!=undefined) && (record.record.reach!=list[i].reach) )",
									"            {",
									"                return false;",
									"            }",
									"            else if( (record.record.views!=undefined) && (record.record.views!=list[i].views) )",
									"            {",
									"                return false;",
									"            }",
									"            else if( (record.record.saves!=undefined) && (record.record.saves!=list[i].saves) )",
									"            {",
									"                return false;",
									"            }                     ",
									"        }",
									"    }",
									"    //count will increase by one if function finds the new record date in the returned list",
									"    //function will return false if record is not found, (count==0) ",
									"    if(count>0)",
									"    {",
									"        return true;    //record exist and all fields match",
									"    }",
									"    return false;    //record not found",
									"}"
								],
								"type": "text/javascript"
							}
						}
					],
					"request": {
						"method": "GET",
						"header": [],
						"url": {
							"raw": "{{test}}post/{{postIdIGTV}}/record?from=2014-12-31&to={{dateNow}}",
							"host": [
								"{{test}}post"
							],
							"path": [
								"{{postIdIGTV}}",
								"record"
							],
							"query": [
								{
									"key": "from",
									"value": "2014-12-31"
								},
								{
									"key": "to",
									"value": "{{dateNow}}",
									"description": "set in pre test script of current folder"
								}
							]
						}
					},
					"response": []
				},
				{
					"name": "Update recordId - Likes higher than reach",
					"event": [
						{
							"listen": "test",
							"script": {
								"exec": [
									"// will only update existing record ids",
									"// returns post and lates record even if no update was done",
									"",
									"var responseBody = pm.response.json();",
									"var requestBody = JSON.parse(pm.request.body.raw);",
									"",
									"//runns regardless of status",
									"pm.test(\"Required fields, impressions, views and reach are provided\", function(){",
									"    pm.expect(requestBody.record.impressions).to.not.equal(undefined);",
									"    pm.expect(requestBody.record.views).to.not.equal(undefined);",
									"    pm.expect(requestBody.record.reach).to.not.equal(undefined);",
									"})",
									"",
									"",
									"// response from this call only shows the lates record so need to validate with another GET call ",
									"// to make sure an uoriginalRecord",
									"if(pm.response.code==200)",
									"{",
									"",
									"    //platform is not returned in get calls",
									"    //saving it from the request here so that it can be used in the revert PUT call",
									"    pm.environment.set(\"platform\", requestBody.record.platform);",
									"",
									"",
									"    // check if all fields have been updated",
									"    // record date is not required, will update existing record and keep old date in non is given",
									"    pm.test(\"Status 200 for recordId \"+ pm.request.url.path[4])",
									"}",
									"else if(pm.response.code==400)",
									"{",
									"    //The requested record date cannot be set to before the post date or to the same record date of the last update,",
									"    //(if an update has been made previously).",
									"    // will not update if post source = OTHER",
									"    if(responseBody.notes.userMessage!=undefined)",
									"    {",
									"        pm.test(\"Status 400, userMessage: \"+ responseBody.notes.userMessage, function(){",
									"            pm.expect(responseBody.notes.userMessage).to.be.oneOf([\"Record must be after post date\",",
									"                                                            \"Post already has a record for that date\",",
									"                                                            \"Can't update automatically fetched records\",",
									"                                                            \"Views must be greater than 0\",",
									"                                                            \"Impressions must be greater than 0\",",
									"                                                            \"Reach must be greater than 0\",",
									"                                                            \"Reach cannot be higher than impressions\",",
									"                                                            \"Likes cannot be higher than reach\",",
									"                                                            \"Record platform does not match post platform\",",
									"                                                            \"Saves cannot be higher than reach\",",
									"                                                            \"Views must be greater than or equal to reach\"]);",
									"        })",
									"    }",
									"    else if(responseBody.object===null )",
									"    {",
									"        pm.test(\"Platform is required, make sure it's valid\");",
									"    }",
									"}",
									"else if(pm.response.code==404)",
									"{",
									"    pm.test(\"Post id not found\", function(){",
									"        pm.expect(responseBody.object).to.equal(null);",
									"    })",
									"",
									"}",
									"else if (pm.response.code == 403) ",
									"{",
									"    pm.test(\"Unauthorised to make call, only allowed for hypetap\");",
									"}",
									"",
									"//---------------Functions",
									"",
									"function updateSuccessful()",
									"{",
									"    //not undefined means it was given in the request",
									"    if( (requestBody.record.likes !=undefined) &&",
									"        (responseBody.object.latestRecord.likes != requestBody.record.likes) )",
									"    {",
									"        return false;",
									"    }",
									"    else if( (requestBody.record.comments !=undefined) &&",
									"        (responseBody.object.latestRecord.comments != requestBody.record.comments) )",
									"    {",
									"        return false;",
									"    }",
									"    else if( (requestBody.record.impressions !=undefined) &&",
									"        (responseBody.object.latestRecord.impressions != requestBody.record.impressions) )",
									"    {",
									"        return false;",
									"    }    ",
									"    else if( (requestBody.record.reach !=undefined) &&",
									"        (responseBody.object.latestRecord.reach != requestBody.record.reach) )",
									"    {",
									"        return false;",
									"    }",
									"        else if( (requestBody.record.views !=undefined) &&",
									"        (responseBody.object.latestRecord.views != requestBody.record.views) )",
									"    {",
									"        return false;",
									"    }   ",
									"        else if( (requestBody.record.saves !=undefined)  &&",
									"        (responseBody.object.latestRecord.saves != requestBody.record.saves) )",
									"    {",
									"        return false;",
									"    }",
									"    else",
									"    {",
									"        return true;",
									"    }    ",
									"}",
									"",
									""
								],
								"type": "text/javascript"
							}
						},
						{
							"listen": "prerequest",
							"script": {
								"exec": [
									"pm.environment.set(\"updateNewRecordId\", pm.environment.get('recordBeforeUpdate').id)"
								],
								"type": "text/javascript"
							}
						}
					],
					"request": {
						"method": "PUT",
						"header": [],
						"body": {
							"mode": "raw",
							"raw": "{\n  \"record\": {\n    \"platform\": \"INSTAGRAM\",\n    \"comments\": 100,\n    \"likes\": 90,\n    \"impressions\": 99,\n    \"reach\": 80,\n    \"views\": 80,\n    \"saves\":10\n  }\n}",
							"options": {
								"raw": {
									"language": "json"
								}
							}
						},
						"url": {
							"raw": "{{test}}post/{{postIdIGTV}}/record/{{updateNewRecordId}}",
							"host": [
								"{{test}}post"
							],
							"path": [
								"{{postIdIGTV}}",
								"record",
								"{{updateNewRecordId}}"
							]
						}
					},
					"response": []
				},
				{
					"name": "Update recordId - Reach higher than impressions",
					"event": [
						{
							"listen": "test",
							"script": {
								"exec": [
									"// will only update existing record ids",
									"// returns post and lates record even if no update was done",
									"",
									"var responseBody = pm.response.json();",
									"var requestBody = JSON.parse(pm.request.body.raw);",
									"",
									"//runns regardless of status",
									"pm.test(\"Required fields, impressions, views and reach are provided\", function(){",
									"    pm.expect(requestBody.record.impressions).to.not.equal(undefined);",
									"    pm.expect(requestBody.record.views).to.not.equal(undefined);",
									"    pm.expect(requestBody.record.reach).to.not.equal(undefined);",
									"})",
									"",
									"",
									"// response from this call only shows the lates record so need to validate with another GET call ",
									"// to make sure an uoriginalRecord",
									"if(pm.response.code==200)",
									"{",
									"",
									"    //platform is not returned in get calls",
									"    //saving it from the request here so that it can be used in the revert PUT call",
									"    pm.environment.set(\"platform\", requestBody.record.platform);",
									"",
									"",
									"    // check if all fields have been updated",
									"    // record date is not required, will update existing record and keep old date in non is given",
									"    pm.test(\"Status 200 for recordId \"+ pm.request.url.path[4])",
									"}",
									"else if(pm.response.code==400)",
									"{",
									"    //The requested record date cannot be set to before the post date or to the same record date of the last update,",
									"    //(if an update has been made previously).",
									"    // will not update if post source = OTHER",
									"    if(responseBody.notes.userMessage!=undefined)",
									"    {",
									"        pm.test(\"Status 400, userMessage: \"+ responseBody.notes.userMessage, function(){",
									"            pm.expect(responseBody.notes.userMessage).to.be.oneOf([\"Record must be after post date\",",
									"                                                            \"Post already has a record for that date\",",
									"                                                            \"Can't update automatically fetched records\",",
									"                                                            \"Views must be greater than 0\",",
									"                                                            \"Impressions must be greater than 0\",",
									"                                                            \"Reach must be greater than 0\",",
									"                                                            \"Reach cannot be higher than impressions\",",
									"                                                            \"Likes cannot be higher than reach\",",
									"                                                            \"Record platform does not match post platform\",",
									"                                                            \"Saves cannot be higher than reach\",",
									"                                                            \"Views must be greater than or equal to reach\"]);",
									"        })",
									"    }",
									"    else if(responseBody.object===null )",
									"    {",
									"        pm.test(\"Platform is required, make sure it's valid\");",
									"    }",
									"}",
									"else if(pm.response.code==404)",
									"{",
									"    pm.test(\"Post id not found\", function(){",
									"        pm.expect(responseBody.object).to.equal(null);",
									"    })",
									"",
									"}",
									"else if (pm.response.code == 403) ",
									"{",
									"    pm.test(\"Unauthorised to make call, only allowed for hypetap\");",
									"}",
									"",
									"//---------------Functions",
									"",
									"function updateSuccessful()",
									"{",
									"    //not undefined means it was given in the request",
									"    if( (requestBody.record.likes !=undefined) &&",
									"        (responseBody.object.latestRecord.likes != requestBody.record.likes) )",
									"    {",
									"        return false;",
									"    }",
									"    else if( (requestBody.record.comments !=undefined) &&",
									"        (responseBody.object.latestRecord.comments != requestBody.record.comments) )",
									"    {",
									"        return false;",
									"    }",
									"    else if( (requestBody.record.impressions !=undefined) &&",
									"        (responseBody.object.latestRecord.impressions != requestBody.record.impressions) )",
									"    {",
									"        return false;",
									"    }    ",
									"    else if( (requestBody.record.reach !=undefined) &&",
									"        (responseBody.object.latestRecord.reach != requestBody.record.reach) )",
									"    {",
									"        return false;",
									"    }",
									"        else if( (requestBody.record.views !=undefined) &&",
									"        (responseBody.object.latestRecord.views != requestBody.record.views) )",
									"    {",
									"        return false;",
									"    }   ",
									"        else if( (requestBody.record.saves !=undefined)  &&",
									"        (responseBody.object.latestRecord.saves != requestBody.record.saves) )",
									"    {",
									"        return false;",
									"    }",
									"    else",
									"    {",
									"        return true;",
									"    }    ",
									"}",
									"",
									""
								],
								"type": "text/javascript"
							}
						},
						{
							"listen": "prerequest",
							"script": {
								"exec": [
									"pm.environment.set(\"updateNewRecordId\", pm.environment.get('recordBeforeUpdate').id)"
								],
								"type": "text/javascript"
							}
						}
					],
					"request": {
						"method": "PUT",
						"header": [],
						"body": {
							"mode": "raw",
							"raw": "{\n  \"record\": {\n    \"platform\": \"INSTAGRAM\",\n    \"comments\": 100,\n    \"likes\": 100,\n    \"impressions\": 90,\n    \"reach\": 100,\n    \"views\": 90,\n    \"saves\":10\n  }\n}",
							"options": {
								"raw": {
									"language": "json"
								}
							}
						},
						"url": {
							"raw": "{{test}}post/{{postIdIGTV}}/record/{{updateNewRecordId}}",
							"host": [
								"{{test}}post"
							],
							"path": [
								"{{postIdIGTV}}",
								"record",
								"{{updateNewRecordId}}"
							]
						}
					},
					"response": []
				},
				{
					"name": "Update recordId - Saves higher than reach",
					"event": [
						{
							"listen": "test",
							"script": {
								"exec": [
									"// will only update existing record ids",
									"// returns post and lates record even if no update was done",
									"",
									"var responseBody = pm.response.json();",
									"var requestBody = JSON.parse(pm.request.body.raw);",
									"",
									"//runns regardless of status",
									"pm.test(\"Required fields, impressions, views and reach are provided\", function(){",
									"    pm.expect(requestBody.record.impressions).to.not.equal(undefined);",
									"    pm.expect(requestBody.record.views).to.not.equal(undefined);",
									"    pm.expect(requestBody.record.reach).to.not.equal(undefined);",
									"})",
									"",
									"",
									"// response from this call only shows the lates record so need to validate with another GET call ",
									"// to make sure an uoriginalRecord",
									"if(pm.response.code==200)",
									"{",
									"",
									"    //platform is not returned in get calls",
									"    //saving it from the request here so that it can be used in the revert PUT call",
									"    pm.environment.set(\"platform\", requestBody.record.platform);",
									"",
									"",
									"    // check if all fields have been updated",
									"    // record date is not required, will update existing record and keep old date in non is given",
									"    pm.test(\"Status 200 for recordId \"+ pm.request.url.path[4])",
									"}",
									"else if(pm.response.code==400)",
									"{",
									"    //The requested record date cannot be set to before the post date or to the same record date of the last update,",
									"    //(if an update has been made previously).",
									"    // will not update if post source = OTHER",
									"    if(responseBody.notes.userMessage!=undefined)",
									"    {",
									"        pm.test(\"Status 400, userMessage: \"+ responseBody.notes.userMessage, function(){",
									"            pm.expect(responseBody.notes.userMessage).to.be.oneOf([\"Record must be after post date\",",
									"                                                            \"Post already has a record for that date\",",
									"                                                            \"Can't update automatically fetched records\",",
									"                                                            \"Views must be greater than 0\",",
									"                                                            \"Impressions must be greater than 0\",",
									"                                                            \"Reach must be greater than 0\",",
									"                                                            \"Reach cannot be higher than impressions\",",
									"                                                            \"Likes cannot be higher than reach\",",
									"                                                            \"Record platform does not match post platform\",",
									"                                                            \"Saves cannot be higher than reach\",",
									"                                                            \"Views must be greater than or equal to reach\"]);",
									"        })",
									"    }",
									"    else if(responseBody.object===null )",
									"    {",
									"        pm.test(\"Platform is required, make sure it's valid\");",
									"    }",
									"}",
									"else if(pm.response.code==404)",
									"{",
									"    pm.test(\"Post id not found\", function(){",
									"        pm.expect(responseBody.object).to.equal(null);",
									"    })",
									"",
									"}",
									"else if (pm.response.code == 403) ",
									"{",
									"    pm.test(\"Unauthorised to make call, only allowed for hypetap\");",
									"}",
									"",
									"//---------------Functions",
									"",
									"function updateSuccessful()",
									"{",
									"    //not undefined means it was given in the request",
									"    if( (requestBody.record.likes !=undefined) &&",
									"        (responseBody.object.latestRecord.likes != requestBody.record.likes) )",
									"    {",
									"        return false;",
									"    }",
									"    else if( (requestBody.record.comments !=undefined) &&",
									"        (responseBody.object.latestRecord.comments != requestBody.record.comments) )",
									"    {",
									"        return false;",
									"    }",
									"    else if( (requestBody.record.impressions !=undefined) &&",
									"        (responseBody.object.latestRecord.impressions != requestBody.record.impressions) )",
									"    {",
									"        return false;",
									"    }    ",
									"    else if( (requestBody.record.reach !=undefined) &&",
									"        (responseBody.object.latestRecord.reach != requestBody.record.reach) )",
									"    {",
									"        return false;",
									"    }",
									"        else if( (requestBody.record.views !=undefined) &&",
									"        (responseBody.object.latestRecord.views != requestBody.record.views) )",
									"    {",
									"        return false;",
									"    }   ",
									"        else if( (requestBody.record.saves !=undefined)  &&",
									"        (responseBody.object.latestRecord.saves != requestBody.record.saves) )",
									"    {",
									"        return false;",
									"    }",
									"    else",
									"    {",
									"        return true;",
									"    }    ",
									"}",
									"",
									""
								],
								"type": "text/javascript"
							}
						},
						{
							"listen": "prerequest",
							"script": {
								"exec": [
									"pm.environment.set(\"updateNewRecordId\", pm.environment.get('recordBeforeUpdate').id)"
								],
								"type": "text/javascript"
							}
						}
					],
					"request": {
						"method": "PUT",
						"header": [],
						"body": {
							"mode": "raw",
							"raw": "{\n  \"record\": {\n    \"platform\": \"INSTAGRAM\",\n    \"comments\": 100,\n    \"likes\": 100,\n    \"impressions\": 110,\n    \"reach\": 100,\n    \"views\": 90,\n    \"saves\":110\n  }\n}",
							"options": {
								"raw": {
									"language": "json"
								}
							}
						},
						"url": {
							"raw": "{{test}}post/{{postIdIGTV}}/record/{{updateNewRecordId}}",
							"host": [
								"{{test}}post"
							],
							"path": [
								"{{postIdIGTV}}",
								"record",
								"{{updateNewRecordId}}"
							]
						}
					},
					"response": []
				}
			],
			"event": [
				{
					"listen": "prerequest",
					"script": {
						"type": "text/javascript",
						"exec": [
							"//sets variable \"dateNow\"  with current date",
							"//GET records requires a date range",
							"month = '' + (new Date().getMonth() + 1)",
							"if(month.length<2 )",
							"{",
							"    month='0'+month;",
							"}",
							"",
							"if(new Date().getDate().length<2 )",
							"{",
							"    day='0'+new Date().getDate();",
							"}",
							"else ",
							"{",
							"    day=new Date().getDate();",
							"}",
							"",
							"date = [ new Date().getFullYear(), month, day].join('-');",
							"",
							"pm.variables.set(\"dateNow\", date);"
						]
					}
				},
				{
					"listen": "test",
					"script": {
						"type": "text/javascript",
						"exec": [
							""
						]
					}
				}
			]
		},
		{
			"name": "REELS - Create, Update and Delete Record",
			"item": [
				{
					"name": "BOSS login",
					"event": [
						{
							"listen": "test",
							"script": {
								"exec": [
									"pm.test(\"Status code is 200\", function () {",
									"    pm.response.to.have.status(200);",
									"});",
									""
								],
								"type": "text/javascript"
							}
						}
					],
					"request": {
						"method": "POST",
						"header": [
							{
								"warning": "This is a duplicate header and will be overridden by the Content-Type header generated by Postman.",
								"key": "Content-Type",
								"value": "application/x-www-form-urlencoded",
								"type": "text"
							}
						],
						"body": {
							"mode": "urlencoded",
							"urlencoded": [
								{
									"key": "username",
									"value": "dumbanddummy1+brooke@gmail.com",
									"description": "dumbanddummy1+brooke@gmail.com",
									"type": "text"
								},
								{
									"key": "password",
									"value": "hypetap1",
									"type": "text"
								},
								{
									"key": "remember-me",
									"value": "true",
									"type": "text"
								}
							]
						},
						"url": {
							"raw": "{{test}}login",
							"host": [
								"{{test}}login"
							]
						}
					},
					"response": []
				},
				{
					"name": "Records Before (requires date range)",
					"event": [
						{
							"listen": "test",
							"script": {
								"exec": [
									"var responseBody = pm.response.json();",
									"",
									"if(pm.response.code==200)",
									"{",
									"    if(responseBody.object.length==0)",
									"    {",
									"        pm.test(\"Status 200 no records returned for postId \" + pm.request.url.path[2]);",
									"    }",
									"    else",
									"    {",
									"        //saves number of records returned to be able to check if number has increased after POST, (add new record) call",
									"        pm.variables.set(\"totalRecordsBefore\", responseBody.object.length);",
									"",
									"        pm.test(\"Status 200, for postId \" + pm.request.url.path[2]);",
									"",
									"        //both dates has to be given for call to work",
									"        pm.test(\"Records returned: \" + responseBody.object.length+ \". Records are within date range: \"+pm.request.url.query.toObject().from+\" - \"+pm.request.url.query.toObject().to, function(){",
									"            pm.expect(withinDates(pm.request.url.query.toObject().from, pm.request.url.query.toObject().to)).to.equal(true);",
									"        })",
									"",
									"    }",
									"}",
									"else if(pm.response.code==404)",
									"{",
									"    pm.test(\"Post id not found\", function(){",
									"        pm.expect(responseBody.object).to.equal(null);",
									"    })",
									"",
									"}",
									"else if (pm.response.code == 403) ",
									"{",
									"    pm.test(\"Unauthorised to make call, only allowed for hypetap\");",
									"}",
									"",
									"//-------------Functions",
									"",
									"function withinDates(from, to)",
									"{",
									"    for(let i =0; i<responseBody.object.length; ++i)",
									"    {",
									"        if( (new Date(responseBody.object[i].dateCreated).getTime()< new Date(from).getTime() ) &&",
									"            ( new Date(responseBody.object[i].dateCreated).getTime() >new Date(to).getTime() ) )",
									"        {",
									"            return false;",
									"        }",
									"    }",
									"    return true;",
									"",
									"}",
									""
								],
								"type": "text/javascript"
							}
						}
					],
					"request": {
						"method": "GET",
						"header": [],
						"url": {
							"raw": "{{test}}post/{{postIdREELS}}/record?from=2014-12-31&to={{dateNow}}",
							"host": [
								"{{test}}post"
							],
							"path": [
								"{{postIdREELS}}",
								"record"
							],
							"query": [
								{
									"key": "from",
									"value": "2014-12-31"
								},
								{
									"key": "to",
									"value": "{{dateNow}}",
									"description": "set in pre test script of current folder"
								}
							]
						}
					},
					"response": []
				},
				{
					"name": "Create Record ({postId}/record)",
					"event": [
						{
							"listen": "test",
							"script": {
								"exec": [
									"var responseBody = pm.response.json();",
									"var requestBody = JSON.parse(pm.request.body.raw);",
									"",
									"//runns regardless of status",
									"pm.test(\"Required fields, impressions, views, reach and recordDate are provided\", function(){",
									"    pm.expect(requestBody.record.impressions).to.not.equal(undefined);",
									"    pm.expect(requestBody.record.views).to.not.equal(undefined);",
									"    pm.expect(requestBody.record.reach).to.not.equal(undefined);",
									"    pm.expect(requestBody.recordDate).to.not.equal(undefined);",
									"})",
									"",
									"if(pm.response.code==200)",
									"{",
									"    //save request to be ale to confirm that it was added with the correct data. ",
									"    //records are not allowed to be for the same date, so date is unique",
									"    pm.variables.set(\"newRecord\", requestBody);",
									"",
									"    pm.test(\"Status 200. Returns post corresponding to given postId \"+ pm.request.url.path[2], function(){",
									"        pm.expect( pm.request.url.path[2]).to.equal(responseBody.object.id);",
									"    })",
									"",
									"    //the new record has to be after the post date",
									"    //need to convert dates to be able to compare since they are of the type string",
									"    pm.test(\"The new record is after post date. The date of added record \" + requestBody.recordDate, function(){",
									"        pm.expect(new Date(requestBody.recordDate).getTime()> new Date(responseBody.object.datePosted).getTime() ).to.equal(true);",
									"    })",
									"",
									"}",
									"else if(pm.response.code==400)",
									"{",
									"    //The requested record date cannot be set to before the post date or to the same record date of the last update,",
									"    //(if an update has been made previously).",
									"    // will not update if post source = OTHER",
									"    if(responseBody.notes.userMessage!=undefined)",
									"    {",
									"        pm.test(\"Status 400, userMessage: \"+ responseBody.notes.userMessage, function(){",
									"            pm.expect(responseBody.notes.userMessage).to.be.oneOf([",
									"                                                            \"Cannot update posts fetched via APIs\",",
									"                                                            \"A record must have a date\",",
									"                                                            \"Record must be after post date\",",
									"                                                            \"Post already has a record for that date\",",
									"                                                            \"Can't update automatically fetched records\",",
									"                                                            \"Views must be greater than 0\",",
									"                                                            \"Impressions must be greater than 0\",",
									"                                                            \"Reach must be greater than 0\",",
									"                                                            \"Reach cannot be higher than impressions\",",
									"                                                            \"Likes cannot be higher than reach\",",
									"                                                            \"Record platform does not match post platform\",",
									"                                                            \"Saves cannot be higher than reach\",",
									"                                                            \"Views must equal impressions\",",
									"                                                            \"Views must be greater than or equal to reach\"]);",
									"        })",
									"    }",
									"    else if(responseBody.object===null )",
									"    {",
									"        pm.test(\"Platform is required, make sure it's valid\");",
									"    }",
									"}",
									"else if (pm.response.code == 403) ",
									"{",
									"    pm.test(\"Unauthorised to make call, only allowed for hypetap\");",
									"}",
									"",
									"//---------------Functions",
									""
								],
								"type": "text/javascript"
							}
						}
					],
					"request": {
						"method": "POST",
						"header": [],
						"body": {
							"mode": "raw",
							"raw": "{\n  \"record\": {\n    \"platform\": \"INSTAGRAM\",\n    \"comments\": 100,\n    \"likes\": 100,\n    \"impressions\": 100,\n    \"reach\": 100,\n    \"views\":100,\n    \"saves\": 100\n  },\n  \"recordDate\": \"2021-09-15\"\n}",
							"options": {
								"raw": {
									"language": "json"
								}
							}
						},
						"url": {
							"raw": "{{test}}post/{{postIdREELS}}/record",
							"host": [
								"{{test}}post"
							],
							"path": [
								"{{postIdREELS}}",
								"record"
							]
						}
					},
					"response": []
				},
				{
					"name": "Records After (requires date range)",
					"event": [
						{
							"listen": "test",
							"script": {
								"exec": [
									"var responseBody = pm.response.json();",
									"",
									"if(pm.response.code==200)",
									"{",
									"    if(responseBody.object.length==0)",
									"    {",
									"        pm.test(\"Status 200 no records returned for postId \" + pm.request.url.path[2]);",
									"    }",
									"    else",
									"    {",
									"",
									"        pm.test(\"Status 200, for postId \" + pm.request.url.path[2]);",
									"",
									"        //both dates has to be given for call to work",
									"        pm.test(\"Records returned: \" + responseBody.object.length+ \". Records are within date range: \"+pm.request.url.query.toObject().from+\" - \"+pm.request.url.query.toObject().to, function(){",
									"            pm.expect(withinDates(pm.request.url.query.toObject().from, pm.request.url.query.toObject().to)).to.equal(true);",
									"        })",
									"",
									"        pm.test(\"Records have increase by one\", function(){",
									"            pm.expect(pm.variables.get(\"totalRecordsBefore\")+1).to.equal(responseBody.object.length)",
									"        })",
									"        //validates if record exist and if it contains the same values given POST call",
									"        //also saves recordID to be able to delete it ",
									"        pm.test(\"The new record has been added and contains the same values given in POST call\", function(){",
									"            pm.expect(validateNewRecord( responseBody.object, pm.variables.get(\"newRecord\")) ).to.equal(true);",
									"        })",
									"    }",
									"}",
									"else if(pm.response.code==404)",
									"{",
									"    pm.test(\"Post id not found\", function(){",
									"        pm.expect(responseBody.object).to.equal(null);",
									"    })",
									"",
									"}",
									"else if (pm.response.code == 403) ",
									"{",
									"    pm.test(\"Unauthorised to make call, only allowed for hypetap\");",
									"}",
									"",
									"//-------------Functions",
									"",
									"function withinDates(from, to)",
									"{",
									"    for(let i =0; i<responseBody.object.length; ++i)",
									"    {",
									"        if( (new Date(responseBody.object[i].dateCreated).getTime()< new Date(from).getTime() ) &&",
									"            ( new Date(responseBody.object[i].dateCreated).getTime() >new Date(to).getTime() ) )",
									"        {",
									"            return false;",
									"        }",
									"    }",
									"    return true;",
									"",
									"}",
									"// checks if the new record, (from reuest in POST call), exist and if the data match",
									"function validateNewRecord(list, record)",
									"{",
									"    count=0;",
									"    for(let i=0; i<list.length; ++i)",
									"    {",
									"        //generate new dates to be able to convert string to date format",
									"        //if they are equal then it's the same record. Only one record can exist for one date",
									"        if(new Date(list[i].dateCreated).getTime() === new Date(record.recordDate).getTime())",
									"        {",
									"           pm.environment.set(\"recordBeforeUpdate\",list[i]);",
									"            //saves id to be able to delete record ",
									"            pm.variables.set(\"newRecordId\", list[i].id);",
									"",
									"            count+= 1;",
									"            //if likes is given and it's not the same value as response then return false, data doesn't match",
									"            if( (record.record.likes!=undefined) && (record.record.likes!=list[i].likes) )",
									"            {",
									"                return false;",
									"            }",
									"            else if( (record.record.comments!=undefined) && (record.record.comments!=list[i].comments) )",
									"            {",
									"                return false;",
									"            }",
									"            else if( (record.record.impressions!=undefined) && (record.record.impressions!=list[i].impressions) )",
									"            {",
									"                return false;",
									"            }",
									"            else if( (record.record.reach!=undefined) && (record.record.reach!=list[i].reach) )",
									"            {",
									"                return false;",
									"            }",
									"            else if( (record.record.views!=undefined) && (record.record.views!=list[i].views) )",
									"            {",
									"                return false;",
									"            }",
									"            else if( (record.record.saves!=undefined) && (record.record.saves!=list[i].saves) )",
									"            {",
									"                return false;",
									"            }                     ",
									"        }",
									"    }",
									"    //count will increase by one if function finds the new record date in the returned list",
									"    //function will return false if record is not found, (count==0) ",
									"    if(count>0)",
									"    {",
									"        return true;    //record exist and all fields match",
									"    }",
									"    return false;    //record not found",
									"}"
								],
								"type": "text/javascript"
							}
						}
					],
					"request": {
						"method": "GET",
						"header": [],
						"url": {
							"raw": "{{test}}post/{{postIdREELS}}/record?from=2014-12-31&to={{dateNow}}",
							"host": [
								"{{test}}post"
							],
							"path": [
								"{{postIdREELS}}",
								"record"
							],
							"query": [
								{
									"key": "from",
									"value": "2014-12-31"
								},
								{
									"key": "to",
									"value": "{{dateNow}}",
									"description": "set in pre test script of current folder"
								}
							]
						}
					},
					"response": []
				},
				{
					"name": "Update recordId",
					"event": [
						{
							"listen": "test",
							"script": {
								"exec": [
									"// will only update existing record ids",
									"// returns post and lates record even if no update was done",
									"",
									"var responseBody = pm.response.json();",
									"var requestBody = JSON.parse(pm.request.body.raw);",
									"",
									"//runns regardless of status",
									"pm.test(\"Required fields, impressions, views and reach are provided\", function(){",
									"    pm.expect(requestBody.record.impressions).to.not.equal(undefined);",
									"    pm.expect(requestBody.record.views).to.not.equal(undefined);",
									"    pm.expect(requestBody.record.reach).to.not.equal(undefined);",
									"})",
									"",
									"//save request to be able to validate if changes were made in get call",
									"pm.variables.set(\"updateRequest\", requestBody);",
									"",
									"// response from this call only shows the lates record so need to validate with another GET call ",
									"// to make sure an uoriginalRecord",
									"if(pm.response.code==200)",
									"{",
									"",
									"    //platform is not returned in get calls",
									"    //saving it from the request here so that it can be used in the revert PUT call",
									"    pm.environment.set(\"platform\", requestBody.record.platform);",
									"",
									"",
									"    // check if all fields have been updated",
									"    // record date is not required, will update existing record and keep old date in non is given",
									"    pm.test(\"Status 200 for recordId \"+ pm.request.url.path[4])",
									"}",
									"else if(pm.response.code==400)",
									"{",
									"    //The requested record date cannot be set to before the post date or to the same record date of the last update,",
									"    //(if an update has been made previously).",
									"    // will not update if post source = OTHER",
									"    if(responseBody.notes.userMessage!=undefined)",
									"    {",
									"        pm.test(\"Status 400, userMessage: \"+ responseBody.notes.userMessage, function(){",
									"            pm.expect(responseBody.notes.userMessage).to.be.oneOf([\"Record must be after post date\",",
									"                                                            \"Post already has a record for that date\",",
									"                                                            \"Can't update automatically fetched records\",",
									"                                                            \"Views must be greater than 0\",",
									"                                                            \"Impressions must be greater than 0\",",
									"                                                            \"Reach must be greater than 0\",",
									"                                                            \"Reach cannot be higher than impressions\",",
									"                                                            \"Likes cannot be higher than reach\",",
									"                                                            \"Record platform does not match post platform\",",
									"                                                            \"Saves cannot be higher than reach\",",
									"                                                            \"Views must be greater than or equal to reach\"]);",
									"        })",
									"    }",
									"    else if(responseBody.object===null )",
									"    {",
									"        pm.test(\"Platform is required, make sure it's valid\");",
									"    }",
									"}",
									"else if(pm.response.code==404)",
									"{",
									"    pm.test(\"Post id not found\", function(){",
									"        pm.expect(responseBody.object).to.equal(null);",
									"    })",
									"",
									"}",
									"else if (pm.response.code == 403) ",
									"{",
									"    pm.test(\"Unauthorised to make call, only allowed for hypetap\");",
									"}",
									"",
									"//---------------Functions",
									"",
									"function updateSuccessful()",
									"{",
									"    //not undefined means it was given in the request",
									"    if( (requestBody.record.likes !=undefined) &&",
									"        (responseBody.object.latestRecord.likes != requestBody.record.likes) )",
									"    {",
									"        return false;",
									"    }",
									"    else if( (requestBody.record.comments !=undefined) &&",
									"        (responseBody.object.latestRecord.comments != requestBody.record.comments) )",
									"    {",
									"        return false;",
									"    }",
									"    else if( (requestBody.record.impressions !=undefined) &&",
									"        (responseBody.object.latestRecord.impressions != requestBody.record.impressions) )",
									"    {",
									"        return false;",
									"    }    ",
									"    else if( (requestBody.record.reach !=undefined) &&",
									"        (responseBody.object.latestRecord.reach != requestBody.record.reach) )",
									"    {",
									"        return false;",
									"    }",
									"        else if( (requestBody.record.views !=undefined) &&",
									"        (responseBody.object.latestRecord.views != requestBody.record.views) )",
									"    {",
									"        return false;",
									"    }   ",
									"        else if( (requestBody.record.saves !=undefined)  &&",
									"        (responseBody.object.latestRecord.saves != requestBody.record.saves) )",
									"    {",
									"        return false;",
									"    }",
									"    else",
									"    {",
									"        return true;",
									"    }    ",
									"}",
									"",
									""
								],
								"type": "text/javascript"
							}
						},
						{
							"listen": "prerequest",
							"script": {
								"exec": [
									"pm.environment.set(\"updateNewRecordId\", pm.environment.get('recordBeforeUpdate').id)"
								],
								"type": "text/javascript"
							}
						}
					],
					"request": {
						"method": "PUT",
						"header": [],
						"body": {
							"mode": "raw",
							"raw": "{\n  \"record\": {\n    \"platform\": \"INSTAGRAM\",\n    \"comments\": 200,\n    \"likes\": 200,\n    \"impressions\": 200,\n    \"reach\": 200,\n    \"views\": 200,\n    \"saves\":200\n  }\n}",
							"options": {
								"raw": {
									"language": "json"
								}
							}
						},
						"url": {
							"raw": "{{test}}post/{{postIdREELS}}/record/{{updateNewRecordId}}",
							"host": [
								"{{test}}post"
							],
							"path": [
								"{{postIdREELS}}",
								"record",
								"{{updateNewRecordId}}"
							]
						}
					},
					"response": []
				},
				{
					"name": "Verify updates",
					"event": [
						{
							"listen": "test",
							"script": {
								"exec": [
									"var responseBody = pm.response.json();",
									"",
									"if(pm.response.code==200)",
									"{",
									"    ",
									"    if(responseBody.object.length==0)",
									"    {",
									"        pm.test(\"Status 200 no records returned\");",
									"    }",
									"    else",
									"    {        ",
									"        //if a record is found",
									"        //check if changes have been made from PUT call",
									"        if(getRecord()!=undefined)",
									"        {",
									"            pm.test(\"Update was successful\", function(){",
									"                pm.expect(updateSuccessful()).to.equal(true);",
									"            })",
									"        }",
									"        //will fail if this test is called without the collection runner",
									"        else",
									"        {",
									"            pm.test(\"No record found with given recordId from PUT call\", function(){",
									"                pm.expect(getRecord()).to.not.equal(undefined);",
									"            })",
									"",
									"        }",
									"",
									"        pm.test(\"Status 200, posts are within date range: \"+pm.request.url.query.toObject().from+\" - \"+pm.request.url.query.toObject().to, function(){",
									"            pm.expect(withinDates(pm.request.url.query.toObject().from, pm.request.url.query.toObject().to)).to.equal(true);",
									"        })",
									"    }",
									"}",
									"else if(pm.response.code==404)",
									"{",
									"    pm.test(\"Post id not found\", function(){",
									"        pm.expect(responseBody.object).to.equal(null);",
									"    })",
									"",
									"}",
									"else if (pm.response.code == 403) ",
									"{",
									"    pm.test(\"Unauthorised to make call, only allowed for hypetap\");",
									"}",
									"",
									"//-------------Functions",
									"",
									"function withinDates(from, to)",
									"{",
									"    for(let i =0; i<responseBody.object.length; ++i)",
									"    {",
									"        if(responseBody.object.dateCreated< from &&",
									"            responseBody.object.dateCreated>to)",
									"        {",
									"            return false;",
									"        }",
									"    }",
									"    return true;",
									"}",
									"",
									"//find record we're trying to update in PUT call",
									"function getRecord()",
									"{",
									"    for(let i = 0; i< responseBody.object.length; ++i)",
									"    {",
									"        if(responseBody.object[i].id == pm.variables.get(\"newRecordId\"))",
									"        {",
									"            return  responseBody.object[i];  //retun record if found",
									"        }",
									"    }",
									"}",
									"",
									"// variable \"updateRequest\" contains request from PUT call",
									"//getRecord() returns the record id, (from the response), which we tried to update in PUT call",
									"function updateSuccessful()",
									"{",
									"    //not undefined means it was given in the request",
									"    // field will be undefined in request if not given",
									"    if( (pm.variables.get(\"updateRequest\").record.likes !=undefined) &&",
									"        (getRecord().likes != pm.variables.get(\"updateRequest\").record.likes) )",
									"    {",
									"        return false;",
									"    }",
									"    else if( (pm.variables.get(\"updateRequest\").record.comments !=undefined) &&",
									"        (getRecord().comments != pm.variables.get(\"updateRequest\").record.comments) )",
									"    {",
									"        return false;",
									"    }",
									"    else if( (pm.variables.get(\"updateRequest\").record.impressions !=undefined) &&",
									"        (getRecord().impressions != pm.variables.get(\"updateRequest\").record.impressions) )",
									"    {",
									"        return false;",
									"    }    ",
									"    else if( (pm.variables.get(\"updateRequest\").record.reach !=undefined) &&",
									"        (getRecord().reach != pm.variables.get(\"updateRequest\").record.reach) )",
									"    {",
									"        return false;",
									"    }",
									"        else if( (pm.variables.get(\"updateRequest\").record.views !=undefined) &&",
									"        (getRecord().views != pm.variables.get(\"updateRequest\").record.views) )",
									"    {",
									"        return false;",
									"    }   ",
									"        else if( (pm.variables.get(\"updateRequest\").record.saves !=undefined)  &&",
									"        (getRecord().saves != pm.variables.get(\"updateRequest\").record.saves) )",
									"    {",
									"        return false;",
									"    }",
									"    else",
									"    {",
									"        return true;",
									"    }    ",
									"}",
									"",
									""
								],
								"type": "text/javascript"
							}
						}
					],
					"request": {
						"method": "GET",
						"header": [],
						"url": {
							"raw": "{{test}}post/{{postIdREELS}}/record?from=2014-12-31&to={{dateNow}}",
							"host": [
								"{{test}}post"
							],
							"path": [
								"{{postIdREELS}}",
								"record"
							],
							"query": [
								{
									"key": "from",
									"value": "2014-12-31"
								},
								{
									"key": "to",
									"value": "{{dateNow}}"
								}
							]
						}
					},
					"response": []
				},
				{
					"name": "Revert updates",
					"event": [
						{
							"listen": "test",
							"script": {
								"exec": [
									"// will only update existing record ids",
									"// returns post and lates record even if no update was done",
									"",
									"var responseBody = pm.response.json();",
									"var requestBody = JSON.parse(pm.request.body.raw);",
									"",
									"pm.test(\"Required fields, impressions, views and reach are provided\", function(){",
									"    pm.expect(requestBody.record.impressions).to.not.equal(undefined);",
									"    pm.expect(requestBody.record.views).to.not.equal(undefined);",
									"    pm.expect(requestBody.record.reach).to.not.equal(undefined);",
									"})",
									"",
									"",
									"// response from this call only shows the lates record so need to validate with another GET call ",
									"// to make sure an update was made",
									"if(pm.response.code==200)",
									"{",
									"    //save request to be able to validate if changes were made in get call",
									"    pm.variables.set(\"updateRequest\", requestBody);",
									"",
									"    // check if all fields have been updated",
									"    // record date is not required, will update existing record and keep old date in non is given",
									"    pm.test(\"Status 200 for recordId \"+ pm.request.url.path[4])",
									"}",
									"else if(pm.response.code==400)",
									"{",
									"    //The requested record date cannot be set to before the post date or to the same record date of the last update,",
									"    //(if an update has been made previously).",
									"    // will not update if post source = OTHER",
									"    if(responseBody.notes.userMessage!=undefined)",
									"    {",
									"        pm.test(\"Status 400, userMessage: \"+ responseBody.notes.userMessage, function(){",
									"            pm.expect(responseBody.notes.userMessage).to.be.oneOf([\"Record must be after post date\",",
									"                                                            \"Post already has a record for that date\",",
									"                                                            \"Can't update automatically fetched records\",",
									"                                                            \"Views must be greater than 0\",",
									"                                                            \"Impressions must be greater than 0\",",
									"                                                            \"Reach must be greater than 0\",",
									"                                                            \"Reach cannot be higher than impressions\",",
									"                                                            \"Likes cannot be higher than reach\",",
									"                                                            \"Record platform does not match post platform\",",
									"                                                            \"Saves cannot be higher than reach\",",
									"                                                            \"Views must be greater than or equal to reach\"]);",
									"        })",
									"    }",
									"    else if(responseBody.object===null )",
									"    {",
									"        pm.test(\"Platform is required, make sure it's valid\");",
									"    }",
									"}",
									"else if(pm.response.code==404)",
									"{",
									"    pm.test(\"Post id not found\", function(){",
									"        pm.expect(responseBody.object).to.equal(null);",
									"    })",
									"",
									"}",
									"else if (pm.response.code == 403) ",
									"{",
									"    pm.test(\"Unauthorised to make call, only allowed for hypetap\");",
									"}",
									"",
									"//---------------Functions",
									""
								],
								"type": "text/javascript"
							}
						},
						{
							"listen": "prerequest",
							"script": {
								"exec": [
									"pm.environment.set(\"comments\", pm.environment.get('recordBeforeUpdate').comments)",
									"pm.environment.set(\"likes\",pm.environment.get('recordBeforeUpdate').likes)",
									"pm.environment.set(\"impressions\", pm.environment.get('recordBeforeUpdate').impressions)",
									"pm.environment.set(\"reach\", pm.environment.get('recordBeforeUpdate').reach)",
									"pm.environment.set(\"views\", pm.environment.get('recordBeforeUpdate').views)",
									"pm.environment.set(\"saves\", pm.environment.get('recordBeforeUpdate').saves)",
									"",
									"pm.environment.set(\"recordDate\",pm.environment.get('recordBeforeUpdate').dateCreated)",
									"//pm.environment.set(\"platform\", JSON.parse(pm.environment.get('platform')))",
									"",
									"",
									""
								],
								"type": "text/javascript"
							}
						}
					],
					"request": {
						"method": "PUT",
						"header": [],
						"body": {
							"mode": "raw",
							"raw": "{\n  \"record\": {\n    \"platform\": \"{{platform}}\",\n    \"comments\": {{comments}},\n    \"likes\": {{likes}},\n    \"impressions\": {{impressions}},\n    \"reach\": {{reach}},\n    \"views\": {{views}},\n    \"saves\":{{saves}}\n  }\n}",
							"options": {
								"raw": {
									"language": "json"
								}
							}
						},
						"url": {
							"raw": "{{test}}post/{{postIdREELS}}/record/{{updateNewRecordId}}",
							"host": [
								"{{test}}post"
							],
							"path": [
								"{{postIdREELS}}",
								"record",
								"{{updateNewRecordId}}"
							]
						}
					},
					"response": []
				},
				{
					"name": "Verify updates",
					"event": [
						{
							"listen": "test",
							"script": {
								"exec": [
									"var responseBody = pm.response.json();",
									"",
									"if(pm.response.code==200)",
									"{",
									"    ",
									"    if(responseBody.object.length==0)",
									"    {",
									"        pm.test(\"Status 200 no records returned\");",
									"    }",
									"    else",
									"    {        ",
									"        //if a record is found",
									"        //check if changes have been made from PUT call",
									"        if(getRecord()!=undefined)",
									"        {",
									"            pm.test(\"Update was successful\", function(){",
									"                pm.expect(updateSuccessful()).to.equal(true);",
									"            })",
									"        }",
									"        //will fail if this test is called without the collection runner",
									"        else",
									"        {",
									"            pm.test(\"No record found with given recordId from PUT call\", function(){",
									"                pm.expect(getRecord()).to.not.equal(undefined);",
									"            })",
									"",
									"        }",
									"",
									"        pm.test(\"Status 200, posts are within date range: \"+pm.request.url.query.toObject().from+\" - \"+pm.request.url.query.toObject().to, function(){",
									"            pm.expect(withinDates(pm.request.url.query.toObject().from, pm.request.url.query.toObject().to)).to.equal(true);",
									"        })",
									"    }",
									"}",
									"else if(pm.response.code==404)",
									"{",
									"    pm.test(\"Post id not found\", function(){",
									"        pm.expect(responseBody.object).to.equal(null);",
									"    })",
									"",
									"}",
									"else if (pm.response.code == 403) ",
									"{",
									"    pm.test(\"Unauthorised to make call, only allowed for hypetap\");",
									"}",
									"",
									"//-------------Functions",
									"",
									"function withinDates(from, to)",
									"{",
									"    for(let i =0; i<responseBody.object.length; ++i)",
									"    {",
									"        if(responseBody.object.dateCreated< from &&",
									"            responseBody.object.dateCreated>to)",
									"        {",
									"            return false;",
									"        }",
									"    }",
									"    return true;",
									"}",
									"",
									"//find record we're trying to update in PUT call",
									"function getRecord()",
									"{",
									"    for(let i = 0; i< responseBody.object.length; ++i)",
									"    {",
									"        if(responseBody.object[i].id == pm.variables.get(\"newRecordId\"))",
									"        {",
									"            return  responseBody.object[i];  //retun record if found",
									"        }",
									"    }",
									"}",
									"",
									"// variable \"updateRequest\" contains request from PUT call",
									"//getRecord() returns the record id, (from the response), which we tried to update in PUT call",
									"function updateSuccessful()",
									"{",
									"    //not undefined means it was given in the request",
									"    // field will be undefined in request if not given",
									"    if( (pm.variables.get(\"updateRequest\").record.likes !=undefined) &&",
									"        (getRecord().likes != pm.variables.get(\"updateRequest\").record.likes) )",
									"    {",
									"        return false;",
									"    }",
									"    else if( (pm.variables.get(\"updateRequest\").record.comments !=undefined) &&",
									"        (getRecord().comments != pm.variables.get(\"updateRequest\").record.comments) )",
									"    {",
									"        return false;",
									"    }",
									"    else if( (pm.variables.get(\"updateRequest\").record.impressions !=undefined) &&",
									"        (getRecord().impressions != pm.variables.get(\"updateRequest\").record.impressions) )",
									"    {",
									"        return false;",
									"    }    ",
									"    else if( (pm.variables.get(\"updateRequest\").record.reach !=undefined) &&",
									"        (getRecord().reach != pm.variables.get(\"updateRequest\").record.reach) )",
									"    {",
									"        return false;",
									"    }",
									"        else if( (pm.variables.get(\"updateRequest\").record.views !=undefined) &&",
									"        (getRecord().views != pm.variables.get(\"updateRequest\").record.views) )",
									"    {",
									"        return false;",
									"    }   ",
									"        else if( (pm.variables.get(\"updateRequest\").record.saves !=undefined)  &&",
									"        (getRecord().saves != pm.variables.get(\"updateRequest\").record.saves) )",
									"    {",
									"        return false;",
									"    }",
									"    else",
									"    {",
									"        return true;",
									"    }    ",
									"}",
									"",
									""
								],
								"type": "text/javascript"
							}
						}
					],
					"request": {
						"method": "GET",
						"header": [],
						"url": {
							"raw": "{{test}}post/{{postIdREELS}}/record?from=2014-12-31&to={{dateNow}}",
							"host": [
								"{{test}}post"
							],
							"path": [
								"{{postIdREELS}}",
								"record"
							],
							"query": [
								{
									"key": "from",
									"value": "2014-12-31"
								},
								{
									"key": "to",
									"value": "{{dateNow}}"
								}
							]
						}
					},
					"response": []
				},
				{
					"name": "Delete Record ({postId}/record/{recordId})",
					"event": [
						{
							"listen": "test",
							"script": {
								"exec": [
									"// Will not delete for a post with PostSource set to OTHER as record data is not applicable to those posts.",
									"",
									"if(pm.response.code==200)",
									"{",
									"    pm.test(\"Status 200. Deleted record with id \"+ pm.request.url.path[4]);",
									"}",
									"else if (pm.response.code == 403) ",
									"{",
									"    pm.test(\"Unauthorised to make call, only allowed for hypetap\");",
									"}"
								],
								"type": "text/javascript"
							}
						}
					],
					"request": {
						"method": "DELETE",
						"header": [],
						"body": {
							"mode": "raw",
							"raw": ""
						},
						"url": {
							"raw": "{{test}}post/{{postIdREELS}}/record/{{newRecordId}}",
							"host": [
								"{{test}}post"
							],
							"path": [
								"{{postIdREELS}}",
								"record",
								"{{newRecordId}}"
							]
						}
					},
					"response": []
				},
				{
					"name": "Records After (requires date range)",
					"event": [
						{
							"listen": "test",
							"script": {
								"exec": [
									"var responseBody = pm.response.json();",
									"",
									"if(pm.response.code==200)",
									"{",
									"    if(responseBody.object.length==0)",
									"    {",
									"        pm.test(\"Status 200 no records returned for postId \" + pm.request.url.path[2]);",
									"    }",
									"    else",
									"    {",
									"",
									"        pm.test(\"Status 200, for postId \" + pm.request.url.path[2]);",
									"",
									"        //both dates has to be given for call to work",
									"        pm.test(\"Records returned: \" + responseBody.object.length+ \". Records are within date range: \"+pm.request.url.query.toObject().from+\" - \"+pm.request.url.query.toObject().to, function(){",
									"            pm.expect(withinDates(pm.request.url.query.toObject().from, pm.request.url.query.toObject().to)).to.equal(true);",
									"        })",
									"",
									"        pm.test(\"Records have decrease by one, (total is same as before POST call)\", function(){",
									"            pm.expect(pm.variables.get(\"totalRecordsBefore\")).to.equal(responseBody.object.length)",
									"        })",
									"",
									"        pm.test(\"Record doesn't exist, was deleted successfuly\", function(){",
									"            pm.expect(recordExist( responseBody.object, pm.variables.get(\"newRecordId\")) ).to.equal(false);",
									"        })",
									"    }",
									"}",
									"else if(pm.response.code==404)",
									"{",
									"    pm.test(\"Post id not found\", function(){",
									"        pm.expect(responseBody.object).to.equal(null);",
									"    })",
									"",
									"}",
									"else if (pm.response.code == 403) ",
									"{",
									"    pm.test(\"Unauthorised to make call, only allowed for hypetap\");",
									"}",
									"",
									"//-------------Functions",
									"",
									"function withinDates(from, to)",
									"{",
									"    for(let i =0; i<responseBody.object.length; ++i)",
									"    {",
									"        if( (new Date(responseBody.object[i].dateCreated).getTime()< new Date(from).getTime() ) &&",
									"            ( new Date(responseBody.object[i].dateCreated).getTime() >new Date(to).getTime() ) )",
									"        {",
									"            return false;",
									"        }",
									"    }",
									"    return true;",
									"",
									"}",
									"// checks if the new record, (from reuest in POST call), exist and if the data match",
									"function recordExist(list, recordId)",
									"{",
									"    for(let i=0; i<list.length; ++i)",
									"    {",
									"        ",
									"        if(recordId==list[i].id)",
									"        {",
									"            return true;",
									"        }",
									"",
									"    }",
									"    return false;    //record not found",
									"}"
								],
								"type": "text/javascript"
							}
						}
					],
					"request": {
						"method": "GET",
						"header": [],
						"url": {
							"raw": "{{test}}post/{{postIdREELS}}/record?from=2014-12-31&to={{dateNow}}",
							"host": [
								"{{test}}post"
							],
							"path": [
								"{{postIdREELS}}",
								"record"
							],
							"query": [
								{
									"key": "from",
									"value": "2014-12-31"
								},
								{
									"key": "to",
									"value": "{{dateNow}}",
									"description": "set in pre test script of current folder"
								}
							]
						}
					},
					"response": []
				}
			],
			"event": [
				{
					"listen": "prerequest",
					"script": {
						"type": "text/javascript",
						"exec": [
							"//sets variable \"dateNow\"  with current date",
							"//GET records requires a date range",
							"month = '' + (new Date().getMonth() + 1)",
							"if(month.length<2 )",
							"{",
							"    month='0'+month;",
							"}",
							"",
							"if(new Date().getDate().length<2 )",
							"{",
							"    day='0'+new Date().getDate();",
							"}",
							"else ",
							"{",
							"    day=new Date().getDate();",
							"}",
							"",
							"date = [ new Date().getFullYear(), month, day].join('-');",
							"",
							"pm.variables.set(\"dateNow\", date);"
						]
					}
				},
				{
					"listen": "test",
					"script": {
						"type": "text/javascript",
						"exec": [
							""
						]
					}
				}
			]
		},
		{
			"name": "NEG REELS - Create, Update and Delete Record",
			"item": [
				{
					"name": "BOSS login",
					"event": [
						{
							"listen": "test",
							"script": {
								"exec": [
									"pm.test(\"Status code is 200\", function () {",
									"    pm.response.to.have.status(200);",
									"});",
									""
								],
								"type": "text/javascript"
							}
						}
					],
					"request": {
						"method": "POST",
						"header": [
							{
								"warning": "This is a duplicate header and will be overridden by the Content-Type header generated by Postman.",
								"key": "Content-Type",
								"value": "application/x-www-form-urlencoded",
								"type": "text"
							}
						],
						"body": {
							"mode": "urlencoded",
							"urlencoded": [
								{
									"key": "username",
									"value": "dumbanddummy1+brooke@gmail.com",
									"description": "dumbanddummy1+brooke@gmail.com",
									"type": "text"
								},
								{
									"key": "password",
									"value": "hypetap1",
									"type": "text"
								},
								{
									"key": "remember-me",
									"value": "true",
									"type": "text"
								}
							]
						},
						"url": {
							"raw": "{{test}}login",
							"host": [
								"{{test}}login"
							]
						}
					},
					"response": []
				},
				{
					"name": "Records Before (requires date range)",
					"event": [
						{
							"listen": "test",
							"script": {
								"exec": [
									"var responseBody = pm.response.json();",
									"",
									"if(pm.response.code==200)",
									"{",
									"    if(responseBody.object.length==0)",
									"    {",
									"        pm.test(\"Status 200 no records returned for postId \" + pm.request.url.path[2]);",
									"    }",
									"    else",
									"    {",
									"        //saves number of records returned to be able to check if number has increased after POST, (add new record) call",
									"        pm.variables.set(\"totalRecordsBefore\", responseBody.object.length);",
									"",
									"        pm.test(\"Status 200, for postId \" + pm.request.url.path[2]);",
									"",
									"        //both dates has to be given for call to work",
									"        pm.test(\"Records returned: \" + responseBody.object.length+ \". Records are within date range: \"+pm.request.url.query.toObject().from+\" - \"+pm.request.url.query.toObject().to, function(){",
									"            pm.expect(withinDates(pm.request.url.query.toObject().from, pm.request.url.query.toObject().to)).to.equal(true);",
									"        })",
									"",
									"    }",
									"}",
									"else if(pm.response.code==404)",
									"{",
									"    pm.test(\"Post id not found\", function(){",
									"        pm.expect(responseBody.object).to.equal(null);",
									"    })",
									"",
									"}",
									"else if (pm.response.code == 403) ",
									"{",
									"    pm.test(\"Unauthorised to make call, only allowed for hypetap\");",
									"}",
									"",
									"//-------------Functions",
									"",
									"function withinDates(from, to)",
									"{",
									"    for(let i =0; i<responseBody.object.length; ++i)",
									"    {",
									"        if( (new Date(responseBody.object[i].dateCreated).getTime()< new Date(from).getTime() ) &&",
									"            ( new Date(responseBody.object[i].dateCreated).getTime() >new Date(to).getTime() ) )",
									"        {",
									"            return false;",
									"        }",
									"    }",
									"    return true;",
									"",
									"}",
									""
								],
								"type": "text/javascript"
							}
						}
					],
					"request": {
						"method": "GET",
						"header": [],
						"url": {
							"raw": "{{test}}post/{{postIdREELS}}/record?from=2014-12-31&to={{dateNow}}",
							"host": [
								"{{test}}post"
							],
							"path": [
								"{{postIdREELS}}",
								"record"
							],
							"query": [
								{
									"key": "from",
									"value": "2014-12-31"
								},
								{
									"key": "to",
									"value": "{{dateNow}}",
									"description": "set in pre test script of current folder"
								}
							]
						}
					},
					"response": []
				},
				{
					"name": "Create Record ({postId}/record) - Reach > Views",
					"event": [
						{
							"listen": "test",
							"script": {
								"exec": [
									"var responseBody = pm.response.json();",
									"var requestBody = JSON.parse(pm.request.body.raw);",
									"",
									"//runns regardless of status",
									"pm.test(\"Required fields, impressions, views, reach and recordDate are provided\", function(){",
									"    pm.expect(requestBody.record.impressions).to.not.equal(undefined);",
									"    pm.expect(requestBody.record.views).to.not.equal(undefined);",
									"    pm.expect(requestBody.record.reach).to.not.equal(undefined);",
									"    pm.expect(requestBody.recordDate).to.not.equal(undefined);",
									"})",
									"",
									"if(pm.response.code==200)",
									"{",
									"    //save request to be ale to confirm that it was added with the correct data. ",
									"    //records are not allowed to be for the same date, so date is unique",
									"    pm.variables.set(\"newRecord\", requestBody);",
									"",
									"    pm.test(\"Status 200. Returns post corresponding to given postId \"+ pm.request.url.path[2], function(){",
									"        pm.expect( pm.request.url.path[2]).to.equal(responseBody.object.id);",
									"    })",
									"",
									"    //the new record has to be after the post date",
									"    //need to convert dates to be able to compare since they are of the type string",
									"    pm.test(\"The new record is after post date. The date of added record \" + requestBody.recordDate, function(){",
									"        pm.expect(new Date(requestBody.recordDate).getTime()> new Date(responseBody.object.datePosted).getTime() ).to.equal(true);",
									"    })",
									"",
									"}",
									"else if(pm.response.code==400)",
									"{",
									"    //The requested record date cannot be set to before the post date or to the same record date of the last update,",
									"    //(if an update has been made previously).",
									"    // will not update if post source = OTHER",
									"    if(responseBody.notes.userMessage!=undefined)",
									"    {",
									"        pm.test(\"Status 400, userMessage: \"+ responseBody.notes.userMessage, function(){",
									"            pm.expect(responseBody.notes.userMessage).to.be.oneOf([",
									"                                                            \"Cannot update posts fetched via APIs\",",
									"                                                            \"A record must have a date\",",
									"                                                            \"Record must be after post date\",",
									"                                                            \"Post already has a record for that date\",",
									"                                                            \"Can't update automatically fetched records\",",
									"                                                            \"Views must be greater than 0\",",
									"                                                            \"Impressions must be greater than 0\",",
									"                                                            \"Reach must be greater than 0\",",
									"                                                            \"Reach cannot be higher than impressions\",",
									"                                                            \"Likes cannot be higher than reach\",",
									"                                                            \"Record platform does not match post platform\",",
									"                                                            \"Saves cannot be higher than reach\",",
									"                                                            \"Views must equal impressions\",",
									"                                                            \"Views must be greater than or equal to reach\"]);",
									"        })",
									"    }",
									"    else if(responseBody.object===null )",
									"    {",
									"        pm.test(\"Platform is required, make sure it's valid\");",
									"    }",
									"}",
									"else if (pm.response.code == 403) ",
									"{",
									"    pm.test(\"Unauthorised to make call, only allowed for hypetap\");",
									"}",
									"",
									"//---------------Functions",
									""
								],
								"type": "text/javascript"
							}
						}
					],
					"request": {
						"method": "POST",
						"header": [],
						"body": {
							"mode": "raw",
							"raw": "{\n  \"record\": {\n    \"platform\": \"INSTAGRAM\",\n    \"comments\": 1580,\n    \"likes\": 15800,\n    \"impressions\": 16000000,\n    \"reach\": 17000000,\n    \"views\":16000000,\n    \"saves\": 8413\n  },\n  \"recordDate\": \"2021-09-15\"\n}",
							"options": {
								"raw": {
									"language": "json"
								}
							}
						},
						"url": {
							"raw": "{{test}}post/{{postIdREELS}}/record",
							"host": [
								"{{test}}post"
							],
							"path": [
								"{{postIdREELS}}",
								"record"
							]
						}
					},
					"response": []
				},
				{
					"name": "Records After (requires date range)",
					"event": [
						{
							"listen": "test",
							"script": {
								"exec": [
									"var responseBody = pm.response.json();",
									"",
									"if(pm.response.code==200)",
									"{",
									"    if(responseBody.object.length==0)",
									"    {",
									"        pm.test(\"Status 200 no records returned for postId \" + pm.request.url.path[2]);",
									"    }",
									"    else",
									"    {",
									"",
									"        pm.test(\"Status 200, for postId \" + pm.request.url.path[2]);",
									"",
									"        //both dates has to be given for call to work",
									"        pm.test(\"Records returned: \" + responseBody.object.length+ \". Records are within date range: \"+pm.request.url.query.toObject().from+\" - \"+pm.request.url.query.toObject().to, function(){",
									"            pm.expect(withinDates(pm.request.url.query.toObject().from, pm.request.url.query.toObject().to)).to.equal(true);",
									"        })",
									"",
									"        pm.test(\"Records have not increase\", function(){",
									"            pm.expect(pm.variables.get(\"totalRecordsBefore\")).to.equal(responseBody.object.length)",
									"        })",
									"",
									"    }",
									"}",
									"else if(pm.response.code==404)",
									"{",
									"    pm.test(\"Post id not found\", function(){",
									"        pm.expect(responseBody.object).to.equal(null);",
									"    })",
									"",
									"}",
									"else if (pm.response.code == 403) ",
									"{",
									"    pm.test(\"Unauthorised to make call, only allowed for hypetap\");",
									"}",
									"",
									"//-------------Functions",
									"",
									"function withinDates(from, to)",
									"{",
									"    for(let i =0; i<responseBody.object.length; ++i)",
									"    {",
									"        if( (new Date(responseBody.object[i].dateCreated).getTime()< new Date(from).getTime() ) &&",
									"            ( new Date(responseBody.object[i].dateCreated).getTime() >new Date(to).getTime() ) )",
									"        {",
									"            return false;",
									"        }",
									"    }",
									"    return true;",
									"",
									"}",
									"// checks if the new record, (from reuest in POST call), exist and if the data match",
									"function validateNewRecord(list, record)",
									"{",
									"    count=0;",
									"    for(let i=0; i<list.length; ++i)",
									"    {",
									"        //generate new dates to be able to convert string to date format",
									"        //if they are equal then it's the same record. Only one record can exist for one date",
									"        if(new Date(list[i].dateCreated).getTime() === new Date(record.recordDate).getTime())",
									"        {",
									"           pm.environment.set(\"recordBeforeUpdate\",list[i]);",
									"            //saves id to be able to delete record ",
									"            pm.variables.set(\"newRecordId\", list[i].id);",
									"",
									"            count+= 1;",
									"            //if likes is given and it's not the same value as response then return false, data doesn't match",
									"            if( (record.record.likes!=undefined) && (record.record.likes!=list[i].likes) )",
									"            {",
									"                return false;",
									"            }",
									"            else if( (record.record.comments!=undefined) && (record.record.comments!=list[i].comments) )",
									"            {",
									"                return false;",
									"            }",
									"            else if( (record.record.impressions!=undefined) && (record.record.impressions!=list[i].impressions) )",
									"            {",
									"                return false;",
									"            }",
									"            else if( (record.record.reach!=undefined) && (record.record.reach!=list[i].reach) )",
									"            {",
									"                return false;",
									"            }",
									"            else if( (record.record.views!=undefined) && (record.record.views!=list[i].views) )",
									"            {",
									"                return false;",
									"            }",
									"            else if( (record.record.saves!=undefined) && (record.record.saves!=list[i].saves) )",
									"            {",
									"                return false;",
									"            }                     ",
									"        }",
									"    }",
									"    //count will increase by one if function finds the new record date in the returned list",
									"    //function will return false if record is not found, (count==0) ",
									"    if(count>0)",
									"    {",
									"        return true;    //record exist and all fields match",
									"    }",
									"    return false;    //record not found",
									"}"
								],
								"type": "text/javascript"
							}
						}
					],
					"request": {
						"method": "GET",
						"header": [],
						"url": {
							"raw": "{{test}}post/{{postIdREELS}}/record?from=2014-12-31&to={{dateNow}}",
							"host": [
								"{{test}}post"
							],
							"path": [
								"{{postIdREELS}}",
								"record"
							],
							"query": [
								{
									"key": "from",
									"value": "2014-12-31"
								},
								{
									"key": "to",
									"value": "{{dateNow}}",
									"description": "set in pre test script of current folder"
								}
							]
						}
					},
					"response": []
				}
			],
			"event": [
				{
					"listen": "prerequest",
					"script": {
						"type": "text/javascript",
						"exec": [
							"//sets variable \"dateNow\"  with current date",
							"//GET records requires a date range",
							"month = '' + (new Date().getMonth() + 1)",
							"if(month.length<2 )",
							"{",
							"    month='0'+month;",
							"}",
							"",
							"if(new Date().getDate().length<2 )",
							"{",
							"    day='0'+new Date().getDate();",
							"}",
							"else ",
							"{",
							"    day=new Date().getDate();",
							"}",
							"",
							"date = [ new Date().getFullYear(), month, day].join('-');",
							"",
							"pm.variables.set(\"dateNow\", date);"
						]
					}
				},
				{
					"listen": "test",
					"script": {
						"type": "text/javascript",
						"exec": [
							""
						]
					}
				}
			]
		},
		{
			"name": "TIKTOK - Create, Update and Delete Record",
			"item": [
				{
					"name": "BOSS login",
					"event": [
						{
							"listen": "test",
							"script": {
								"exec": [
									"pm.test(\"Status code is 200\", function () {",
									"    pm.response.to.have.status(200);",
									"});",
									""
								],
								"type": "text/javascript"
							}
						}
					],
					"request": {
						"method": "POST",
						"header": [
							{
								"warning": "This is a duplicate header and will be overridden by the Content-Type header generated by Postman.",
								"key": "Content-Type",
								"value": "application/x-www-form-urlencoded",
								"type": "text"
							}
						],
						"body": {
							"mode": "urlencoded",
							"urlencoded": [
								{
									"key": "username",
									"value": "dumbanddummy1+brooke@gmail.com",
									"description": "dumbanddummy1+brooke@gmail.com",
									"type": "text"
								},
								{
									"key": "password",
									"value": "hypetap1",
									"type": "text"
								},
								{
									"key": "remember-me",
									"value": "true",
									"type": "text"
								}
							]
						},
						"url": {
							"raw": "{{test}}login",
							"host": [
								"{{test}}login"
							]
						}
					},
					"response": []
				},
				{
					"name": "Records Before (requires date range)",
					"event": [
						{
							"listen": "test",
							"script": {
								"exec": [
									"var responseBody = pm.response.json();",
									"",
									"if(pm.response.code==200)",
									"{",
									"    if(responseBody.object.length==0)",
									"    {",
									"        pm.test(\"Status 200 no records returned for postId \" + pm.request.url.path[2]);",
									"    }",
									"    else",
									"    {",
									"        //saves number of records returned to be able to check if number has increased after POST, (add new record) call",
									"        pm.variables.set(\"totalRecordsBefore\", responseBody.object.length);",
									"",
									"        pm.test(\"Status 200, for postId \" + pm.request.url.path[2]);",
									"",
									"        //both dates has to be given for call to work",
									"        pm.test(\"Records returned: \" + responseBody.object.length+ \". Records are within date range: \"+pm.request.url.query.toObject().from+\" - \"+pm.request.url.query.toObject().to, function(){",
									"            pm.expect(withinDates(pm.request.url.query.toObject().from, pm.request.url.query.toObject().to)).to.equal(true);",
									"        })",
									"",
									"    }",
									"}",
									"else if(pm.response.code==404)",
									"{",
									"    pm.test(\"Post id not found\", function(){",
									"        pm.expect(responseBody.object).to.equal(null);",
									"    })",
									"",
									"}",
									"else if (pm.response.code == 403) ",
									"{",
									"    pm.test(\"Unauthorised to make call, only allowed for hypetap\");",
									"}",
									"",
									"//-------------Functions",
									"",
									"function withinDates(from, to)",
									"{",
									"    for(let i =0; i<responseBody.object.length; ++i)",
									"    {",
									"        if( (new Date(responseBody.object[i].dateCreated).getTime()< new Date(from).getTime() ) &&",
									"            ( new Date(responseBody.object[i].dateCreated).getTime() >new Date(to).getTime() ) )",
									"        {",
									"            return false;",
									"        }",
									"    }",
									"    return true;",
									"",
									"}",
									""
								],
								"type": "text/javascript"
							}
						}
					],
					"request": {
						"method": "GET",
						"header": [],
						"url": {
							"raw": "{{test}}post/{{postIdTIKTOK}}/record?from=2014-12-31&to={{dateNow}}",
							"host": [
								"{{test}}post"
							],
							"path": [
								"{{postIdTIKTOK}}",
								"record"
							],
							"query": [
								{
									"key": "from",
									"value": "2014-12-31"
								},
								{
									"key": "to",
									"value": "{{dateNow}}",
									"description": "set in pre test script of current folder"
								}
							]
						}
					},
					"response": []
				},
				{
					"name": "Create Record ({postId}/record)",
					"event": [
						{
							"listen": "test",
							"script": {
								"exec": [
									"var responseBody = pm.response.json();",
									"var requestBody = JSON.parse(pm.request.body.raw);",
									"",
									"//runns regardless of status",
									"pm.test(\"Required fields, impressions, views, reach and recordDate are provided\", function(){",
									"    pm.expect(requestBody.record.impressions).to.not.equal(undefined);",
									"    pm.expect(requestBody.record.views).to.not.equal(undefined);",
									"    pm.expect(requestBody.record.reach).to.not.equal(undefined);",
									"    pm.expect(requestBody.recordDate).to.not.equal(undefined);",
									"})",
									"",
									"if(pm.response.code==200)",
									"{",
									"    //save request to be ale to confirm that it was added with the correct data. ",
									"    //records are not allowed to be for the same date, so date is unique",
									"    pm.variables.set(\"newRecord\", requestBody);",
									"",
									"    pm.test(\"Status 200. Returns post corresponding to given postId \"+ pm.request.url.path[2], function(){",
									"        pm.expect( pm.request.url.path[2]).to.equal(responseBody.object.id);",
									"    })",
									"",
									"    //the new record has to be after the post date",
									"    //need to convert dates to be able to compare since they are of the type string",
									"    pm.test(\"The new record is after post date. The date of added record \" + requestBody.recordDate, function(){",
									"        pm.expect(new Date(requestBody.recordDate).getTime()> new Date(responseBody.object.datePosted).getTime() ).to.equal(true);",
									"    })",
									"",
									"}",
									"else if(pm.response.code==400)",
									"{",
									"    //The requested record date cannot be set to before the post date or to the same record date of the last update,",
									"    //(if an update has been made previously).",
									"    // will not update if post source = OTHER",
									"    if(responseBody.notes.userMessage!=undefined)",
									"    {",
									"        pm.test(\"Status 400, userMessage: \"+ responseBody.notes.userMessage, function(){",
									"            pm.expect(responseBody.notes.userMessage).to.be.oneOf([",
									"                                                            \"Cannot update posts fetched via APIs\",",
									"                                                            \"A record must have a date\",",
									"                                                            \"Record must be after post date\",",
									"                                                            \"Post already has a record for that date\",",
									"                                                            \"Can't update automatically fetched records\",",
									"                                                            \"Views must be greater than 0\",",
									"                                                            \"Impressions must be greater than 0\",",
									"                                                            \"Reach must be greater than 0\",",
									"                                                            \"Reach cannot be higher than impressions\",",
									"                                                            \"Likes cannot be higher than reach\",",
									"                                                            \"Record platform does not match post platform\",",
									"                                                            \"Saves cannot be higher than reach\",",
									"                                                            \"Views must equal impressions\",",
									"                                                            \"Views must be greater than or equal to reach\"]);",
									"        })",
									"    }",
									"    else if(responseBody.object===null )",
									"    {",
									"        pm.test(\"Platform is required, make sure it's valid\");",
									"    }",
									"}",
									"else if (pm.response.code == 403) ",
									"{",
									"    pm.test(\"Unauthorised to make call, only allowed for hypetap\");",
									"}",
									"",
									"//---------------Functions",
									""
								],
								"type": "text/javascript"
							}
						}
					],
					"request": {
						"method": "POST",
						"header": [],
						"body": {
							"mode": "raw",
							"raw": "{\n  \"record\": {\n    \"platform\": \"TIKTOK\",\n    \"comments\": 100,\n    \"impressions\": 15800000,\n    \"reach\": 15800000,\n    \"views\":15800000,\n    \"shares\": 100,\n    \"likes\": 100,\n    \"totalPlayTime\": 100,\n    \"averageWatchTime\": 100\n  },\n  \"recordDate\": \"2021-09-21\"\n}",
							"options": {
								"raw": {
									"language": "json"
								}
							}
						},
						"url": {
							"raw": "{{test}}post/{{postIdTIKTOK}}/record",
							"host": [
								"{{test}}post"
							],
							"path": [
								"{{postIdTIKTOK}}",
								"record"
							]
						}
					},
					"response": []
				},
				{
					"name": "Records After (requires date range)",
					"event": [
						{
							"listen": "test",
							"script": {
								"exec": [
									"var responseBody = pm.response.json();",
									"",
									"if(pm.response.code==200)",
									"{",
									"    if(responseBody.object.length==0)",
									"    {",
									"        pm.test(\"Status 200 no records returned for postId \" + pm.request.url.path[2]);",
									"    }",
									"    else",
									"    {",
									"",
									"        pm.test(\"Status 200, for postId \" + pm.request.url.path[2]);",
									"",
									"        //both dates has to be given for call to work",
									"        pm.test(\"Records returned: \" + responseBody.object.length+ \". Records are within date range: \"+pm.request.url.query.toObject().from+\" - \"+pm.request.url.query.toObject().to, function(){",
									"            pm.expect(withinDates(pm.request.url.query.toObject().from, pm.request.url.query.toObject().to)).to.equal(true);",
									"        })",
									"",
									"        pm.test(\"Records have increase by one\", function(){",
									"            pm.expect(pm.variables.get(\"totalRecordsBefore\")+1).to.equal(responseBody.object.length)",
									"        })",
									"        //validates if record exist and if it contains the same values given POST call",
									"        //also saves recordID to be able to delete it ",
									"        pm.test(\"The new record has been added and contains the same values given in POST call\", function(){",
									"            pm.expect(validateNewRecord( responseBody.object, pm.variables.get(\"newRecord\")) ).to.equal(true);",
									"        })",
									"    }",
									"}",
									"else if(pm.response.code==404)",
									"{",
									"    pm.test(\"Post id not found\", function(){",
									"        pm.expect(responseBody.object).to.equal(null);",
									"    })",
									"",
									"}",
									"else if (pm.response.code == 403) ",
									"{",
									"    pm.test(\"Unauthorised to make call, only allowed for hypetap\");",
									"}",
									"",
									"//-------------Functions",
									"",
									"function withinDates(from, to)",
									"{",
									"    for(let i =0; i<responseBody.object.length; ++i)",
									"    {",
									"        if( (new Date(responseBody.object[i].dateCreated).getTime()< new Date(from).getTime() ) &&",
									"            ( new Date(responseBody.object[i].dateCreated).getTime() >new Date(to).getTime() ) )",
									"        {",
									"            return false;",
									"        }",
									"    }",
									"    return true;",
									"",
									"}",
									"// checks if the new record, (from reuest in POST call), exist and if the data match",
									"function validateNewRecord(list, record)",
									"{",
									"    count=0;",
									"    for(let i=0; i<list.length; ++i)",
									"    {",
									"        //generate new dates to be able to convert string to date format",
									"        //if they are equal then it's the same record. Only one record can exist for one date",
									"        if(new Date(list[i].dateCreated).getTime() === new Date(record.recordDate).getTime())",
									"        {",
									"           pm.environment.set(\"recordBeforeUpdate\",list[i]);",
									"            //saves id to be able to delete record ",
									"            pm.variables.set(\"newRecordId\", list[i].id);",
									"",
									"            count+= 1;",
									"            //if likes is given and it's not the same value as response then return false, data doesn't match",
									"            if( (record.record.likes!=undefined) && (record.record.likes!=list[i].likes) )",
									"            {",
									"                return false;",
									"            }",
									"            else if( (record.record.comments!=undefined) && (record.record.comments!=list[i].comments) )",
									"            {",
									"                return false;",
									"            }",
									"            else if( (record.record.impressions!=undefined) && (record.record.impressions!=list[i].impressions) )",
									"            {",
									"                return false;",
									"            }",
									"            else if( (record.record.reach!=undefined) && (record.record.reach!=list[i].reach) )",
									"            {",
									"                return false;",
									"            }",
									"            else if( (record.record.views!=undefined) && (record.record.views!=list[i].views) )",
									"            {",
									"                return false;",
									"            } ",
									"            else if( (record.record.shares!=undefined) && (record.record.shares!=list[i].shares) )",
									"            {",
									"                return false;",
									"            }",
									"            else if( (record.record.totalPlayTime!=undefined) && (record.record.totalPlayTime!=list[i].totalPlayTime) )",
									"            {",
									"                return false;",
									"            }",
									"            else if( (record.record.averageWatchTime!=undefined) && (record.record.averageWatchTime!=list[i].averageWatchTime) )",
									"            {",
									"                return false;",
									"            }            ",
									"        }",
									"    }",
									"    //count will increase by one if function finds the new record date in the returned list",
									"    //function will return false if record is not found, (count==0) ",
									"    if(count>0)",
									"    {",
									"        return true;    //record exist and all fields match",
									"    }",
									"    return false;    //record not found",
									"}"
								],
								"type": "text/javascript"
							}
						}
					],
					"request": {
						"method": "GET",
						"header": [],
						"url": {
							"raw": "{{test}}post/{{postIdTIKTOK}}/record?from=2014-12-31&to={{dateNow}}",
							"host": [
								"{{test}}post"
							],
							"path": [
								"{{postIdTIKTOK}}",
								"record"
							],
							"query": [
								{
									"key": "from",
									"value": "2014-12-31"
								},
								{
									"key": "to",
									"value": "{{dateNow}}",
									"description": "set in pre test script of current folder"
								}
							]
						}
					},
					"response": []
				},
				{
					"name": "Update recordId",
					"event": [
						{
							"listen": "test",
							"script": {
								"exec": [
									"// will only update existing record ids",
									"// returns post and lates record even if no update was done",
									"",
									"var responseBody = pm.response.json();",
									"var requestBody = JSON.parse(pm.request.body.raw);",
									"",
									"//runns regardless of status",
									"pm.test(\"Required fields, impressions, views and reach are provided\", function(){",
									"    pm.expect(requestBody.record.impressions).to.not.equal(undefined);",
									"    pm.expect(requestBody.record.views).to.not.equal(undefined);",
									"    pm.expect(requestBody.record.reach).to.not.equal(undefined);",
									"})",
									"",
									"//save request to be able to validate if changes were made in get call",
									"pm.variables.set(\"updateRequest\", requestBody);",
									"",
									"// response from this call only shows the lates record so need to validate with another GET call ",
									"// to make sure an uoriginalRecord",
									"if(pm.response.code==200)",
									"{",
									"",
									"    //platform is not returned in get calls",
									"    //saving it from the request here so that it can be used in the revert PUT call",
									"    pm.environment.set(\"platform\", requestBody.record.platform);",
									"",
									"",
									"    // check if all fields have been updated",
									"    // record date is not required, will update existing record and keep old date in non is given",
									"    pm.test(\"Status 200 for recordId \"+ pm.request.url.path[4])",
									"}",
									"else if(pm.response.code==400)",
									"{",
									"    //The requested record date cannot be set to before the post date or to the same record date of the last update,",
									"    //(if an update has been made previously).",
									"    // will not update if post source = OTHER",
									"    if(responseBody.notes.userMessage!=undefined)",
									"    {",
									"        pm.test(\"Status 400, userMessage: \"+ responseBody.notes.userMessage, function(){",
									"            pm.expect(responseBody.notes.userMessage).to.be.oneOf([\"Record must be after post date\",",
									"                                                            \"Post already has a record for that date\",",
									"                                                            \"Can't update automatically fetched records\",",
									"                                                            \"Views must be greater than 0\",",
									"                                                            \"Impressions must be greater than 0\",",
									"                                                            \"Reach must be greater than 0\",",
									"                                                            \"Reach cannot be higher than impressions\",",
									"                                                            \"Likes cannot be higher than reach\",",
									"                                                            \"Record platform does not match post platform\",",
									"                                                            \"Saves cannot be higher than reach\",",
									"                                                            \"Views must be greater than or equal to reach\"]);",
									"        })",
									"    }",
									"    else if(responseBody.object===null )",
									"    {",
									"        pm.test(\"Platform is required, make sure it's valid\");",
									"    }",
									"}",
									"else if(pm.response.code==404)",
									"{",
									"    pm.test(\"Post id not found\", function(){",
									"        pm.expect(responseBody.object).to.equal(null);",
									"    })",
									"",
									"}",
									"else if (pm.response.code == 403) ",
									"{",
									"    pm.test(\"Unauthorised to make call, only allowed for hypetap\");",
									"}",
									"",
									"//---------------Functions",
									"",
									"function updateSuccessful()",
									"{",
									"    //not undefined means it was given in the request",
									"    if( (requestBody.record.likes !=undefined) &&",
									"        (responseBody.object.latestRecord.likes != requestBody.record.likes) )",
									"    {",
									"        return false;",
									"    }",
									"    else if( (requestBody.record.comments !=undefined) &&",
									"        (responseBody.object.latestRecord.comments != requestBody.record.comments) )",
									"    {",
									"        return false;",
									"    }",
									"    else if( (requestBody.record.impressions !=undefined) &&",
									"        (responseBody.object.latestRecord.impressions != requestBody.record.impressions) )",
									"    {",
									"        return false;",
									"    }    ",
									"    else if( (requestBody.record.reach !=undefined) &&",
									"        (responseBody.object.latestRecord.reach != requestBody.record.reach) )",
									"    {",
									"        return false;",
									"    }",
									"        else if( (requestBody.record.views !=undefined) &&",
									"        (responseBody.object.latestRecord.views != requestBody.record.views) )",
									"    {",
									"        return false;",
									"    }   ",
									"        else if( (requestBody.record.saves !=undefined)  &&",
									"        (responseBody.object.latestRecord.saves != requestBody.record.saves) )",
									"    {",
									"        return false;",
									"    }",
									"    else",
									"    {",
									"        return true;",
									"    }    ",
									"}",
									"",
									""
								],
								"type": "text/javascript"
							}
						},
						{
							"listen": "prerequest",
							"script": {
								"exec": [
									"pm.environment.set(\"updateNewRecordId\", pm.environment.get('recordBeforeUpdate').id)"
								],
								"type": "text/javascript"
							}
						}
					],
					"request": {
						"method": "PUT",
						"header": [],
						"body": {
							"mode": "raw",
							"raw": "{\n  \"record\": {\n    \"platform\": \"TIKTOK\",\n    \"comments\": 200,\n    \"likes\": 200,\n    \"impressions\": 200,\n    \"reach\": 200,\n    \"views\": 200,\n    \"shares\":200,\n    \"totalPlayTime\":200,\n    \"averageWatchTime\":200\n  }\n}",
							"options": {
								"raw": {
									"language": "json"
								}
							}
						},
						"url": {
							"raw": "{{test}}post/{{postIdTIKTOK}}/record/{{updateNewRecordId}}",
							"host": [
								"{{test}}post"
							],
							"path": [
								"{{postIdTIKTOK}}",
								"record",
								"{{updateNewRecordId}}"
							]
						}
					},
					"response": []
				},
				{
					"name": "Verify updates",
					"event": [
						{
							"listen": "test",
							"script": {
								"exec": [
									"var responseBody = pm.response.json();",
									"",
									"if(pm.response.code==200)",
									"{",
									"    ",
									"    if(responseBody.object.length==0)",
									"    {",
									"        pm.test(\"Status 200 no records returned\");",
									"    }",
									"    else",
									"    {        ",
									"        //if a record is found",
									"        //check if changes have been made from PUT call",
									"        if(getRecord()!=undefined)",
									"        {",
									"            pm.test(\"Update was successful\", function(){",
									"                pm.expect(updateSuccessful()).to.equal(true);",
									"            })",
									"        }",
									"        //will fail if this test is called without the collection runner",
									"        else",
									"        {",
									"            pm.test(\"No record found with given recordId from PUT call\", function(){",
									"                pm.expect(getRecord()).to.not.equal(undefined);",
									"            })",
									"",
									"        }",
									"",
									"        pm.test(\"Status 200, posts are within date range: \"+pm.request.url.query.toObject().from+\" - \"+pm.request.url.query.toObject().to, function(){",
									"            pm.expect(withinDates(pm.request.url.query.toObject().from, pm.request.url.query.toObject().to)).to.equal(true);",
									"        })",
									"    }",
									"}",
									"else if(pm.response.code==404)",
									"{",
									"    pm.test(\"Post id not found\", function(){",
									"        pm.expect(responseBody.object).to.equal(null);",
									"    })",
									"",
									"}",
									"else if (pm.response.code == 403) ",
									"{",
									"    pm.test(\"Unauthorised to make call, only allowed for hypetap\");",
									"}",
									"",
									"//-------------Functions",
									"",
									"function withinDates(from, to)",
									"{",
									"    for(let i =0; i<responseBody.object.length; ++i)",
									"    {",
									"        if(responseBody.object.dateCreated< from &&",
									"            responseBody.object.dateCreated>to)",
									"        {",
									"            return false;",
									"        }",
									"    }",
									"    return true;",
									"}",
									"",
									"//find record we're trying to update in PUT call",
									"function getRecord()",
									"{",
									"    for(let i = 0; i< responseBody.object.length; ++i)",
									"    {",
									"        if(responseBody.object[i].id == pm.variables.get(\"newRecordId\"))",
									"        {",
									"            return  responseBody.object[i];  //retun record if found",
									"        }",
									"    }",
									"}",
									"",
									"// variable \"updateRequest\" contains request from PUT call",
									"//getRecord() returns the record id, (from the response), which we tried to update in PUT call",
									"function updateSuccessful()",
									"{",
									"    //not undefined means it was given in the request",
									"    // field will be undefined in request if not given",
									"    if( (pm.variables.get(\"updateRequest\").record.likes !=undefined) &&",
									"        (getRecord().likes != pm.variables.get(\"updateRequest\").record.likes) )",
									"    {",
									"        return false;",
									"    }",
									"    else if( (pm.variables.get(\"updateRequest\").record.comments !=undefined) &&",
									"        (getRecord().comments != pm.variables.get(\"updateRequest\").record.comments) )",
									"    {",
									"        return false;",
									"    }",
									"    else if( (pm.variables.get(\"updateRequest\").record.impressions !=undefined) &&",
									"        (getRecord().impressions != pm.variables.get(\"updateRequest\").record.impressions) )",
									"    {",
									"        return false;",
									"    }    ",
									"    else if( (pm.variables.get(\"updateRequest\").record.reach !=undefined) &&",
									"        (getRecord().reach != pm.variables.get(\"updateRequest\").record.reach) )",
									"    {",
									"    return false;",
									"    }",
									"    else if( (pm.variables.get(\"updateRequest\").record.views !=undefined) &&",
									"        (getRecord().views != pm.variables.get(\"updateRequest\").record.views) )",
									"    {",
									"        return false;",
									"    }   ",
									"    else if( (pm.variables.get(\"updateRequest\").record.shares !=undefined)  &&",
									"        (getRecord().shares != pm.variables.get(\"updateRequest\").record.shares) )",
									"    {",
									"        return false;",
									"    }",
									"    else if( (pm.variables.get(\"updateRequest\").record.totalPlayTime !=undefined)  &&",
									"        (getRecord().totalPlayTime != pm.variables.get(\"updateRequest\").record.totalPlayTime) )",
									"    {",
									"        return false;",
									"    }",
									"    else if( (pm.variables.get(\"updateRequest\").record.averageWatchTime !=undefined)  &&",
									"        (getRecord().averageWatchTime != pm.variables.get(\"updateRequest\").record.averageWatchTime) )",
									"    {",
									"        return false;",
									"    }",
									"    else",
									"    {",
									"        return true;",
									"    }    ",
									"}",
									"",
									""
								],
								"type": "text/javascript"
							}
						}
					],
					"request": {
						"method": "GET",
						"header": [],
						"url": {
							"raw": "{{test}}post/{{postIdTIKTOK}}/record?from=2014-12-31&to={{dateNow}}",
							"host": [
								"{{test}}post"
							],
							"path": [
								"{{postIdTIKTOK}}",
								"record"
							],
							"query": [
								{
									"key": "from",
									"value": "2014-12-31"
								},
								{
									"key": "to",
									"value": "{{dateNow}}"
								}
							]
						}
					},
					"response": []
				},
				{
					"name": "Revert updates",
					"event": [
						{
							"listen": "test",
							"script": {
								"exec": [
									"// will only update existing record ids",
									"// returns post and lates record even if no update was done",
									"",
									"var responseBody = pm.response.json();",
									"var requestBody = JSON.parse(pm.request.body.raw);",
									"",
									"pm.test(\"Required fields, impressions, views and reach are provided\", function(){",
									"    pm.expect(requestBody.record.impressions).to.not.equal(undefined);",
									"    pm.expect(requestBody.record.views).to.not.equal(undefined);",
									"    pm.expect(requestBody.record.reach).to.not.equal(undefined);",
									"})",
									"",
									"",
									"// response from this call only shows the lates record so need to validate with another GET call ",
									"// to make sure an update was made",
									"if(pm.response.code==200)",
									"{",
									"    //save request to be able to validate if changes were made in get call",
									"    pm.variables.set(\"updateRequest\", requestBody);",
									"",
									"    // check if all fields have been updated",
									"    // record date is not required, will update existing record and keep old date in non is given",
									"    pm.test(\"Status 200 for recordId \"+ pm.request.url.path[4])",
									"}",
									"else if(pm.response.code==400)",
									"{",
									"    //The requested record date cannot be set to before the post date or to the same record date of the last update,",
									"    //(if an update has been made previously).",
									"    // will not update if post source = OTHER",
									"    if(responseBody.notes.userMessage!=undefined)",
									"    {",
									"        pm.test(\"Status 400, userMessage: \"+ responseBody.notes.userMessage, function(){",
									"            pm.expect(responseBody.notes.userMessage).to.be.oneOf([\"Record must be after post date\",",
									"                                                            \"Post already has a record for that date\",",
									"                                                            \"Can't update automatically fetched records\",",
									"                                                            \"Views must be greater than 0\",",
									"                                                            \"Impressions must be greater than 0\",",
									"                                                            \"Reach must be greater than 0\",",
									"                                                            \"Reach cannot be higher than impressions\",",
									"                                                            \"Likes cannot be higher than reach\",",
									"                                                            \"Record platform does not match post platform\",",
									"                                                            \"Saves cannot be higher than reach\",",
									"                                                            \"Views must be greater than or equal to reach\"]);",
									"        })",
									"    }",
									"    else if(responseBody.object===null )",
									"    {",
									"        pm.test(\"Platform is required, make sure it's valid\");",
									"    }",
									"}",
									"else if(pm.response.code==404)",
									"{",
									"    pm.test(\"Post id not found\", function(){",
									"        pm.expect(responseBody.object).to.equal(null);",
									"    })",
									"",
									"}",
									"else if (pm.response.code == 403) ",
									"{",
									"    pm.test(\"Unauthorised to make call, only allowed for hypetap\");",
									"}",
									"",
									"//---------------Functions",
									""
								],
								"type": "text/javascript"
							}
						},
						{
							"listen": "prerequest",
							"script": {
								"exec": [
									"pm.environment.set(\"comments\", pm.environment.get('recordBeforeUpdate').comments)",
									"pm.environment.set(\"likes\",pm.environment.get('recordBeforeUpdate').likes)",
									"pm.environment.set(\"impressions\", pm.environment.get('recordBeforeUpdate').impressions)",
									"pm.environment.set(\"reach\", pm.environment.get('recordBeforeUpdate').reach)",
									"pm.environment.set(\"views\", pm.environment.get('recordBeforeUpdate').views)",
									"pm.environment.set(\"shares\", pm.environment.get('recordBeforeUpdate').shares)",
									"pm.environment.set(\"averageWatchTime\", pm.environment.get('recordBeforeUpdate').averageWatchTime)",
									"pm.environment.set(\"totalPlayTime\", pm.environment.get('recordBeforeUpdate').totalPlayTime)",
									"",
									"pm.environment.set(\"recordDate\",pm.environment.get('recordBeforeUpdate').dateCreated)",
									"//pm.environment.set(\"platform\", JSON.parse(pm.environment.get('platform')))",
									"",
									"",
									""
								],
								"type": "text/javascript"
							}
						}
					],
					"request": {
						"method": "PUT",
						"header": [],
						"body": {
							"mode": "raw",
							"raw": "{\n  \"record\": {\n    \"platform\": \"{{platform}}\",\n    \"comments\": {{comments}},\n    \"likes\": {{likes}},\n    \"impressions\": {{impressions}},\n    \"reach\": {{reach}},\n    \"views\": {{views}},\n    \"shares\":{{shares}},\n    \"totalPlayTime\": {{totalPlayTime}},\n    \"averageWatchTime\": {{averageWatchTime}}\n  }\n}",
							"options": {
								"raw": {
									"language": "json"
								}
							}
						},
						"url": {
							"raw": "{{test}}post/{{postIdTIKTOK}}/record/{{updateNewRecordId}}",
							"host": [
								"{{test}}post"
							],
							"path": [
								"{{postIdTIKTOK}}",
								"record",
								"{{updateNewRecordId}}"
							]
						}
					},
					"response": []
				},
				{
					"name": "Verify updates",
					"event": [
						{
							"listen": "test",
							"script": {
								"exec": [
									"var responseBody = pm.response.json();",
									"",
									"if(pm.response.code==200)",
									"{",
									"    ",
									"    if(responseBody.object.length==0)",
									"    {",
									"        pm.test(\"Status 200 no records returned\");",
									"    }",
									"    else",
									"    {        ",
									"        //if a record is found",
									"        //check if changes have been made from PUT call",
									"        if(getRecord()!=undefined)",
									"        {",
									"            pm.test(\"Update was successful\", function(){",
									"                pm.expect(updateSuccessful()).to.equal(true);",
									"            })",
									"        }",
									"        //will fail if this test is called without the collection runner",
									"        else",
									"        {",
									"            pm.test(\"No record found with given recordId from PUT call\", function(){",
									"                pm.expect(getRecord()).to.not.equal(undefined);",
									"            })",
									"",
									"        }",
									"",
									"        pm.test(\"Status 200, posts are within date range: \"+pm.request.url.query.toObject().from+\" - \"+pm.request.url.query.toObject().to, function(){",
									"            pm.expect(withinDates(pm.request.url.query.toObject().from, pm.request.url.query.toObject().to)).to.equal(true);",
									"        })",
									"    }",
									"}",
									"else if(pm.response.code==404)",
									"{",
									"    pm.test(\"Post id not found\", function(){",
									"        pm.expect(responseBody.object).to.equal(null);",
									"    })",
									"",
									"}",
									"else if (pm.response.code == 403) ",
									"{",
									"    pm.test(\"Unauthorised to make call, only allowed for hypetap\");",
									"}",
									"",
									"//-------------Functions",
									"",
									"function withinDates(from, to)",
									"{",
									"    for(let i =0; i<responseBody.object.length; ++i)",
									"    {",
									"        if(responseBody.object.dateCreated< from &&",
									"            responseBody.object.dateCreated>to)",
									"        {",
									"            return false;",
									"        }",
									"    }",
									"    return true;",
									"}",
									"",
									"//find record we're trying to update in PUT call",
									"function getRecord()",
									"{",
									"    for(let i = 0; i< responseBody.object.length; ++i)",
									"    {",
									"        if(responseBody.object[i].id == pm.variables.get(\"newRecordId\"))",
									"        {",
									"            return  responseBody.object[i];  //retun record if found",
									"        }",
									"    }",
									"}",
									"",
									"// variable \"updateRequest\" contains request from PUT call",
									"//getRecord() returns the record id, (from the response), which we tried to update in PUT call",
									"function updateSuccessful()",
									"{",
									"    //not undefined means it was given in the request",
									"    // field will be undefined in request if not given",
									"    if( (pm.variables.get(\"updateRequest\").record.likes !=undefined) &&",
									"        (getRecord().likes != pm.variables.get(\"updateRequest\").record.likes) )",
									"    {",
									"        return false;",
									"    }",
									"    else if( (pm.variables.get(\"updateRequest\").record.comments !=undefined) &&",
									"        (getRecord().comments != pm.variables.get(\"updateRequest\").record.comments) )",
									"    {",
									"        return false;",
									"    }",
									"    else if( (pm.variables.get(\"updateRequest\").record.impressions !=undefined) &&",
									"        (getRecord().impressions != pm.variables.get(\"updateRequest\").record.impressions) )",
									"    {",
									"        return false;",
									"    }    ",
									"    else if( (pm.variables.get(\"updateRequest\").record.reach !=undefined) &&",
									"        (getRecord().reach != pm.variables.get(\"updateRequest\").record.reach) )",
									"    {",
									"        return false;",
									"    }",
									"        else if( (pm.variables.get(\"updateRequest\").record.views !=undefined) &&",
									"        (getRecord().views != pm.variables.get(\"updateRequest\").record.views) )",
									"    {",
									"        return false;",
									"    }   ",
									"        else if( (pm.variables.get(\"updateRequest\").record.saves !=undefined)  &&",
									"        (getRecord().saves != pm.variables.get(\"updateRequest\").record.saves) )",
									"    {",
									"        return false;",
									"    }",
									"    else",
									"    {",
									"        return true;",
									"    }    ",
									"}",
									"",
									""
								],
								"type": "text/javascript"
							}
						}
					],
					"request": {
						"method": "GET",
						"header": [],
						"url": {
							"raw": "{{test}}post/{{postIdTIKTOK}}/record?from=2014-12-31&to={{dateNow}}",
							"host": [
								"{{test}}post"
							],
							"path": [
								"{{postIdTIKTOK}}",
								"record"
							],
							"query": [
								{
									"key": "from",
									"value": "2014-12-31"
								},
								{
									"key": "to",
									"value": "{{dateNow}}"
								}
							]
						}
					},
					"response": []
				},
				{
					"name": "Delete Record ({postId}/record/{recordId})",
					"event": [
						{
							"listen": "test",
							"script": {
								"exec": [
									"// Will not delete for a post with PostSource set to OTHER as record data is not applicable to those posts.",
									"",
									"if(pm.response.code==200)",
									"{",
									"    pm.test(\"Status 200. Deleted record with id \"+ pm.request.url.path[4]);",
									"}",
									"else if (pm.response.code == 403) ",
									"{",
									"    pm.test(\"Unauthorised to make call, only allowed for hypetap\");",
									"}"
								],
								"type": "text/javascript"
							}
						}
					],
					"request": {
						"method": "DELETE",
						"header": [],
						"body": {
							"mode": "raw",
							"raw": ""
						},
						"url": {
							"raw": "{{test}}post/{{postIdTIKTOK}}/record/{{newRecordId}}",
							"host": [
								"{{test}}post"
							],
							"path": [
								"{{postIdTIKTOK}}",
								"record",
								"{{newRecordId}}"
							]
						}
					},
					"response": []
				},
				{
					"name": "Records After (requires date range)",
					"event": [
						{
							"listen": "test",
							"script": {
								"exec": [
									"var responseBody = pm.response.json();",
									"",
									"if(pm.response.code==200)",
									"{",
									"    if(responseBody.object.length==0)",
									"    {",
									"        pm.test(\"Status 200 no records returned for postId \" + pm.request.url.path[2]);",
									"    }",
									"    else",
									"    {",
									"",
									"        pm.test(\"Status 200, for postId \" + pm.request.url.path[2]);",
									"",
									"        //both dates has to be given for call to work",
									"        pm.test(\"Records returned: \" + responseBody.object.length+ \". Records are within date range: \"+pm.request.url.query.toObject().from+\" - \"+pm.request.url.query.toObject().to, function(){",
									"            pm.expect(withinDates(pm.request.url.query.toObject().from, pm.request.url.query.toObject().to)).to.equal(true);",
									"        })",
									"",
									"        pm.test(\"Records have decrease by one, (total is same as before POST call)\", function(){",
									"            pm.expect(pm.variables.get(\"totalRecordsBefore\")).to.equal(responseBody.object.length)",
									"        })",
									"",
									"        pm.test(\"Record doesn't exist, was deleted successfuly\", function(){",
									"            pm.expect(recordExist( responseBody.object, pm.variables.get(\"newRecordId\")) ).to.equal(false);",
									"        })",
									"    }",
									"}",
									"else if(pm.response.code==404)",
									"{",
									"    pm.test(\"Post id not found\", function(){",
									"        pm.expect(responseBody.object).to.equal(null);",
									"    })",
									"",
									"}",
									"else if (pm.response.code == 403) ",
									"{",
									"    pm.test(\"Unauthorised to make call, only allowed for hypetap\");",
									"}",
									"",
									"//-------------Functions",
									"",
									"function withinDates(from, to)",
									"{",
									"    for(let i =0; i<responseBody.object.length; ++i)",
									"    {",
									"        if( (new Date(responseBody.object[i].dateCreated).getTime()< new Date(from).getTime() ) &&",
									"            ( new Date(responseBody.object[i].dateCreated).getTime() >new Date(to).getTime() ) )",
									"        {",
									"            return false;",
									"        }",
									"    }",
									"    return true;",
									"",
									"}",
									"// checks if the new record, (from reuest in POST call), exist and if the data match",
									"function recordExist(list, recordId)",
									"{",
									"    for(let i=0; i<list.length; ++i)",
									"    {",
									"        ",
									"        if(recordId==list[i].id)",
									"        {",
									"            return true;",
									"        }",
									"",
									"    }",
									"    return false;    //record not found",
									"}"
								],
								"type": "text/javascript"
							}
						}
					],
					"request": {
						"method": "GET",
						"header": [],
						"url": {
							"raw": "{{test}}post/{{postIdTIKTOK}}/record?from=2014-12-31&to={{dateNow}}",
							"host": [
								"{{test}}post"
							],
							"path": [
								"{{postIdTIKTOK}}",
								"record"
							],
							"query": [
								{
									"key": "from",
									"value": "2014-12-31"
								},
								{
									"key": "to",
									"value": "{{dateNow}}",
									"description": "set in pre test script of current folder"
								}
							]
						}
					},
					"response": []
				}
			],
			"event": [
				{
					"listen": "prerequest",
					"script": {
						"type": "text/javascript",
						"exec": [
							"//sets variable \"dateNow\"  with current date",
							"//GET records requires a date range",
							"month = '' + (new Date().getMonth() + 1)",
							"if(month.length<2 )",
							"{",
							"    month='0'+month;",
							"}",
							"",
							"if(new Date().getDate().length<2 )",
							"{",
							"    day='0'+new Date().getDate();",
							"}",
							"else ",
							"{",
							"    day=new Date().getDate();",
							"}",
							"",
							"date = [ new Date().getFullYear(), month, day].join('-');",
							"",
							"pm.variables.set(\"dateNow\", date);"
						]
					}
				},
				{
					"listen": "test",
					"script": {
						"type": "text/javascript",
						"exec": [
							""
						]
					}
				}
			]
		},
		{
			"name": "NEG TIKTOK - Create, Update and Delete Record",
			"item": [
				{
					"name": "BOSS login",
					"event": [
						{
							"listen": "test",
							"script": {
								"exec": [
									"pm.test(\"Status code is 200\", function () {",
									"    pm.response.to.have.status(200);",
									"});",
									""
								],
								"type": "text/javascript"
							}
						}
					],
					"request": {
						"method": "POST",
						"header": [
							{
								"warning": "This is a duplicate header and will be overridden by the Content-Type header generated by Postman.",
								"key": "Content-Type",
								"value": "application/x-www-form-urlencoded",
								"type": "text"
							}
						],
						"body": {
							"mode": "urlencoded",
							"urlencoded": [
								{
									"key": "username",
									"value": "dumbanddummy1+brooke@gmail.com",
									"description": "dumbanddummy1+brooke@gmail.com",
									"type": "text"
								},
								{
									"key": "password",
									"value": "hypetap1",
									"type": "text"
								},
								{
									"key": "remember-me",
									"value": "true",
									"type": "text"
								}
							]
						},
						"url": {
							"raw": "{{test}}login",
							"host": [
								"{{test}}login"
							]
						}
					},
					"response": []
				},
				{
					"name": "Records Before (requires date range)",
					"event": [
						{
							"listen": "test",
							"script": {
								"exec": [
									"var responseBody = pm.response.json();",
									"",
									"if(pm.response.code==200)",
									"{",
									"    if(responseBody.object.length==0)",
									"    {",
									"        pm.test(\"Status 200 no records returned for postId \" + pm.request.url.path[2]);",
									"    }",
									"    else",
									"    {",
									"        //saves number of records returned to be able to check if number has increased after POST, (add new record) call",
									"        pm.variables.set(\"totalRecordsBefore\", responseBody.object.length);",
									"",
									"        pm.test(\"Status 200, for postId \" + pm.request.url.path[2]);",
									"",
									"        //both dates has to be given for call to work",
									"        pm.test(\"Records returned: \" + responseBody.object.length+ \". Records are within date range: \"+pm.request.url.query.toObject().from+\" - \"+pm.request.url.query.toObject().to, function(){",
									"            pm.expect(withinDates(pm.request.url.query.toObject().from, pm.request.url.query.toObject().to)).to.equal(true);",
									"        })",
									"",
									"    }",
									"}",
									"else if(pm.response.code==404)",
									"{",
									"    pm.test(\"Post id not found\", function(){",
									"        pm.expect(responseBody.object).to.equal(null);",
									"    })",
									"",
									"}",
									"else if (pm.response.code == 403) ",
									"{",
									"    pm.test(\"Unauthorised to make call, only allowed for hypetap\");",
									"}",
									"",
									"//-------------Functions",
									"",
									"function withinDates(from, to)",
									"{",
									"    for(let i =0; i<responseBody.object.length; ++i)",
									"    {",
									"        if( (new Date(responseBody.object[i].dateCreated).getTime()< new Date(from).getTime() ) &&",
									"            ( new Date(responseBody.object[i].dateCreated).getTime() >new Date(to).getTime() ) )",
									"        {",
									"            return false;",
									"        }",
									"    }",
									"    return true;",
									"",
									"}",
									""
								],
								"type": "text/javascript"
							}
						}
					],
					"request": {
						"method": "GET",
						"header": [],
						"url": {
							"raw": "{{test}}post/{{postIdTIKTOK}}/record?from=2014-12-31&to={{dateNow}}",
							"host": [
								"{{test}}post"
							],
							"path": [
								"{{postIdTIKTOK}}",
								"record"
							],
							"query": [
								{
									"key": "from",
									"value": "2014-12-31"
								},
								{
									"key": "to",
									"value": "{{dateNow}}",
									"description": "set in pre test script of current folder"
								}
							]
						}
					},
					"response": []
				},
				{
					"name": "Create Record ({postId}/record)",
					"event": [
						{
							"listen": "test",
							"script": {
								"exec": [
									"var responseBody = pm.response.json();",
									"var requestBody = JSON.parse(pm.request.body.raw);",
									"",
									"//runns regardless of status",
									"pm.test(\"Required fields, impressions, views, reach and recordDate are provided\", function(){",
									"    pm.expect(requestBody.record.impressions).to.not.equal(undefined);",
									"    pm.expect(requestBody.record.views).to.not.equal(undefined);",
									"    pm.expect(requestBody.record.reach).to.not.equal(undefined);",
									"    pm.expect(requestBody.recordDate).to.not.equal(undefined);",
									"})",
									"",
									"if(pm.response.code==200)",
									"{",
									"    //save request to be ale to confirm that it was added with the correct data. ",
									"    //records are not allowed to be for the same date, so date is unique",
									"    pm.variables.set(\"newRecord\", requestBody);",
									"",
									"    pm.test(\"Status 200. Returns post corresponding to given postId \"+ pm.request.url.path[2], function(){",
									"        pm.expect( pm.request.url.path[2]).to.equal(responseBody.object.id);",
									"    })",
									"",
									"    //the new record has to be after the post date",
									"    //need to convert dates to be able to compare since they are of the type string",
									"    pm.test(\"The new record is after post date. The date of added record \" + requestBody.recordDate, function(){",
									"        pm.expect(new Date(requestBody.recordDate).getTime()> new Date(responseBody.object.datePosted).getTime() ).to.equal(true);",
									"    })",
									"",
									"}",
									"else if(pm.response.code==400)",
									"{",
									"    //The requested record date cannot be set to before the post date or to the same record date of the last update,",
									"    //(if an update has been made previously).",
									"    // will not update if post source = OTHER",
									"    if(responseBody.notes.userMessage!=undefined)",
									"    {",
									"        pm.test(\"Status 400, userMessage: \"+ responseBody.notes.userMessage, function(){",
									"            pm.expect(responseBody.notes.userMessage).to.be.oneOf([",
									"                                                            \"Cannot update posts fetched via APIs\",",
									"                                                            \"A record must have a date\",",
									"                                                            \"Record must be after post date\",",
									"                                                            \"Post already has a record for that date\",",
									"                                                            \"Can't update automatically fetched records\",",
									"                                                            \"Views must be greater than 0\",",
									"                                                            \"Impressions must be greater than 0\",",
									"                                                            \"Reach must be greater than 0\",",
									"                                                            \"Reach cannot be higher than impressions\",",
									"                                                            \"Likes cannot be higher than reach\",",
									"                                                            \"Record platform does not match post platform\",",
									"                                                            \"Saves cannot be higher than reach\",",
									"                                                            \"Views must equal impressions\",",
									"                                                            \"Views must be greater than or equal to reach\"]);",
									"        })",
									"    }",
									"    else if(responseBody.object===null )",
									"    {",
									"        pm.test(\"Platform is required, make sure it's valid\");",
									"    }",
									"}",
									"else if (pm.response.code == 403) ",
									"{",
									"    pm.test(\"Unauthorised to make call, only allowed for hypetap\");",
									"}",
									"",
									"//---------------Functions",
									""
								],
								"type": "text/javascript"
							}
						}
					],
					"request": {
						"method": "POST",
						"header": [],
						"body": {
							"mode": "raw",
							"raw": "{\n  \"record\": {\n    \"platform\": \"TIKTOK\",\n    \"comments\": 100,\n    \"impressions\": 15600000,\n    \"reach\": 15800000,\n    \"views\":15800000,\n    \"shares\": 100,\n    \"likes\": 100,\n    \"totalPlayTime\": 100,\n    \"averageWatchTime\": 100\n  },\n  \"recordDate\": \"2021-09-21\"\n}",
							"options": {
								"raw": {
									"language": "json"
								}
							}
						},
						"url": {
							"raw": "{{test}}post/{{postIdTIKTOK}}/record",
							"host": [
								"{{test}}post"
							],
							"path": [
								"{{postIdTIKTOK}}",
								"record"
							]
						}
					},
					"response": []
				},
				{
					"name": "Records After (requires date range)",
					"event": [
						{
							"listen": "test",
							"script": {
								"exec": [
									"var responseBody = pm.response.json();",
									"",
									"if(pm.response.code==200)",
									"{",
									"    if(responseBody.object.length==0)",
									"    {",
									"        pm.test(\"Status 200 no records returned for postId \" + pm.request.url.path[2]);",
									"    }",
									"    else",
									"    {",
									"",
									"        pm.test(\"Status 200, for postId \" + pm.request.url.path[2]);",
									"",
									"        //both dates has to be given for call to work",
									"        pm.test(\"Records returned: \" + responseBody.object.length+ \". Records are within date range: \"+pm.request.url.query.toObject().from+\" - \"+pm.request.url.query.toObject().to, function(){",
									"            pm.expect(withinDates(pm.request.url.query.toObject().from, pm.request.url.query.toObject().to)).to.equal(true);",
									"        })",
									"",
									"        pm.test(\"Records not have increase\", function(){",
									"            pm.expect(pm.variables.get(\"totalRecordsBefore\")).to.equal(responseBody.object.length)",
									"        })",
									"",
									"    }",
									"}",
									"else if(pm.response.code==404)",
									"{",
									"    pm.test(\"Post id not found\", function(){",
									"        pm.expect(responseBody.object).to.equal(null);",
									"    })",
									"",
									"}",
									"else if (pm.response.code == 403) ",
									"{",
									"    pm.test(\"Unauthorised to make call, only allowed for hypetap\");",
									"}",
									"",
									"//-------------Functions",
									"",
									"function withinDates(from, to)",
									"{",
									"    for(let i =0; i<responseBody.object.length; ++i)",
									"    {",
									"        if( (new Date(responseBody.object[i].dateCreated).getTime()< new Date(from).getTime() ) &&",
									"            ( new Date(responseBody.object[i].dateCreated).getTime() >new Date(to).getTime() ) )",
									"        {",
									"            return false;",
									"        }",
									"    }",
									"    return true;",
									"",
									"}",
									"// checks if the new record, (from reuest in POST call), exist and if the data match",
									"function validateNewRecord(list, record)",
									"{",
									"    count=0;",
									"    for(let i=0; i<list.length; ++i)",
									"    {",
									"        //generate new dates to be able to convert string to date format",
									"        //if they are equal then it's the same record. Only one record can exist for one date",
									"        if(new Date(list[i].dateCreated).getTime() === new Date(record.recordDate).getTime())",
									"        {",
									"           pm.environment.set(\"recordBeforeUpdate\",list[i]);",
									"            //saves id to be able to delete record ",
									"            pm.variables.set(\"newRecordId\", list[i].id);",
									"",
									"            count+= 1;",
									"            //if likes is given and it's not the same value as response then return false, data doesn't match",
									"            if( (record.record.likes!=undefined) && (record.record.likes!=list[i].likes) )",
									"            {",
									"                return false;",
									"            }",
									"            else if( (record.record.comments!=undefined) && (record.record.comments!=list[i].comments) )",
									"            {",
									"                return false;",
									"            }",
									"            else if( (record.record.impressions!=undefined) && (record.record.impressions!=list[i].impressions) )",
									"            {",
									"                return false;",
									"            }",
									"            else if( (record.record.reach!=undefined) && (record.record.reach!=list[i].reach) )",
									"            {",
									"                return false;",
									"            }",
									"            else if( (record.record.views!=undefined) && (record.record.views!=list[i].views) )",
									"            {",
									"                return false;",
									"            } ",
									"            else if( (record.record.shares!=undefined) && (record.record.shares!=list[i].shares) )",
									"            {",
									"                return false;",
									"            }",
									"            else if( (record.record.totalPlayTime!=undefined) && (record.record.totalPlayTime!=list[i].totalPlayTime) )",
									"            {",
									"                return false;",
									"            }",
									"            else if( (record.record.averageWatchTime!=undefined) && (record.record.averageWatchTime!=list[i].averageWatchTime) )",
									"            {",
									"                return false;",
									"            }            ",
									"        }",
									"    }",
									"    //count will increase by one if function finds the new record date in the returned list",
									"    //function will return false if record is not found, (count==0) ",
									"    if(count>0)",
									"    {",
									"        return true;    //record exist and all fields match",
									"    }",
									"    return false;    //record not found",
									"}"
								],
								"type": "text/javascript"
							}
						}
					],
					"request": {
						"method": "GET",
						"header": [],
						"url": {
							"raw": "{{test}}post/{{postIdTIKTOK}}/record?from=2014-12-31&to={{dateNow}}",
							"host": [
								"{{test}}post"
							],
							"path": [
								"{{postIdTIKTOK}}",
								"record"
							],
							"query": [
								{
									"key": "from",
									"value": "2014-12-31"
								},
								{
									"key": "to",
									"value": "{{dateNow}}",
									"description": "set in pre test script of current folder"
								}
							]
						}
					},
					"response": []
				}
			],
			"event": [
				{
					"listen": "prerequest",
					"script": {
						"type": "text/javascript",
						"exec": [
							"//sets variable \"dateNow\"  with current date",
							"//GET records requires a date range",
							"month = '' + (new Date().getMonth() + 1)",
							"if(month.length<2 )",
							"{",
							"    month='0'+month;",
							"}",
							"",
							"if(new Date().getDate().length<2 )",
							"{",
							"    day='0'+new Date().getDate();",
							"}",
							"else ",
							"{",
							"    day=new Date().getDate();",
							"}",
							"",
							"date = [ new Date().getFullYear(), month, day].join('-');",
							"",
							"pm.variables.set(\"dateNow\", date);"
						]
					}
				},
				{
					"listen": "test",
					"script": {
						"type": "text/javascript",
						"exec": [
							""
						]
					}
				}
			]
		},
		{
			"name": "Update AUTO_DETECTED",
			"item": [
				{
					"name": "BOSS login",
					"event": [
						{
							"listen": "test",
							"script": {
								"exec": [
									"pm.test(\"Status code is 200\", function () {",
									"    pm.response.to.have.status(200);",
									"});"
								],
								"type": "text/javascript"
							}
						}
					],
					"request": {
						"method": "POST",
						"header": [
							{
								"warning": "This is a duplicate header and will be overridden by the Content-Type header generated by Postman.",
								"key": "Content-Type",
								"value": "application/x-www-form-urlencoded",
								"type": "text"
							}
						],
						"body": {
							"mode": "urlencoded",
							"urlencoded": [
								{
									"key": "username",
									"value": "dumbanddummy1+brooke@gmail.com",
									"description": "dumbanddummy1+brooke@gmail.com",
									"type": "text"
								},
								{
									"key": "password",
									"value": "hypetap1",
									"type": "text"
								},
								{
									"key": "remember-me",
									"value": "true",
									"type": "text"
								}
							]
						},
						"url": {
							"raw": "{{test}}login",
							"host": [
								"{{test}}login"
							]
						}
					},
					"response": []
				},
				{
					"name": "Record exists (save original)",
					"event": [
						{
							"listen": "test",
							"script": {
								"exec": [
									"var responseBody = pm.response.json();",
									"",
									"if(pm.response.code==200)",
									"{",
									"    ",
									"    if(responseBody.object.length==0)",
									"    {",
									"        pm.test(\"Status 200 no records returned\");",
									"    }",
									"    else",
									"    {        ",
									"        //if a record is found",
									"        //check if changes have been made from PUT call",
									"        if(getRecord()!=undefined)",
									"        {",
									"            pm.environment.set(\"originalRecord\", JSON.stringify(getRecord()));",
									"",
									"            pm.test(\"Record corresponding to given recordId have been found and saved\");",
									"        }",
									"        //will fail if this test is called without the collection runner",
									"        else",
									"        {",
									"            pm.test(\"No record found with given recordId from collection variables\", function(){",
									"                pm.expect(getRecord()).to.not.equal(undefined);",
									"            })",
									"",
									"        }",
									"",
									"        pm.test(\"Status 200, posts are within date range: \"+pm.request.url.query.toObject().from+\" - \"+pm.request.url.query.toObject().to, function(){",
									"            pm.expect(withinDates(pm.request.url.query.toObject().from, pm.request.url.query.toObject().to)).to.equal(true);",
									"        })",
									"    }",
									"}",
									"else if(pm.response.code==404)",
									"{",
									"    pm.test(\"Post id not found\", function(){",
									"        pm.expect(responseBody.object).to.equal(null);",
									"    })",
									"",
									"}",
									"else if (pm.response.code == 403) ",
									"{",
									"    pm.test(\"Unauthorised to make call, only allowed for hypetap\");",
									"}",
									"",
									"//-------------Functions",
									"",
									"function withinDates(from, to)",
									"{",
									"    for(let i =0; i<responseBody.object.length; ++i)",
									"    {",
									"        if(responseBody.object.dateCreated< from &&",
									"            responseBody.object.dateCreated>to)",
									"        {",
									"            return false;",
									"        }",
									"    }",
									"    return true;",
									"}",
									"",
									"//find record we're trying to update in PUT call",
									"function getRecord()",
									"{",
									"    record={};",
									"    for(let i = 0; i< responseBody.object.length; ++i)",
									"    {",
									"        if(responseBody.object[i].id == pm.variables.get(\"updateRecordId\"))",
									"        {",
									"            return responseBody.object[i];",
									"        }",
									"    }",
									"}",
									""
								],
								"type": "text/javascript"
							}
						}
					],
					"request": {
						"method": "GET",
						"header": [],
						"url": {
							"raw": "{{test}}post/611b5ef1416a8f754181fb0f/record?from=2020-12-30&to=2021-09-08",
							"host": [
								"{{test}}post"
							],
							"path": [
								"611b5ef1416a8f754181fb0f",
								"record"
							],
							"query": [
								{
									"key": "from",
									"value": "2020-12-30"
								},
								{
									"key": "to",
									"value": "2021-09-08"
								}
							]
						}
					},
					"response": []
				},
				{
					"name": "Update recordId",
					"event": [
						{
							"listen": "test",
							"script": {
								"exec": [
									"// will only update existing record ids",
									"// returns post and lates record even if no update was done",
									"",
									"var responseBody = pm.response.json();",
									"var requestBody = JSON.parse(pm.request.body.raw);",
									"",
									"//runns regardless of status",
									"pm.test(\"Required fields, impressions, views and reach are provided\", function(){",
									"    pm.expect(requestBody.record.impressions).to.not.equal(undefined);",
									"    pm.expect(requestBody.record.views).to.not.equal(undefined);",
									"    pm.expect(requestBody.record.reach).to.not.equal(undefined);",
									"})",
									"",
									"",
									"//save request to be able to validate if changes were made in get call",
									"pm.variables.set(\"updateRequest\", requestBody);",
									"",
									"// response from this call only shows the lates record so need to validate with another GET call ",
									"// to make sure an update was made",
									"if(pm.response.code==200)",
									"{",
									"",
									"    //platform is not returned in get calls",
									"    //saving it from the request here so that it can be used in the revert PUT call",
									"    pm.environment.set(\"platform\", requestBody.record.platform);",
									"",
									"",
									"    // check if all fields have been updated",
									"    // record date is not required, will update existing record and keep old date in non is given",
									"    pm.test(\"Status 200 for recordId \"+ pm.request.url.path[4])",
									"}",
									"else if(pm.response.code==400)",
									"{",
									"    //The requested record date cannot be set to before the post date or to the same record date of the last update,",
									"    //(if an update has been made previously).",
									"    // will not update if post source = OTHER",
									"    if(responseBody.notes.userMessage!=undefined)",
									"    {",
									"        pm.test(\"Status 400, userMessage: \"+ responseBody.notes.userMessage, function(){",
									"            pm.expect(responseBody.notes.userMessage).to.be.oneOf([\"Record must be after post date\",",
									"                                                            \"Post already has a record for that date\",",
									"                                                            \"Can't update automatically fetched records\",",
									"                                                            \"Views must be greater than 0\",",
									"                                                            \"Impressions must be greater than 0\",",
									"                                                            \"Reach must be greater than 0\",",
									"                                                            \"Reach cannot be higher than impressions\",",
									"                                                            \"Likes cannot be higher than reach\",",
									"                                                            \"Record platform does not match post platform\",",
									"                                                            \"Saves cannot be higher than reach\",",
									"                                                            \"Views must be greater than or equal to reach\"]);",
									"        })",
									"    }",
									"    else if(responseBody.object===null )",
									"    {",
									"        pm.test(\"Platform is required, make sure it's valid\");",
									"    }",
									"}",
									"else if(pm.response.code==404)",
									"{",
									"    pm.test(\"Post id not found\", function(){",
									"        pm.expect(responseBody.object).to.equal(null);",
									"    })",
									"",
									"}",
									"else if (pm.response.code == 403) ",
									"{",
									"    pm.test(\"Unauthorised to make call, only allowed for hypetap\");",
									"}",
									"",
									"//---------------Functions",
									"",
									"function updateSuccessful()",
									"{",
									"    //not undefined means it was given in the request",
									"    if( (requestBody.record.likes !=undefined) &&",
									"        (responseBody.object.latestRecord.likes != requestBody.record.likes) )",
									"    {",
									"        return false;",
									"    }",
									"    else if( (requestBody.record.comments !=undefined) &&",
									"        (responseBody.object.latestRecord.comments != requestBody.record.comments) )",
									"    {",
									"        return false;",
									"    }",
									"    else if( (requestBody.record.impressions !=undefined) &&",
									"        (responseBody.object.latestRecord.impressions != requestBody.record.impressions) )",
									"    {",
									"        return false;",
									"    }    ",
									"    else if( (requestBody.record.reach !=undefined) &&",
									"        (responseBody.object.latestRecord.reach != requestBody.record.reach) )",
									"    {",
									"        return false;",
									"    }",
									"        else if( (requestBody.record.views !=undefined) &&",
									"        (responseBody.object.latestRecord.views != requestBody.record.views) )",
									"    {",
									"        return false;",
									"    }   ",
									"        else if( (requestBody.record.saves !=undefined)  &&",
									"        (responseBody.object.latestRecord.saves != requestBody.record.saves) )",
									"    {",
									"        return false;",
									"    }",
									"    else",
									"    {",
									"        return true;",
									"    }    ",
									"}",
									"",
									""
								],
								"type": "text/javascript"
							}
						}
					],
					"request": {
						"method": "PUT",
						"header": [],
						"body": {
							"mode": "raw",
							"raw": "{\n  \"record\": {\n    \"platform\": \"INSTAGRAM\",\n    \"comments\": \"\",\n    \"likes\": 400,\n    \"impressions\": 400,\n    \"reach\": 400,\n    \"views\": 400,\n    \"saves\":0\n  },\n   \"recordDate\": \"2021-08-16\"\n}",
							"options": {
								"raw": {
									"language": "json"
								}
							}
						},
						"url": {
							"raw": "{{test}}post/611b5ef1416a8f754181fb0f/record/{{updateRecordId}}",
							"host": [
								"{{test}}post"
							],
							"path": [
								"611b5ef1416a8f754181fb0f",
								"record",
								"{{updateRecordId}}"
							]
						},
						"description": "recordDate is only needed if the date is to be altered for given recordId"
					},
					"response": []
				},
				{
					"name": "Verify updates",
					"event": [
						{
							"listen": "test",
							"script": {
								"exec": [
									"var responseBody = pm.response.json();",
									"",
									"if(pm.response.code==200)",
									"{",
									"    ",
									"    if(responseBody.object.length==0)",
									"    {",
									"        pm.test(\"Status 200 no records returned\");",
									"    }",
									"    else",
									"    {        ",
									"        //if a record is found",
									"        //check if changes have been made from PUT call",
									"        if(getRecord()!=undefined)",
									"        {",
									"            pm.test(\"Update was successful\", function(){",
									"                pm.expect(updateSuccessful()).to.equal(true);",
									"            })",
									"        }",
									"        //will fail if this test is called without the collection runner",
									"        else",
									"        {",
									"            pm.test(\"No record found with given recordId from PUT call\", function(){",
									"                pm.expect(getRecord()).to.not.equal(undefined);",
									"            })",
									"",
									"        }",
									"",
									"        pm.test(\"Status 200, posts are within date range: \"+pm.request.url.query.toObject().from+\" - \"+pm.request.url.query.toObject().to, function(){",
									"            pm.expect(withinDates(pm.request.url.query.toObject().from, pm.request.url.query.toObject().to)).to.equal(true);",
									"        })",
									"    }",
									"}",
									"else if(pm.response.code==404)",
									"{",
									"    pm.test(\"Post id not found\", function(){",
									"        pm.expect(responseBody.object).to.equal(null);",
									"    })",
									"",
									"}",
									"else if (pm.response.code == 403) ",
									"{",
									"    pm.test(\"Unauthorised to make call, only allowed for hypetap\");",
									"}",
									"",
									"//-------------Functions",
									"",
									"function withinDates(from, to)",
									"{",
									"    for(let i =0; i<responseBody.object.length; ++i)",
									"    {",
									"        if(responseBody.object.dateCreated< from &&",
									"            responseBody.object.dateCreated>to)",
									"        {",
									"            return false;",
									"        }",
									"    }",
									"    return true;",
									"}",
									"",
									"//find record we're trying to update in PUT call",
									"function getRecord()",
									"{",
									"    for(let i = 0; i< responseBody.object.length; ++i)",
									"    {",
									"        if(responseBody.object[i].id == pm.variables.get(\"updateRecordId\"))",
									"        {",
									"            return  responseBody.object[i];  //retun record if found",
									"        }",
									"    }",
									"}",
									"",
									"// variable \"updateRequest\" contains request from PUT call",
									"//getRecord() returns the record id, (from the response), which we tried to update in PUT call",
									"function updateSuccessful()",
									"{",
									"    //not undefined means it was given in the request",
									"    // field will be undefined in request if not given",
									"    if( (pm.variables.get(\"updateRequest\").record.likes !=undefined) &&",
									"        (getRecord().likes != pm.variables.get(\"updateRequest\").record.likes) )",
									"    {",
									"        return false;",
									"    }",
									"    else if( (pm.variables.get(\"updateRequest\").record.comments !=undefined) &&",
									"        (getRecord().comments != pm.variables.get(\"updateRequest\").record.comments) )",
									"    {",
									"        return false;",
									"    }",
									"    else if( (pm.variables.get(\"updateRequest\").record.impressions !=undefined) &&",
									"        (getRecord().impressions != pm.variables.get(\"updateRequest\").record.impressions) )",
									"    {",
									"        return false;",
									"    }    ",
									"    else if( (pm.variables.get(\"updateRequest\").record.reach !=undefined) &&",
									"        (getRecord().reach != pm.variables.get(\"updateRequest\").record.reach) )",
									"    {",
									"        return false;",
									"    }",
									"        else if( (pm.variables.get(\"updateRequest\").record.views !=undefined) &&",
									"        (getRecord().views != pm.variables.get(\"updateRequest\").record.views) )",
									"    {",
									"        return false;",
									"    }   ",
									"        else if( (pm.variables.get(\"updateRequest\").record.saves !=undefined)  &&",
									"        (getRecord().saves != pm.variables.get(\"updateRequest\").record.saves) )",
									"    {",
									"        return false;",
									"    }",
									"    else",
									"    {",
									"        return true;",
									"    }    ",
									"}",
									"",
									""
								],
								"type": "text/javascript"
							}
						}
					],
					"request": {
						"method": "GET",
						"header": [],
						"url": {
							"raw": "{{test}}post/611b5ef1416a8f754181fb0f/record?from=2020-12-30&to=2021-09-08",
							"host": [
								"{{test}}post"
							],
							"path": [
								"611b5ef1416a8f754181fb0f",
								"record"
							],
							"query": [
								{
									"key": "from",
									"value": "2020-12-30"
								},
								{
									"key": "to",
									"value": "2021-09-08"
								}
							]
						}
					},
					"response": []
				},
				{
					"name": "Revert updates",
					"event": [
						{
							"listen": "test",
							"script": {
								"exec": [
									"// will only update existing record ids",
									"// returns post and lates record even if no update was done",
									"",
									"var responseBody = pm.response.json();",
									"var requestBody = JSON.parse(pm.request.body.raw);",
									"",
									"//runns regardless of status",
									"pm.test(\"Required fields, impressions, views and reach are provided\", function(){",
									"    pm.expect(requestBody.record.impressions).to.not.equal(undefined);",
									"    pm.expect(requestBody.record.views).to.not.equal(undefined);",
									"    pm.expect(requestBody.record.reach).to.not.equal(undefined);",
									"})",
									"",
									"// response from this call only shows the lates record so need to validate with another GET call ",
									"// to make sure an update was made",
									"if(pm.response.code==200)",
									"{",
									"    //save request to be able to validate if changes were made in get call",
									"    pm.variables.set(\"updateRequest\", requestBody);",
									"",
									"    // check if all fields have been updated",
									"    // record date is not required, will update existing record and keep old date in non is given",
									"    pm.test(\"Status 200 for recordId \"+ pm.request.url.path[4])",
									"}",
									"else if(pm.response.code==400)",
									"{",
									"    //The requested record date cannot be set to before the post date or to the same record date of the last update,",
									"    //(if an update has been made previously).",
									"    // will not update if post source = OTHER",
									"    if(responseBody.notes.userMessage!=undefined)",
									"    {",
									"        pm.test(\"Status 400, userMessage: \"+ responseBody.notes.userMessage, function(){",
									"            pm.expect(responseBody.notes.userMessage).to.be.oneOf([\"Record must be after post date\",",
									"                                                            \"Post already has a record for that date\",",
									"                                                            \"Can't update automatically fetched records\",",
									"                                                            \"Views must be greater than 0\",",
									"                                                            \"Impressions must be greater than 0\",",
									"                                                            \"Reach must be greater than 0\",",
									"                                                            \"Reach cannot be higher than impressions\",",
									"                                                            \"Likes cannot be higher than reach\",",
									"                                                            \"Record platform does not match post platform\",",
									"                                                            \"Saves cannot be higher than reach\",",
									"                                                            \"Views must be greater than or equal to reach\"]);",
									"        })",
									"    }",
									"    else if(responseBody.object===null )",
									"    {",
									"        pm.test(\"Platform is required, make sure it's valid\");",
									"    }",
									"}",
									"else if(pm.response.code==404)",
									"{",
									"    pm.test(\"Post id not found\", function(){",
									"        pm.expect(responseBody.object).to.equal(null);",
									"    })",
									"",
									"}",
									"else if (pm.response.code == 403) ",
									"{",
									"    pm.test(\"Unauthorised to make call, only allowed for hypetap\");",
									"}",
									"",
									"//---------------Functions",
									""
								],
								"type": "text/javascript"
							}
						},
						{
							"listen": "prerequest",
							"script": {
								"exec": [
									"pm.environment.set(\"comments\", JSON.parse(pm.environment.get('originalRecord')).comments)",
									"pm.environment.set(\"likes\", JSON.parse(pm.environment.get('originalRecord')).likes)",
									"pm.environment.set(\"impressions\", JSON.parse(pm.environment.get('originalRecord')).impressions)",
									"pm.environment.set(\"reach\", JSON.parse(pm.environment.get('originalRecord')).reach)",
									"pm.environment.set(\"views\", JSON.parse(pm.environment.get('originalRecord')).views)",
									"pm.environment.set(\"saves\", JSON.parse(pm.environment.get('originalRecord')).saves)",
									"",
									"pm.environment.set(\"recordDate\", JSON.parse(pm.environment.get('originalRecord')).dateCreated)",
									"//pm.environment.set(\"platform\", JSON.parse(pm.environment.get('platform')))",
									"",
									"",
									""
								],
								"type": "text/javascript"
							}
						}
					],
					"request": {
						"method": "PUT",
						"header": [],
						"body": {
							"mode": "raw",
							"raw": "{\n  \"record\": {\n    \"platform\": \"{{platform}}\",\n    \"comments\": {{comments}},\n    \"likes\": {{likes}},\n    \"impressions\": {{impressions}},\n    \"reach\": {{reach}},\n    \"views\": {{views}},\n    \"saves\":{{saves}}\n  },\n    \"recordDate\": \"{{recordDate}}\"\n}",
							"options": {
								"raw": {
									"language": "json"
								}
							}
						},
						"url": {
							"raw": "{{test}}post/611b5ef1416a8f754181fb0f/record/{{updateRecordId}}",
							"host": [
								"{{test}}post"
							],
							"path": [
								"611b5ef1416a8f754181fb0f",
								"record",
								"{{updateRecordId}}"
							]
						}
					},
					"response": []
				},
				{
					"name": "Verify updates",
					"event": [
						{
							"listen": "test",
							"script": {
								"exec": [
									"var responseBody = pm.response.json();",
									"",
									"if(pm.response.code==200)",
									"{",
									"    ",
									"    if(responseBody.object.length==0)",
									"    {",
									"        pm.test(\"Status 200 no records returned\");",
									"    }",
									"    else",
									"    {        ",
									"        //if a record is found",
									"        //check if changes have been made from PUT call",
									"        if(getRecord()!=undefined)",
									"        {",
									"            pm.test(\"Update was successful\", function(){",
									"                pm.expect(updateSuccessful()).to.equal(true);",
									"            })",
									"        }",
									"        //will fail if this test is called without the collection runner",
									"        else",
									"        {",
									"            pm.test(\"No record found with given recordId from PUT call\", function(){",
									"                pm.expect(getRecord()).to.not.equal(undefined);",
									"            })",
									"",
									"        }",
									"",
									"        pm.test(\"Status 200, posts are within date range: \"+pm.request.url.query.toObject().from+\" - \"+pm.request.url.query.toObject().to, function(){",
									"            pm.expect(withinDates(pm.request.url.query.toObject().from, pm.request.url.query.toObject().to)).to.equal(true);",
									"        })",
									"    }",
									"}",
									"else if(pm.response.code==404)",
									"{",
									"    pm.test(\"Post id not found\", function(){",
									"        pm.expect(responseBody.object).to.equal(null);",
									"    })",
									"",
									"}",
									"else if (pm.response.code == 403) ",
									"{",
									"    pm.test(\"Unauthorised to make call, only allowed for hypetap\");",
									"}",
									"",
									"//-------------Functions",
									"",
									"function withinDates(from, to)",
									"{",
									"    for(let i =0; i<responseBody.object.length; ++i)",
									"    {",
									"        if(responseBody.object.dateCreated< from &&",
									"            responseBody.object.dateCreated>to)",
									"        {",
									"            return false;",
									"        }",
									"    }",
									"    return true;",
									"}",
									"",
									"//find record we're trying to update in PUT call",
									"function getRecord()",
									"{",
									"    for(let i = 0; i< responseBody.object.length; ++i)",
									"    {",
									"        if(responseBody.object[i].id == pm.variables.get(\"updateRecordId\"))",
									"        {",
									"            return  responseBody.object[i];  //retun record if found",
									"        }",
									"    }",
									"}",
									"",
									"// variable \"updateRequest\" contains request from PUT call",
									"//getRecord() returns the record id, (from the response), which we tried to update in PUT call",
									"function updateSuccessful()",
									"{",
									"    //not undefined means it was given in the request",
									"    // field will be undefined in request if not given",
									"    if( (pm.variables.get(\"updateRequest\").record.likes !=undefined) &&",
									"        (getRecord().likes != pm.variables.get(\"updateRequest\").record.likes) )",
									"    {",
									"        return false;",
									"    }",
									"    else if( (pm.variables.get(\"updateRequest\").record.comments !=undefined) &&",
									"        (getRecord().comments != pm.variables.get(\"updateRequest\").record.comments) )",
									"    {",
									"        return false;",
									"    }",
									"    else if( (pm.variables.get(\"updateRequest\").record.impressions !=undefined) &&",
									"        (getRecord().impressions != pm.variables.get(\"updateRequest\").record.impressions) )",
									"    {",
									"        return false;",
									"    }    ",
									"    else if( (pm.variables.get(\"updateRequest\").record.reach !=undefined) &&",
									"        (getRecord().reach != pm.variables.get(\"updateRequest\").record.reach) )",
									"    {",
									"        return false;",
									"    }",
									"        else if( (pm.variables.get(\"updateRequest\").record.views !=undefined) &&",
									"        (getRecord().views != pm.variables.get(\"updateRequest\").record.views) )",
									"    {",
									"        return false;",
									"    }   ",
									"        else if( (pm.variables.get(\"updateRequest\").record.saves !=undefined)  &&",
									"        (getRecord().saves != pm.variables.get(\"updateRequest\").record.saves) )",
									"    {",
									"        return false;",
									"    }",
									"    else",
									"    {",
									"        return true;",
									"    }    ",
									"}",
									"",
									""
								],
								"type": "text/javascript"
							}
						}
					],
					"request": {
						"method": "GET",
						"header": [],
						"url": {
							"raw": "{{test}}post/611b5ef1416a8f754181fb0f/record?from=2020-12-30&to=2021-09-08",
							"host": [
								"{{test}}post"
							],
							"path": [
								"611b5ef1416a8f754181fb0f",
								"record"
							],
							"query": [
								{
									"key": "from",
									"value": "2020-12-30"
								},
								{
									"key": "to",
									"value": "2021-09-08"
								}
							]
						}
					},
					"response": []
				}
			]
		},
		{
			"name": "NEG Update Record (PostSource Not OTHER)",
			"item": [
				{
					"name": "BOSS login",
					"event": [
						{
							"listen": "test",
							"script": {
								"exec": [
									"pm.test(\"Status code is 200\", function () {",
									"    pm.response.to.have.status(200);",
									"});"
								],
								"type": "text/javascript"
							}
						}
					],
					"request": {
						"method": "POST",
						"header": [
							{
								"warning": "This is a duplicate header and will be overridden by the Content-Type header generated by Postman.",
								"key": "Content-Type",
								"value": "application/x-www-form-urlencoded",
								"type": "text"
							}
						],
						"body": {
							"mode": "urlencoded",
							"urlencoded": [
								{
									"key": "username",
									"value": "dumbanddummy1+brooke@gmail.com",
									"description": "dumbanddummy1+brooke@gmail.com",
									"type": "text"
								},
								{
									"key": "password",
									"value": "hypetap1",
									"type": "text"
								},
								{
									"key": "remember-me",
									"value": "true",
									"type": "text"
								}
							]
						},
						"url": {
							"raw": "{{test}}login",
							"host": [
								"{{test}}login"
							]
						}
					},
					"response": []
				},
				{
					"name": "Record exists (save original)",
					"event": [
						{
							"listen": "test",
							"script": {
								"exec": [
									"var responseBody = pm.response.json();",
									"",
									"if(pm.response.code==200)",
									"{",
									"    ",
									"    if(responseBody.object.length==0)",
									"    {",
									"        pm.test(\"Status 200 no records returned\");",
									"    }",
									"    else",
									"    {        ",
									"        //if a record is found",
									"        //check if changes have been made from PUT call",
									"        if(getRecord()!=undefined)",
									"        {",
									"            pm.environment.set(\"originalRecord\", JSON.stringify(getRecord()));",
									"",
									"            pm.test(\"Record corresponding to given recordId have been found and saved\");",
									"        }",
									"        //will fail if this test is called without the collection runner",
									"        else",
									"        {",
									"            pm.test(\"No record found with given recordId from collection variables\", function(){",
									"                pm.expect(getRecord()).to.not.equal(undefined);",
									"            })",
									"",
									"        }",
									"",
									"        pm.test(\"Status 200, posts are within date range: \"+pm.request.url.query.toObject().from+\" - \"+pm.request.url.query.toObject().to, function(){",
									"            pm.expect(withinDates(pm.request.url.query.toObject().from, pm.request.url.query.toObject().to)).to.equal(true);",
									"        })",
									"    }",
									"}",
									"else if(pm.response.code==404)",
									"{",
									"    pm.test(\"Post id not found\", function(){",
									"        pm.expect(responseBody.object).to.equal(null);",
									"    })",
									"",
									"}",
									"else if (pm.response.code == 403) ",
									"{",
									"    pm.test(\"Unauthorised to make call, only allowed for hypetap\");",
									"}",
									"",
									"//-------------Functions",
									"",
									"function withinDates(from, to)",
									"{",
									"    for(let i =0; i<responseBody.object.length; ++i)",
									"    {",
									"        if(responseBody.object.dateCreated< from &&",
									"            responseBody.object.dateCreated>to)",
									"        {",
									"            return false;",
									"        }",
									"    }",
									"    return true;",
									"}",
									"",
									"//find record we're trying to update in PUT call",
									"function getRecord()",
									"{",
									"    record={};",
									"    for(let i = 0; i< responseBody.object.length; ++i)",
									"    {",
									"        if(responseBody.object[i].id == pm.variables.get(\"negAPPROVEDPostRecordId\"))",
									"        {",
									"            return responseBody.object[i];",
									"        }",
									"    }",
									"}",
									""
								],
								"type": "text/javascript"
							}
						}
					],
					"request": {
						"method": "GET",
						"header": [],
						"url": {
							"raw": "{{test}}post/61283918416a8f7541a337c6/record?from=2020-12-30&to=2021-09-08",
							"host": [
								"{{test}}post"
							],
							"path": [
								"61283918416a8f7541a337c6",
								"record"
							],
							"query": [
								{
									"key": "from",
									"value": "2020-12-30"
								},
								{
									"key": "to",
									"value": "2021-09-08"
								}
							]
						}
					},
					"response": []
				},
				{
					"name": "Update recordId",
					"event": [
						{
							"listen": "test",
							"script": {
								"exec": [
									"// will only update existing record ids",
									"// returns post and lates record even if no update was done",
									"",
									"var responseBody = pm.response.json();",
									"var requestBody = JSON.parse(pm.request.body.raw);",
									"",
									"//runns regardless of status",
									"pm.test(\"Required fields, impressions, views and reach are provided\", function(){",
									"    pm.expect(requestBody.record.impressions).to.not.equal(undefined);",
									"    pm.expect(requestBody.record.views).to.not.equal(undefined);",
									"    pm.expect(requestBody.record.reach).to.not.equal(undefined);",
									"})",
									"",
									"//save request to be able to validate if changes were made in get call",
									"pm.variables.set(\"updateRequest\", requestBody);",
									"",
									"",
									"// response from this call only shows the lates record so need to validate with another GET call ",
									"// to make sure an update was made",
									"if(pm.response.code==200)",
									"{",
									"",
									"",
									"    //platform is not returned in get calls",
									"    //saving it from the request here so that it can be used in the revert PUT call",
									"    pm.environment.set(\"platform\", requestBody.record.platform);",
									"",
									"",
									"    // check if all fields have been updated",
									"    // record date is not required, will update existing record and keep old date in non is given",
									"    pm.test(\"Status 200 for recordId \"+ pm.request.url.path[4])",
									"}",
									"else if(pm.response.code==400)",
									"{",
									"    //The requested record date cannot be set to before the post date or to the same record date of the last update,",
									"    //(if an update has been made previously).",
									"    // will not update if post source = OTHER",
									"    if(responseBody.notes.userMessage!=undefined)",
									"    {",
									"        pm.test(\"Status 400, userMessage: \"+ responseBody.notes.userMessage, function(){",
									"            pm.expect(responseBody.notes.userMessage).to.be.oneOf([\"Record must be after post date\",",
									"                                                            \"Post already has a record for that date\",",
									"                                                            \"Can't update automatically fetched records\",",
									"                                                            \"Views must be greater than 0\",",
									"                                                            \"Impressions must be greater than 0\",",
									"                                                            \"Reach must be greater than 0\",",
									"                                                            \"Reach cannot be higher than impressions\",",
									"                                                            \"Likes cannot be higher than reach\",",
									"                                                            \"Record platform does not match post platform\",",
									"                                                            \"Saves cannot be higher than reach\",",
									"                                                            \"Views must be greater than or equal to reach\"]);",
									"        })",
									"    }",
									"    else if(responseBody.object===null )",
									"    {",
									"        pm.test(\"Platform is required, make sure it's valid\");",
									"    }",
									"}",
									"else if(pm.response.code==404)",
									"{",
									"    pm.test(\"Post id not found\", function(){",
									"        pm.expect(responseBody.object).to.equal(null);",
									"    })",
									"",
									"}",
									"else if (pm.response.code == 403) ",
									"{",
									"    pm.test(\"Unauthorised to make call, only allowed for hypetap\");",
									"}",
									"",
									"//---------------Functions",
									"",
									"function updateSuccessful()",
									"{",
									"    //not undefined means it was given in the request",
									"    if( (requestBody.record.likes !=undefined) &&",
									"        (responseBody.object.latestRecord.likes != requestBody.record.likes) )",
									"    {",
									"        return false;",
									"    }",
									"    else if( (requestBody.record.comments !=undefined) &&",
									"        (responseBody.object.latestRecord.comments != requestBody.record.comments) )",
									"    {",
									"        return false;",
									"    }",
									"    else if( (requestBody.record.impressions !=undefined) &&",
									"        (responseBody.object.latestRecord.impressions != requestBody.record.impressions) )",
									"    {",
									"        return false;",
									"    }    ",
									"    else if( (requestBody.record.reach !=undefined) &&",
									"        (responseBody.object.latestRecord.reach != requestBody.record.reach) )",
									"    {",
									"        return false;",
									"    }",
									"        else if( (requestBody.record.views !=undefined) &&",
									"        (responseBody.object.latestRecord.views != requestBody.record.views) )",
									"    {",
									"        return false;",
									"    }   ",
									"        else if( (requestBody.record.saves !=undefined)  &&",
									"        (responseBody.object.latestRecord.saves != requestBody.record.saves) )",
									"    {",
									"        return false;",
									"    }",
									"    else",
									"    {",
									"        return true;",
									"    }    ",
									"}",
									"",
									""
								],
								"type": "text/javascript"
							}
						}
					],
					"request": {
						"method": "PUT",
						"header": [],
						"body": {
							"mode": "raw",
							"raw": "{\n  \"record\": {\n    \"platform\": \"INSTAGRAM\",\n    \"comments\": \"\",\n    \"likes\": 400,\n    \"impressions\": 400,\n    \"reach\": 400,\n    \"views\": 400,\n    \"saves\":0\n  },\n   \"recordDate\": \"2021-07-18\"\n}",
							"options": {
								"raw": {
									"language": "json"
								}
							}
						},
						"url": {
							"raw": "{{test}}post/61283918416a8f7541a337c6/record/{{negAPPROVEDPostRecordId}}",
							"host": [
								"{{test}}post"
							],
							"path": [
								"61283918416a8f7541a337c6",
								"record",
								"{{negAPPROVEDPostRecordId}}"
							]
						},
						"description": "recordDate is only needed if the date is to be altered for given recordId"
					},
					"response": []
				},
				{
					"name": "Verify updates",
					"event": [
						{
							"listen": "test",
							"script": {
								"exec": [
									"var responseBody = pm.response.json();",
									"",
									"if(pm.response.code==200)",
									"{",
									"    ",
									"    if(responseBody.object.length==0)",
									"    {",
									"        pm.test(\"Status 200 no records returned\");",
									"    }",
									"    else",
									"    {        ",
									"        //if a record is found",
									"        //check if changes have been made from PUT call",
									"        if(getRecord()!=undefined)",
									"        {",
									"            pm.test(\"Update was not successful\", function(){",
									"                pm.expect(updateSuccessful()).to.equal(false);",
									"            })",
									"        }",
									"        //will fail if this test is called without the collection runner",
									"        else",
									"        {",
									"            pm.test(\"No record found with given recordId from PUT call\", function(){",
									"                pm.expect(getRecord()).to.not.equal(undefined);",
									"            })",
									"",
									"        }",
									"",
									"        pm.test(\"Status 200, posts are within date range: \"+pm.request.url.query.toObject().from+\" - \"+pm.request.url.query.toObject().to, function(){",
									"            pm.expect(withinDates(pm.request.url.query.toObject().from, pm.request.url.query.toObject().to)).to.equal(true);",
									"        })",
									"    }",
									"}",
									"else if(pm.response.code==404)",
									"{",
									"    pm.test(\"Post id not found\", function(){",
									"        pm.expect(responseBody.object).to.equal(null);",
									"    })",
									"",
									"}",
									"else if (pm.response.code == 403) ",
									"{",
									"    pm.test(\"Unauthorised to make call, only allowed for hypetap\");",
									"}",
									"",
									"//-------------Functions",
									"",
									"function withinDates(from, to)",
									"{",
									"    for(let i =0; i<responseBody.object.length; ++i)",
									"    {",
									"        if(responseBody.object.dateCreated< from &&",
									"            responseBody.object.dateCreated>to)",
									"        {",
									"            return false;",
									"        }",
									"    }",
									"    return true;",
									"}",
									"",
									"//find record we're trying to update in PUT call",
									"function getRecord()",
									"{",
									"    for(let i = 0; i< responseBody.object.length; ++i)",
									"    {",
									"        if(responseBody.object[i].id == pm.variables.get(\"negAPPROVEDPostRecordId\"))",
									"        {",
									"            return  responseBody.object[i];  //retun record if found",
									"        }",
									"    }",
									"}",
									"",
									"// variable \"updateRequest\" contains request from PUT call",
									"//getRecord() returns the record id, (from the response), which we tried to update in PUT call",
									"function updateSuccessful()",
									"{",
									"    //not undefined means it was given in the request",
									"    // field will be undefined in request if not given",
									"    if( (pm.variables.get(\"updateRequest\").record.likes !=undefined) &&",
									"        (getRecord().likes != pm.variables.get(\"updateRequest\").record.likes) )",
									"    {",
									"        return false;",
									"    }",
									"    else if( (pm.variables.get(\"updateRequest\").record.comments !=undefined) &&",
									"        (getRecord().comments != pm.variables.get(\"updateRequest\").record.comments) )",
									"    {",
									"        return false;",
									"    }",
									"    else if( (pm.variables.get(\"updateRequest\").record.impressions !=undefined) &&",
									"        (getRecord().impressions != pm.variables.get(\"updateRequest\").record.impressions) )",
									"    {",
									"        return false;",
									"    }    ",
									"    else if( (pm.variables.get(\"updateRequest\").record.reach !=undefined) &&",
									"        (getRecord().reach != pm.variables.get(\"updateRequest\").record.reach) )",
									"    {",
									"        return false;",
									"    }",
									"        else if( (pm.variables.get(\"updateRequest\").record.views !=undefined) &&",
									"        (getRecord().views != pm.variables.get(\"updateRequest\").record.views) )",
									"    {",
									"        return false;",
									"    }   ",
									"        else if( (pm.variables.get(\"updateRequest\").record.saves !=undefined)  &&",
									"        (getRecord().saves != pm.variables.get(\"updateRequest\").record.saves) )",
									"    {",
									"        return false;",
									"    }",
									"    else",
									"    {",
									"        return true;",
									"    }    ",
									"}",
									"",
									""
								],
								"type": "text/javascript"
							}
						}
					],
					"request": {
						"method": "GET",
						"header": [],
						"url": {
							"raw": "{{test}}post/61283918416a8f7541a337c6/record?from=2020-12-30&to=2021-09-08",
							"host": [
								"{{test}}post"
							],
							"path": [
								"61283918416a8f7541a337c6",
								"record"
							],
							"query": [
								{
									"key": "from",
									"value": "2020-12-30"
								},
								{
									"key": "to",
									"value": "2021-09-08"
								}
							]
						}
					},
					"response": []
				}
			]
		},
		{
			"name": "NEG Update Non Existing Post",
			"item": [
				{
					"name": "BOSS login",
					"event": [
						{
							"listen": "test",
							"script": {
								"exec": [
									"pm.test(\"Status code is 200\", function () {",
									"    pm.response.to.have.status(200);",
									"});"
								],
								"type": "text/javascript"
							}
						}
					],
					"request": {
						"method": "POST",
						"header": [
							{
								"warning": "This is a duplicate header and will be overridden by the Content-Type header generated by Postman.",
								"key": "Content-Type",
								"value": "application/x-www-form-urlencoded",
								"type": "text"
							}
						],
						"body": {
							"mode": "urlencoded",
							"urlencoded": [
								{
									"key": "username",
									"value": "dumbanddummy1+brooke@gmail.com",
									"description": "dumbanddummy1+brooke@gmail.com",
									"type": "text"
								},
								{
									"key": "password",
									"value": "hypetap1",
									"type": "text"
								},
								{
									"key": "remember-me",
									"value": "true",
									"type": "text"
								}
							]
						},
						"url": {
							"raw": "{{test}}login",
							"host": [
								"{{test}}login"
							]
						}
					},
					"response": []
				},
				{
					"name": "Record exists (save original)",
					"event": [
						{
							"listen": "test",
							"script": {
								"exec": [
									"var responseBody = pm.response.json();",
									"",
									"if(pm.response.code==200)",
									"{",
									"    ",
									"    if(responseBody.object.length==0)",
									"    {",
									"        pm.test(\"Status 200 no records returned\");",
									"    }",
									"    else",
									"    {        ",
									"        //if a record is found",
									"        //check if changes have been made from PUT call",
									"        if(getRecord()!=undefined)",
									"        {",
									"            pm.environment.set(\"originalRecord\", JSON.stringify(getRecord()));",
									"",
									"            pm.test(\"Record corresponding to given recordId have been found and saved\");",
									"        }",
									"        //will fail if this test is called without the collection runner",
									"        else",
									"        {",
									"            pm.test(\"No record found with given recordId from collection variables\", function(){",
									"                pm.expect(getRecord()).to.not.equal(undefined);",
									"            })",
									"",
									"        }",
									"",
									"        pm.test(\"Status 200, posts are within date range: \"+pm.request.url.query.toObject().from+\" - \"+pm.request.url.query.toObject().to, function(){",
									"            pm.expect(withinDates(pm.request.url.query.toObject().from, pm.request.url.query.toObject().to)).to.equal(true);",
									"        })",
									"    }",
									"}",
									"else if(pm.response.code==404)",
									"{",
									"    pm.test(\"Post id not found\", function(){",
									"        pm.expect(responseBody.object).to.equal(null);",
									"    })",
									"",
									"}",
									"else if (pm.response.code == 403) ",
									"{",
									"    pm.test(\"Unauthorised to make call, only allowed for hypetap\");",
									"}",
									"",
									"//-------------Functions",
									"",
									"function withinDates(from, to)",
									"{",
									"    for(let i =0; i<responseBody.object.length; ++i)",
									"    {",
									"        if(responseBody.object.dateCreated< from &&",
									"            responseBody.object.dateCreated>to)",
									"        {",
									"            return false;",
									"        }",
									"    }",
									"    return true;",
									"}",
									"",
									"//find record we're trying to update in PUT call",
									"function getRecord()",
									"{",
									"    record={};",
									"    for(let i = 0; i< responseBody.object.length; ++i)",
									"    {",
									"        if(responseBody.object[i].id == pm.variables.get(\"updateRecordId\"))",
									"        {",
									"            return responseBody.object[i];",
									"        }",
									"    }",
									"}",
									""
								],
								"type": "text/javascript"
							}
						}
					],
					"request": {
						"method": "GET",
						"header": [],
						"url": {
							"raw": "{{test}}post/611/record?from=2020-12-30&to=2021-09-08",
							"host": [
								"{{test}}post"
							],
							"path": [
								"611",
								"record"
							],
							"query": [
								{
									"key": "from",
									"value": "2020-12-30"
								},
								{
									"key": "to",
									"value": "2021-09-08"
								}
							]
						}
					},
					"response": []
				},
				{
					"name": "Update recordId",
					"event": [
						{
							"listen": "test",
							"script": {
								"exec": [
									"// will only update existing record ids",
									"// returns post and lates record even if no update was done",
									"",
									"var responseBody = pm.response.json();",
									"var requestBody = JSON.parse(pm.request.body.raw);",
									"",
									"//runns regardless of status",
									"pm.test(\"Required fields, impressions, views and reach are provided\", function(){",
									"    pm.expect(requestBody.record.impressions).to.not.equal(undefined);",
									"    pm.expect(requestBody.record.views).to.not.equal(undefined);",
									"    pm.expect(requestBody.record.reach).to.not.equal(undefined);",
									"})",
									"",
									"",
									"//save request to be able to validate if changes were made in get call",
									"pm.variables.set(\"updateRequest\", requestBody);",
									"",
									"// response from this call only shows the lates record so need to validate with another GET call ",
									"// to make sure an update was made",
									"if(pm.response.code==200)",
									"{",
									"",
									"    //platform is not returned in get calls",
									"    //saving it from the request here so that it can be used in the revert PUT call",
									"    pm.environment.set(\"platform\", requestBody.record.platform);",
									"",
									"",
									"    // check if all fields have been updated",
									"    // record date is not required, will update existing record and keep old date in non is given",
									"    pm.test(\"Status 200 for recordId \"+ pm.request.url.path[4])",
									"}",
									"else if(pm.response.code==400)",
									"{",
									"    //The requested record date cannot be set to before the post date or to the same record date of the last update,",
									"    //(if an update has been made previously).",
									"    // will not update if post source = OTHER",
									"    if(responseBody.notes.userMessage!=undefined)",
									"    {",
									"        pm.test(\"Status 400, userMessage: \"+ responseBody.notes.userMessage, function(){",
									"            pm.expect(responseBody.notes.userMessage).to.be.oneOf([\"Record must be after post date\",",
									"                                                            \"Post already has a record for that date\",",
									"                                                            \"Can't update automatically fetched records\",",
									"                                                            \"Views must be greater than 0\",",
									"                                                            \"Impressions must be greater than 0\",",
									"                                                            \"Reach must be greater than 0\",",
									"                                                            \"Reach cannot be higher than impressions\",",
									"                                                            \"Likes cannot be higher than reach\",",
									"                                                            \"Record platform does not match post platform\",",
									"                                                            \"Saves cannot be higher than reach\",",
									"                                                            \"Views must be greater than or equal to reach\"]);",
									"        })",
									"    }",
									"    else if(responseBody.object===null )",
									"    {",
									"        pm.test(\"Platform is required, make sure it's valid\");",
									"    }",
									"}",
									"else if(pm.response.code==404)",
									"{",
									"    pm.test(\"Post id not found\", function(){",
									"        pm.expect(responseBody.object).to.equal(null);",
									"    })",
									"",
									"}",
									"else if (pm.response.code == 403) ",
									"{",
									"    pm.test(\"Unauthorised to make call, only allowed for hypetap\");",
									"}",
									"",
									"//---------------Functions",
									"",
									"function updateSuccessful()",
									"{",
									"    //not undefined means it was given in the request",
									"    if( (requestBody.record.likes !=undefined) &&",
									"        (responseBody.object.latestRecord.likes != requestBody.record.likes) )",
									"    {",
									"        return false;",
									"    }",
									"    else if( (requestBody.record.comments !=undefined) &&",
									"        (responseBody.object.latestRecord.comments != requestBody.record.comments) )",
									"    {",
									"        return false;",
									"    }",
									"    else if( (requestBody.record.impressions !=undefined) &&",
									"        (responseBody.object.latestRecord.impressions != requestBody.record.impressions) )",
									"    {",
									"        return false;",
									"    }    ",
									"    else if( (requestBody.record.reach !=undefined) &&",
									"        (responseBody.object.latestRecord.reach != requestBody.record.reach) )",
									"    {",
									"        return false;",
									"    }",
									"        else if( (requestBody.record.views !=undefined) &&",
									"        (responseBody.object.latestRecord.views != requestBody.record.views) )",
									"    {",
									"        return false;",
									"    }   ",
									"        else if( (requestBody.record.saves !=undefined)  &&",
									"        (responseBody.object.latestRecord.saves != requestBody.record.saves) )",
									"    {",
									"        return false;",
									"    }",
									"    else",
									"    {",
									"        return true;",
									"    }    ",
									"}",
									"",
									""
								],
								"type": "text/javascript"
							}
						}
					],
					"request": {
						"method": "PUT",
						"header": [],
						"body": {
							"mode": "raw",
							"raw": "{\n  \"record\": {\n    \"platform\": \"INSTAGRAM\",\n    \"comments\": \"\",\n    \"likes\": 400,\n    \"impressions\": 400,\n    \"reach\": 400,\n    \"views\": 400,\n    \"saves\":0\n  },\n   \"recordDate\": \"2021-08-20\"\n}",
							"options": {
								"raw": {
									"language": "json"
								}
							}
						},
						"url": {
							"raw": "{{test}}post/611/record/{{updateRecordId}}",
							"host": [
								"{{test}}post"
							],
							"path": [
								"611",
								"record",
								"{{updateRecordId}}"
							]
						},
						"description": "recordDate is only needed if the date is to be altered for given recordId"
					},
					"response": []
				},
				{
					"name": "Verify updates",
					"event": [
						{
							"listen": "test",
							"script": {
								"exec": [
									"var responseBody = pm.response.json();",
									"",
									"if(pm.response.code==200)",
									"{",
									"    ",
									"    if(responseBody.object.length==0)",
									"    {",
									"        pm.test(\"Status 200 no records returned\");",
									"    }",
									"    else",
									"    {        ",
									"        //if a record is found",
									"        //check if changes have been made from PUT call",
									"        if(getRecord()!=undefined)",
									"        {",
									"            pm.test(\"Update was successful\", function(){",
									"                pm.expect(updateSuccessful()).to.equal(true);",
									"            })",
									"        }",
									"        //will fail if this test is called without the collection runner",
									"        else",
									"        {",
									"            pm.test(\"No record found with given recordId from PUT call\", function(){",
									"                pm.expect(getRecord()).to.not.equal(undefined);",
									"            })",
									"",
									"        }",
									"",
									"        pm.test(\"Status 200, posts are within date range: \"+pm.request.url.query.toObject().from+\" - \"+pm.request.url.query.toObject().to, function(){",
									"            pm.expect(withinDates(pm.request.url.query.toObject().from, pm.request.url.query.toObject().to)).to.equal(true);",
									"        })",
									"    }",
									"}",
									"else if(pm.response.code==404)",
									"{",
									"    pm.test(\"Post id not found\", function(){",
									"        pm.expect(responseBody.object).to.equal(null);",
									"    })",
									"",
									"}",
									"else if (pm.response.code == 403) ",
									"{",
									"    pm.test(\"Unauthorised to make call, only allowed for hypetap\");",
									"}",
									"",
									"//-------------Functions",
									"",
									"function withinDates(from, to)",
									"{",
									"    for(let i =0; i<responseBody.object.length; ++i)",
									"    {",
									"        if(responseBody.object.dateCreated< from &&",
									"            responseBody.object.dateCreated>to)",
									"        {",
									"            return false;",
									"        }",
									"    }",
									"    return true;",
									"}",
									"",
									"//find record we're trying to update in PUT call",
									"function getRecord()",
									"{",
									"    for(let i = 0; i< responseBody.object.length; ++i)",
									"    {",
									"        if(responseBody.object[i].id == pm.variables.get(\"updateRecordId\"))",
									"        {",
									"            return  responseBody.object[i];  //retun record if found",
									"        }",
									"    }",
									"}",
									"",
									"// variable \"updateRequest\" contains request from PUT call",
									"//getRecord() returns the record id, (from the response), which we tried to update in PUT call",
									"function updateSuccessful()",
									"{",
									"    //not undefined means it was given in the request",
									"    // field will be undefined in request if not given",
									"    if( (pm.variables.get(\"updateRequest\").record.likes !=undefined) &&",
									"        (getRecord().likes != pm.variables.get(\"updateRequest\").record.likes) )",
									"    {",
									"        return false;",
									"    }",
									"    else if( (pm.variables.get(\"updateRequest\").record.comments !=undefined) &&",
									"        (getRecord().comments != pm.variables.get(\"updateRequest\").record.comments) )",
									"    {",
									"        return false;",
									"    }",
									"    else if( (pm.variables.get(\"updateRequest\").record.impressions !=undefined) &&",
									"        (getRecord().impressions != pm.variables.get(\"updateRequest\").record.impressions) )",
									"    {",
									"        return false;",
									"    }    ",
									"    else if( (pm.variables.get(\"updateRequest\").record.reach !=undefined) &&",
									"        (getRecord().reach != pm.variables.get(\"updateRequest\").record.reach) )",
									"    {",
									"        return false;",
									"    }",
									"        else if( (pm.variables.get(\"updateRequest\").record.views !=undefined) &&",
									"        (getRecord().views != pm.variables.get(\"updateRequest\").record.views) )",
									"    {",
									"        return false;",
									"    }   ",
									"        else if( (pm.variables.get(\"updateRequest\").record.saves !=undefined)  &&",
									"        (getRecord().saves != pm.variables.get(\"updateRequest\").record.saves) )",
									"    {",
									"        return false;",
									"    }",
									"    else",
									"    {",
									"        return true;",
									"    }    ",
									"}",
									"",
									""
								],
								"type": "text/javascript"
							}
						}
					],
					"request": {
						"method": "GET",
						"header": [],
						"url": {
							"raw": "{{test}}post/611/record?from=2020-12-30&to=2021-09-08",
							"host": [
								"{{test}}post"
							],
							"path": [
								"611",
								"record"
							],
							"query": [
								{
									"key": "from",
									"value": "2020-12-30"
								},
								{
									"key": "to",
									"value": "2021-09-08"
								}
							]
						}
					},
					"response": []
				}
			]
		},
		{
			"name": "NEG Update Non Existing Record (No Updates Made)",
			"item": [
				{
					"name": "BOSS login",
					"event": [
						{
							"listen": "test",
							"script": {
								"exec": [
									"pm.test(\"Status code is 200\", function () {",
									"    pm.response.to.have.status(200);",
									"});"
								],
								"type": "text/javascript"
							}
						}
					],
					"request": {
						"method": "POST",
						"header": [
							{
								"warning": "This is a duplicate header and will be overridden by the Content-Type header generated by Postman.",
								"key": "Content-Type",
								"value": "application/x-www-form-urlencoded",
								"type": "text"
							}
						],
						"body": {
							"mode": "urlencoded",
							"urlencoded": [
								{
									"key": "username",
									"value": "dumbanddummy1+brooke@gmail.com",
									"description": "dumbanddummy1+brooke@gmail.com",
									"type": "text"
								},
								{
									"key": "password",
									"value": "hypetap1",
									"type": "text"
								},
								{
									"key": "remember-me",
									"value": "true",
									"type": "text"
								}
							]
						},
						"url": {
							"raw": "{{test}}login",
							"host": [
								"{{test}}login"
							]
						}
					},
					"response": []
				},
				{
					"name": "Record exists (save original)",
					"event": [
						{
							"listen": "test",
							"script": {
								"exec": [
									"var responseBody = pm.response.json();",
									"",
									"if(pm.response.code==200)",
									"{",
									"    ",
									"    if(responseBody.object.length==0)",
									"    {",
									"        pm.test(\"Status 200 no records returned\");",
									"    }",
									"    else",
									"    {        ",
									"        //if a record is found",
									"        //check if changes have been made from PUT call",
									"        if(getRecord()!=undefined)",
									"        {",
									"            pm.environment.set(\"originalRecord\", JSON.stringify(getRecord()));",
									"",
									"            pm.test(\"Record corresponding to given recordId have been found and saved\");",
									"        }",
									"        //will fail if this test is called without the collection runner",
									"        else",
									"        {",
									"            pm.test(\"No record found with given recordId from collection variables\", function(){",
									"                pm.expect(getRecord()).to.equal(undefined);",
									"            })",
									"",
									"        }",
									"",
									"        pm.test(\"Status 200, posts are within date range: \"+pm.request.url.query.toObject().from+\" - \"+pm.request.url.query.toObject().to, function(){",
									"            pm.expect(withinDates(pm.request.url.query.toObject().from, pm.request.url.query.toObject().to)).to.equal(true);",
									"        })",
									"    }",
									"}",
									"else if(pm.response.code==404)",
									"{",
									"    pm.test(\"Post id not found\", function(){",
									"        pm.expect(responseBody.object).to.equal(null);",
									"    })",
									"",
									"}",
									"else if (pm.response.code == 403) ",
									"{",
									"    pm.test(\"Unauthorised to make call, only allowed for hypetap\");",
									"}",
									"",
									"//-------------Functions",
									"",
									"function withinDates(from, to)",
									"{",
									"    for(let i =0; i<responseBody.object.length; ++i)",
									"    {",
									"        if(responseBody.object.dateCreated< from &&",
									"            responseBody.object.dateCreated>to)",
									"        {",
									"            return false;",
									"        }",
									"    }",
									"    return true;",
									"}",
									"",
									"//find record we're trying to update in PUT call",
									"function getRecord()",
									"{",
									"    record={};",
									"    for(let i = 0; i< responseBody.object.length; ++i)",
									"    {",
									"        if(responseBody.object[i].id == pm.variables.get(\"negUpdateRecordId\"))",
									"        {",
									"            return responseBody.object[i];",
									"        }",
									"    }",
									"}",
									""
								],
								"type": "text/javascript"
							}
						}
					],
					"request": {
						"method": "GET",
						"header": [],
						"url": {
							"raw": "{{test}}post/611b5ef1416a8f754181fb0f/record?from=2020-12-30&to=2021-09-08",
							"host": [
								"{{test}}post"
							],
							"path": [
								"611b5ef1416a8f754181fb0f",
								"record"
							],
							"query": [
								{
									"key": "from",
									"value": "2020-12-30"
								},
								{
									"key": "to",
									"value": "2021-09-08"
								}
							]
						}
					},
					"response": []
				},
				{
					"name": "Update recordId",
					"event": [
						{
							"listen": "test",
							"script": {
								"exec": [
									"// will only update existing record ids",
									"// returns post and lates record even if no update was done",
									"",
									"var responseBody = pm.response.json();",
									"var requestBody = JSON.parse(pm.request.body.raw);",
									"",
									"//runns regardless of status",
									"pm.test(\"Required fields, impressions, views and reach are provided\", function(){",
									"    pm.expect(requestBody.record.impressions).to.not.equal(undefined);",
									"    pm.expect(requestBody.record.views).to.not.equal(undefined);",
									"    pm.expect(requestBody.record.reach).to.not.equal(undefined);",
									"})",
									"",
									"",
									"//save request to be able to validate if changes were made in get call",
									"pm.variables.set(\"updateRequest\", requestBody);",
									"",
									"// response from this call only shows the lates record so need to validate with another GET call ",
									"// to make sure an update was made",
									"if(pm.response.code==200)",
									"{",
									"",
									"    //platform is not returned in get calls",
									"    //saving it from the request here so that it can be used in the revert PUT call",
									"    pm.environment.set(\"platform\", requestBody.record.platform);",
									"",
									"",
									"    // check if all fields have been updated",
									"    // record date is not required, will update existing record and keep old date in non is given",
									"    pm.test(\"Status 200 for recordId \"+ pm.request.url.path[4])",
									"}",
									"else if(pm.response.code==400)",
									"{",
									"    //The requested record date cannot be set to before the post date or to the same record date of the last update,",
									"    //(if an update has been made previously).",
									"    // will not update if post source = OTHER",
									"    if(responseBody.notes.userMessage!=undefined)",
									"    {",
									"        pm.test(\"Status 400, userMessage: \"+ responseBody.notes.userMessage, function(){",
									"            pm.expect(responseBody.notes.userMessage).to.be.oneOf([\"Record must be after post date\",",
									"                                                            \"Post already has a record for that date\",",
									"                                                            \"Can't update automatically fetched records\",",
									"                                                            \"Views must be greater than 0\",",
									"                                                            \"Impressions must be greater than 0\",",
									"                                                            \"Reach must be greater than 0\",",
									"                                                            \"Reach cannot be higher than impressions\",",
									"                                                            \"Likes cannot be higher than reach\",",
									"                                                            \"Record platform does not match post platform\",",
									"                                                            \"Saves cannot be higher than reach\",",
									"                                                            \"Views must be greater than or equal to reach\"]);",
									"        })",
									"    }",
									"    else if(responseBody.object===null )",
									"    {",
									"        pm.test(\"Platform is required, make sure it's valid\");",
									"    }",
									"}",
									"else if(pm.response.code==404)",
									"{",
									"    pm.test(\"Post id not found\", function(){",
									"        pm.expect(responseBody.object).to.equal(null);",
									"    })",
									"",
									"}",
									"else if (pm.response.code == 403) ",
									"{",
									"    pm.test(\"Unauthorised to make call, only allowed for hypetap\");",
									"}",
									"",
									"//---------------Functions",
									"",
									"function updateSuccessful()",
									"{",
									"    //not undefined means it was given in the request",
									"    if( (requestBody.record.likes !=undefined) &&",
									"        (responseBody.object.latestRecord.likes != requestBody.record.likes) )",
									"    {",
									"        return false;",
									"    }",
									"    else if( (requestBody.record.comments !=undefined) &&",
									"        (responseBody.object.latestRecord.comments != requestBody.record.comments) )",
									"    {",
									"        return false;",
									"    }",
									"    else if( (requestBody.record.impressions !=undefined) &&",
									"        (responseBody.object.latestRecord.impressions != requestBody.record.impressions) )",
									"    {",
									"        return false;",
									"    }    ",
									"    else if( (requestBody.record.reach !=undefined) &&",
									"        (responseBody.object.latestRecord.reach != requestBody.record.reach) )",
									"    {",
									"        return false;",
									"    }",
									"        else if( (requestBody.record.views !=undefined) &&",
									"        (responseBody.object.latestRecord.views != requestBody.record.views) )",
									"    {",
									"        return false;",
									"    }   ",
									"        else if( (requestBody.record.saves !=undefined)  &&",
									"        (responseBody.object.latestRecord.saves != requestBody.record.saves) )",
									"    {",
									"        return false;",
									"    }",
									"    else",
									"    {",
									"        return true;",
									"    }    ",
									"}",
									"",
									""
								],
								"type": "text/javascript"
							}
						}
					],
					"request": {
						"method": "PUT",
						"header": [],
						"body": {
							"mode": "raw",
							"raw": "{\n  \"record\": {\n    \"platform\": \"INSTAGRAM\",\n    \"comments\": \"\",\n    \"likes\": 400,\n    \"impressions\": 400,\n    \"reach\": 400,\n    \"views\": 400,\n    \"saves\":0\n  },\n   \"recordDate\": \"2021-08-20\"\n}",
							"options": {
								"raw": {
									"language": "json"
								}
							}
						},
						"url": {
							"raw": "{{test}}post/611b5ef1416a8f754181fb0f/record/{{negUpdateRecordId}}",
							"host": [
								"{{test}}post"
							],
							"path": [
								"611b5ef1416a8f754181fb0f",
								"record",
								"{{negUpdateRecordId}}"
							]
						},
						"description": "recordDate is only needed if the date is to be altered for given recordId"
					},
					"response": []
				},
				{
					"name": "Verify updates",
					"event": [
						{
							"listen": "test",
							"script": {
								"exec": [
									"var responseBody = pm.response.json();",
									"",
									"if(pm.response.code==200)",
									"{",
									"    ",
									"    if(responseBody.object.length==0)",
									"    {",
									"        pm.test(\"Status 200 no records returned\");",
									"    }",
									"    else",
									"    {        ",
									"        //if a record is found",
									"        //check if changes have been made from PUT call",
									"        if(getRecord()!=undefined)",
									"        {",
									"            pm.test(\"Update was successful\", function(){",
									"                pm.expect(updateSuccessful()).to.equal(true);",
									"            })",
									"        }",
									"        //will fail if this test is called without the collection runner",
									"        else",
									"        {",
									"            pm.test(\"No record found with given recordId from PUT call\", function(){",
									"                pm.expect(getRecord()).to.equal(undefined);",
									"            })",
									"",
									"        }",
									"",
									"        pm.test(\"Status 200, posts are within date range: \"+pm.request.url.query.toObject().from+\" - \"+pm.request.url.query.toObject().to, function(){",
									"            pm.expect(withinDates(pm.request.url.query.toObject().from, pm.request.url.query.toObject().to)).to.equal(true);",
									"        })",
									"    }",
									"}",
									"else if(pm.response.code==404)",
									"{",
									"    pm.test(\"Post id not found\", function(){",
									"        pm.expect(responseBody.object).to.equal(null);",
									"    })",
									"",
									"}",
									"else if (pm.response.code == 403) ",
									"{",
									"    pm.test(\"Unauthorised to make call, only allowed for hypetap\");",
									"}",
									"",
									"//-------------Functions",
									"",
									"function withinDates(from, to)",
									"{",
									"    for(let i =0; i<responseBody.object.length; ++i)",
									"    {",
									"        if(responseBody.object.dateCreated< from &&",
									"            responseBody.object.dateCreated>to)",
									"        {",
									"            return false;",
									"        }",
									"    }",
									"    return true;",
									"}",
									"",
									"//find record we're trying to update in PUT call",
									"function getRecord()",
									"{",
									"    for(let i = 0; i< responseBody.object.length; ++i)",
									"    {",
									"        if(responseBody.object[i].id == pm.variables.get(\"negUpdateRecordId\"))",
									"        {",
									"            return  responseBody.object[i];  //retun record if found",
									"        }",
									"    }",
									"}",
									"",
									"// variable \"updateRequest\" contains request from PUT call",
									"//getRecord() returns the record id, (from the response), which we tried to update in PUT call",
									"function updateSuccessful()",
									"{",
									"    //not undefined means it was given in the request",
									"    // field will be undefined in request if not given",
									"    if( (pm.variables.get(\"updateRequest\").record.likes !=undefined) &&",
									"        (getRecord().likes != pm.variables.get(\"updateRequest\").record.likes) )",
									"    {",
									"        return false;",
									"    }",
									"    else if( (pm.variables.get(\"updateRequest\").record.comments !=undefined) &&",
									"        (getRecord().comments != pm.variables.get(\"updateRequest\").record.comments) )",
									"    {",
									"        return false;",
									"    }",
									"    else if( (pm.variables.get(\"updateRequest\").record.impressions !=undefined) &&",
									"        (getRecord().impressions != pm.variables.get(\"updateRequest\").record.impressions) )",
									"    {",
									"        return false;",
									"    }    ",
									"    else if( (pm.variables.get(\"updateRequest\").record.reach !=undefined) &&",
									"        (getRecord().reach != pm.variables.get(\"updateRequest\").record.reach) )",
									"    {",
									"        return false;",
									"    }",
									"        else if( (pm.variables.get(\"updateRequest\").record.views !=undefined) &&",
									"        (getRecord().views != pm.variables.get(\"updateRequest\").record.views) )",
									"    {",
									"        return false;",
									"    }   ",
									"        else if( (pm.variables.get(\"updateRequest\").record.saves !=undefined)  &&",
									"        (getRecord().saves != pm.variables.get(\"updateRequest\").record.saves) )",
									"    {",
									"        return false;",
									"    }",
									"    else",
									"    {",
									"        return true;",
									"    }    ",
									"}",
									"",
									""
								],
								"type": "text/javascript"
							}
						}
					],
					"request": {
						"method": "GET",
						"header": [],
						"url": {
							"raw": "{{test}}post/611b5ef1416a8f754181fb0f/record?from=2020-12-30&to=2021-09-08",
							"host": [
								"{{test}}post"
							],
							"path": [
								"611b5ef1416a8f754181fb0f",
								"record"
							],
							"query": [
								{
									"key": "from",
									"value": "2020-12-30"
								},
								{
									"key": "to",
									"value": "2021-09-08"
								}
							]
						}
					},
					"response": []
				}
			]
		},
		{
			"name": "NEG Update No RecordId Given",
			"item": [
				{
					"name": "BOSS login",
					"event": [
						{
							"listen": "test",
							"script": {
								"exec": [
									"pm.test(\"Status code is 200\", function () {",
									"    pm.response.to.have.status(200);",
									"});"
								],
								"type": "text/javascript"
							}
						}
					],
					"request": {
						"method": "POST",
						"header": [
							{
								"warning": "This is a duplicate header and will be overridden by the Content-Type header generated by Postman.",
								"key": "Content-Type",
								"value": "application/x-www-form-urlencoded",
								"type": "text"
							}
						],
						"body": {
							"mode": "urlencoded",
							"urlencoded": [
								{
									"key": "username",
									"value": "dumbanddummy1+brooke@gmail.com",
									"description": "dumbanddummy1+brooke@gmail.com",
									"type": "text"
								},
								{
									"key": "password",
									"value": "hypetap1",
									"type": "text"
								},
								{
									"key": "remember-me",
									"value": "true",
									"type": "text"
								}
							]
						},
						"url": {
							"raw": "{{test}}login",
							"host": [
								"{{test}}login"
							]
						}
					},
					"response": []
				},
				{
					"name": "Update recordId",
					"event": [
						{
							"listen": "test",
							"script": {
								"exec": [
									"// will only update existing record ids",
									"// returns post and lates record even if no update was done",
									"",
									"var requestBody = JSON.parse(pm.request.body.raw);",
									"",
									"//runns regardless of status",
									"pm.test(\"Required fields, impressions, views and reach are provided\", function(){",
									"    pm.expect(requestBody.record.impressions).to.not.equal(undefined);",
									"    pm.expect(requestBody.record.views).to.not.equal(undefined);",
									"    pm.expect(requestBody.record.reach).to.not.equal(undefined);",
									"})",
									"",
									"",
									"//save request to be able to validate if changes were made in get call",
									"pm.variables.set(\"updateRequest\", requestBody);",
									"",
									"// response from this call only shows the lates record so need to validate with another GET call ",
									"// to make sure an update was made",
									"if(pm.response.code==200)",
									"{",
									"",
									"var responseBody = pm.response.json();",
									"",
									"    //platform is not returned in get calls",
									"    //saving it from the request here so that it can be used in the revert PUT call",
									"    pm.environment.set(\"platform\", requestBody.record.platform);",
									"",
									"",
									"    // check if all fields have been updated",
									"    // record date is not required, will update existing record and keep old date in non is given",
									"    pm.test(\"Status 200 for recordId \"+ pm.request.url.path[4])",
									"}",
									"else if(pm.response.code==400)",
									"{",
									"    ",
									"var responseBody = pm.response.json();",
									"    //The requested record date cannot be set to before the post date or to the same record date of the last update,",
									"    //(if an update has been made previously).",
									"    // will not update if post source = OTHER",
									"    if(responseBody.notes.userMessage!=undefined)",
									"    {",
									"        pm.test(\"Status 400, userMessage: \"+ responseBody.notes.userMessage, function(){",
									"            pm.expect(responseBody.notes.userMessage).to.be.oneOf([\"Record must be after post date\",",
									"                                                            \"Post already has a record for that date\",",
									"                                                            \"Can't update automatically fetched records\",",
									"                                                            \"Views must be greater than 0\",",
									"                                                            \"Impressions must be greater than 0\",",
									"                                                            \"Reach must be greater than 0\",",
									"                                                            \"Reach cannot be higher than impressions\",",
									"                                                            \"Likes cannot be higher than reach\",",
									"                                                            \"Record platform does not match post platform\",",
									"                                                            \"Saves cannot be higher than reach\",",
									"                                                            \"Views must be greater than or equal to reach\"]);",
									"        })",
									"    }",
									"    else if(responseBody.object===null )",
									"    {",
									"        pm.test(\"Platform is required, make sure it's valid\");",
									"    }",
									"}",
									"else if(pm.response.code==404)",
									"{",
									"    pm.test(\"Post id not found\", function(){",
									"        pm.expect(responseBody.object).to.equal(null);",
									"    })",
									"",
									"}",
									"else if (pm.response.code == 403) ",
									"{",
									"    pm.test(\"Unauthorised to make call, only allowed for hypetap\");",
									"}",
									"else if (pm.response.code == 405) ",
									"{",
									"    pm.test(\"Make sure to provide a recordId\");",
									"}",
									"//---------------Functions",
									"",
									"function updateSuccessful()",
									"{",
									"    //not undefined means it was given in the request",
									"    if( (requestBody.record.likes !=undefined) &&",
									"        (responseBody.object.latestRecord.likes != requestBody.record.likes) )",
									"    {",
									"        return false;",
									"    }",
									"    else if( (requestBody.record.comments !=undefined) &&",
									"        (responseBody.object.latestRecord.comments != requestBody.record.comments) )",
									"    {",
									"        return false;",
									"    }",
									"    else if( (requestBody.record.impressions !=undefined) &&",
									"        (responseBody.object.latestRecord.impressions != requestBody.record.impressions) )",
									"    {",
									"        return false;",
									"    }    ",
									"    else if( (requestBody.record.reach !=undefined) &&",
									"        (responseBody.object.latestRecord.reach != requestBody.record.reach) )",
									"    {",
									"        return false;",
									"    }",
									"        else if( (requestBody.record.views !=undefined) &&",
									"        (responseBody.object.latestRecord.views != requestBody.record.views) )",
									"    {",
									"        return false;",
									"    }   ",
									"        else if( (requestBody.record.saves !=undefined)  &&",
									"        (responseBody.object.latestRecord.saves != requestBody.record.saves) )",
									"    {",
									"        return false;",
									"    }",
									"    else",
									"    {",
									"        return true;",
									"    }    ",
									"}",
									"",
									""
								],
								"type": "text/javascript"
							}
						}
					],
					"request": {
						"method": "PUT",
						"header": [],
						"body": {
							"mode": "raw",
							"raw": "{\n  \"record\": {\n    \"platform\": \"INSTAGRAM\",\n    \"comments\": \"\",\n    \"likes\": 400,\n    \"impressions\": 400,\n    \"reach\": 400,\n    \"views\": 400,\n    \"saves\":0\n  },\n   \"recordDate\": \"2021-08-20\"\n}",
							"options": {
								"raw": {
									"language": "json"
								}
							}
						},
						"url": {
							"raw": "{{test}}post/611b5ef1416a8f754181fb0f/record/",
							"host": [
								"{{test}}post"
							],
							"path": [
								"611b5ef1416a8f754181fb0f",
								"record",
								""
							]
						},
						"description": "recordDate is only needed if the date is to be altered for given recordId"
					},
					"response": []
				}
			]
		},
		{
			"name": "NEG Delete Last Record",
			"item": [
				{
					"name": "Records After (requires date range) Copy 2",
					"event": [
						{
							"listen": "test",
							"script": {
								"exec": [
									"var responseBody = pm.response.json();",
									"",
									"if(pm.response.code==200)",
									"{",
									"    if(responseBody.object.length==0)",
									"    {",
									"        pm.test(\"Status 200 no records returned for postId \" + pm.request.url.path[2]);",
									"    }",
									"    else",
									"    {",
									"",
									"        pm.test(\"Status 200, for postId \" + pm.request.url.path[2]);",
									"",
									"        //both dates has to be given for call to work",
									"        pm.test(\"Records returned: \" + responseBody.object.length+ \". Records are within date range: \"+pm.request.url.query.toObject().from+\" - \"+pm.request.url.query.toObject().to, function(){",
									"            pm.expect(withinDates(pm.request.url.query.toObject().from, pm.request.url.query.toObject().to)).to.equal(true);",
									"        })",
									"",
									"        pm.test(\"Record exist\", function(){",
									"            pm.expect(recordExist( responseBody.object, \"60ca9d702181372ab93cc450\") ).to.equal(true);",
									"        })",
									"    }",
									"}",
									"else if(pm.response.code==404)",
									"{",
									"    pm.test(\"Post id not found\", function(){",
									"        pm.expect(responseBody.object).to.equal(null);",
									"    })",
									"",
									"}",
									"else if (pm.response.code == 403) ",
									"{",
									"    pm.test(\"Unauthorised to make call, only allowed for hypetap\");",
									"}",
									"",
									"//-------------Functions",
									"",
									"function withinDates(from, to)",
									"{",
									"    for(let i =0; i<responseBody.object.length; ++i)",
									"    {",
									"        if( (new Date(responseBody.object[i].dateCreated).getTime()< new Date(from).getTime() ) &&",
									"            ( new Date(responseBody.object[i].dateCreated).getTime() >new Date(to).getTime() ) )",
									"        {",
									"            return false;",
									"        }",
									"    }",
									"    return true;",
									"",
									"}",
									"// checks if the new record, (from reuest in POST call), exist and if the data match",
									"function recordExist(list, recordId)",
									"{",
									"    for(let i=0; i<list.length; ++i)",
									"    {",
									"        ",
									"        if(recordId==list[i].id)",
									"        {",
									"            return true;",
									"        }",
									"",
									"    }",
									"    return false;    //record not found",
									"}"
								],
								"type": "text/javascript"
							}
						}
					],
					"request": {
						"method": "GET",
						"header": [],
						"url": {
							"raw": "{{test}}post/60ca9d702181372ab93cc451/record?from=2014-12-31&to=2021-09-29",
							"host": [
								"{{test}}post"
							],
							"path": [
								"60ca9d702181372ab93cc451",
								"record"
							],
							"query": [
								{
									"key": "from",
									"value": "2014-12-31"
								},
								{
									"key": "to",
									"value": "2021-09-29",
									"description": "set in pre test script of current folder"
								}
							]
						}
					},
					"response": []
				},
				{
					"name": "Delete Record ({postId}/record/{recordId}) Copy",
					"event": [
						{
							"listen": "test",
							"script": {
								"exec": [
									"// Will not delete for a post with PostSource set to OTHER as record data is not applicable to those posts.",
									"var responseBody = pm.response.json();",
									"if(pm.response.code==200)",
									"{",
									"    pm.test(\"Status 200. Deleted record with id \"+ pm.request.url.path[4]);",
									"}",
									"else if (pm.response.code == 403) ",
									"{",
									"    pm.test(\"Unauthorised to make call, only allowed for hypetap\");",
									"}",
									"else if(pm.response.code==400)",
									"{",
									"    if(responseBody.notes.userMessage!=undefined)",
									"    {",
									"        pm.test(\"Status 400, userMessage: \"+ responseBody.notes.userMessage);",
									"    }",
									"}"
								],
								"type": "text/javascript"
							}
						}
					],
					"request": {
						"method": "DELETE",
						"header": [],
						"body": {
							"mode": "raw",
							"raw": ""
						},
						"url": {
							"raw": "{{test}}post/60ca9d702181372ab93cc451/record/60ca9d702181372ab93cc450",
							"host": [
								"{{test}}post"
							],
							"path": [
								"60ca9d702181372ab93cc451",
								"record",
								"60ca9d702181372ab93cc450"
							]
						}
					},
					"response": []
				},
				{
					"name": "Records After (requires date range)",
					"event": [
						{
							"listen": "test",
							"script": {
								"exec": [
									"var responseBody = pm.response.json();",
									"",
									"if(pm.response.code==200)",
									"{",
									"    if(responseBody.object.length==0)",
									"    {",
									"        pm.test(\"Status 200 no records returned for postId \" + pm.request.url.path[2]);",
									"    }",
									"    else",
									"    {",
									"",
									"        pm.test(\"Status 200, for postId \" + pm.request.url.path[2]);",
									"",
									"        //both dates has to be given for call to work",
									"        pm.test(\"Records returned: \" + responseBody.object.length+ \". Records are within date range: \"+pm.request.url.query.toObject().from+\" - \"+pm.request.url.query.toObject().to, function(){",
									"            pm.expect(withinDates(pm.request.url.query.toObject().from, pm.request.url.query.toObject().to)).to.equal(true);",
									"        })",
									"",
									"        pm.test(\"Record still exist, was not deleted successfuly\", function(){",
									"            pm.expect(recordExist( responseBody.object, \"60ca9d702181372ab93cc450\") ).to.equal(true);",
									"        })",
									"    }",
									"}",
									"else if(pm.response.code==404)",
									"{",
									"    pm.test(\"Post id not found\", function(){",
									"        pm.expect(responseBody.object).to.equal(null);",
									"    })",
									"",
									"}",
									"else if (pm.response.code == 403) ",
									"{",
									"    pm.test(\"Unauthorised to make call, only allowed for hypetap\");",
									"}",
									"",
									"//-------------Functions",
									"",
									"function withinDates(from, to)",
									"{",
									"    for(let i =0; i<responseBody.object.length; ++i)",
									"    {",
									"        if( (new Date(responseBody.object[i].dateCreated).getTime()< new Date(from).getTime() ) &&",
									"            ( new Date(responseBody.object[i].dateCreated).getTime() >new Date(to).getTime() ) )",
									"        {",
									"            return false;",
									"        }",
									"    }",
									"    return true;",
									"",
									"}",
									"// checks if the new record, (from reuest in POST call), exist and if the data match",
									"function recordExist(list, recordId)",
									"{",
									"    for(let i=0; i<list.length; ++i)",
									"    {",
									"        ",
									"        if(recordId==list[i].id)",
									"        {",
									"            return true;",
									"        }",
									"",
									"    }",
									"    return false;    //record not found",
									"}"
								],
								"type": "text/javascript"
							}
						}
					],
					"request": {
						"method": "GET",
						"header": [],
						"url": {
							"raw": "{{test}}post/60ca9d702181372ab93cc451/record?from=2014-12-31&to=2021-09-29",
							"host": [
								"{{test}}post"
							],
							"path": [
								"60ca9d702181372ab93cc451",
								"record"
							],
							"query": [
								{
									"key": "from",
									"value": "2014-12-31"
								},
								{
									"key": "to",
									"value": "2021-09-29",
									"description": "set in pre test script of current folder"
								}
							]
						}
					},
					"response": []
				}
			]
		},
		{
			"name": "NEG Add New Record On Existing Date",
			"item": [
				{
					"name": "BOSS login Copy",
					"event": [
						{
							"listen": "test",
							"script": {
								"exec": [
									"pm.test(\"Status code is 200\", function () {",
									"    pm.response.to.have.status(200);",
									"});"
								],
								"type": "text/javascript"
							}
						}
					],
					"request": {
						"method": "POST",
						"header": [
							{
								"warning": "This is a duplicate header and will be overridden by the Content-Type header generated by Postman.",
								"key": "Content-Type",
								"value": "application/x-www-form-urlencoded",
								"type": "text"
							}
						],
						"body": {
							"mode": "urlencoded",
							"urlencoded": [
								{
									"key": "username",
									"value": "dumbanddummy1+brooke@gmail.com",
									"description": "dumbanddummy1+brooke@gmail.com",
									"type": "text"
								},
								{
									"key": "password",
									"value": "hypetap1",
									"type": "text"
								},
								{
									"key": "remember-me",
									"value": "true",
									"type": "text"
								}
							]
						},
						"url": {
							"raw": "{{test}}login",
							"host": [
								"{{test}}login"
							]
						}
					},
					"response": []
				},
				{
					"name": "Create Record ({postId}/record) Copy",
					"event": [
						{
							"listen": "test",
							"script": {
								"exec": [
									"var responseBody = pm.response.json();",
									"var requestBody = JSON.parse(pm.request.body.raw);",
									"",
									"//save request to be ale to confirm that it was added with the correct data. ",
									"//records are not allowed to be for the same date, so date is unique",
									"pm.variables.set(\"negNewRecord\", requestBody);",
									"",
									"",
									"//runns regardless of status",
									"pm.test(\"Required fields, impressions, views, reach and recordDate are provided\", function(){",
									"    pm.expect(requestBody.record.impressions).to.not.equal(undefined);",
									"    pm.expect(requestBody.record.views).to.not.equal(undefined);",
									"    pm.expect(requestBody.record.reach).to.not.equal(undefined);",
									"    pm.expect(requestBody.recordDate).to.not.equal(undefined);",
									"})",
									"",
									"",
									"if(pm.response.code==200)",
									"{",
									"",
									"    pm.test(\"Status 200. Returns post corresponding to given postId \"+ pm.request.url.path[2], function(){",
									"        pm.expect( pm.request.url.path[2]).to.equal(responseBody.object.id);",
									"    })",
									"",
									"    //the new record has to be after the post date",
									"    //need to convert dates to be able to compare since they are of the type string",
									"    pm.test(\"The new record is after post date. The date of added record \" + requestBody.recordDate, function(){",
									"        pm.expect(new Date(requestBody.recordDate).getTime()> new Date(responseBody.object.datePosted).getTime() ).to.equal(true);",
									"    })",
									"}",
									"else if(pm.response.code==400)",
									"{",
									"    //The requested record date cannot be set to before the post date or to the same record date of the last update,",
									"    //(if an update has been made previously).",
									"    // will not update if post source = OTHER",
									"    if(responseBody.notes.userMessage!=undefined)",
									"    {",
									"        pm.test(\"Status 400, userMessage: \"+ responseBody.notes.userMessage, function(){",
									"            pm.expect(responseBody.notes.userMessage).to.be.oneOf([",
									"                                                            \"Cannot update posts fetched via APIs\",",
									"                                                            \"A record must have a date\",",
									"                                                            \"Record must be after post date\",",
									"                                                            \"Post already has a record for that date\",",
									"                                                            \"Can't update automatically fetched records\",",
									"                                                            \"Views must be greater than 0\",",
									"                                                            \"Impressions must be greater than 0\",",
									"                                                            \"Reach must be greater than 0\",",
									"                                                            \"Reach cannot be higher than impressions\",",
									"                                                            \"Likes cannot be higher than reach\",",
									"                                                            \"Record platform does not match post platform\",",
									"                                                            \"Saves cannot be higher than reach\",",
									"                                                            \"Views must equal impressions\",",
									"                                                            \"Views must be greater than or equal to reach\"]);",
									"        })",
									"    }",
									"    else if(responseBody.object===null )",
									"    {",
									"        pm.test(\"Platform is required, make sure it's valid\");",
									"    }",
									"}",
									"else if (pm.response.code == 403) ",
									"{",
									"    pm.test(\"Unauthorised to make call, only allowed for hypetap\");",
									"}",
									"",
									"//---------------Functions",
									""
								],
								"type": "text/javascript"
							}
						}
					],
					"request": {
						"method": "POST",
						"header": [],
						"body": {
							"mode": "raw",
							"raw": "{\n  \"record\": {\n    \"platform\": \"INSTAGRAM\",\n    \"comments\": 100,\n    \"likes\": 100,\n    \"impressions\": 100,\n    \"reach\": 100,\n    \"views\":100,\n    \"saves\": 100\n  },\n  \"recordDate\": \"2021-08-18\"\n}",
							"options": {
								"raw": {
									"language": "json"
								}
							}
						},
						"url": {
							"raw": "{{test}}post/611b5ef1416a8f754181fb0f/record",
							"host": [
								"{{test}}post"
							],
							"path": [
								"611b5ef1416a8f754181fb0f",
								"record"
							]
						}
					},
					"response": []
				},
				{
					"name": "Records Doesn't Exist (requires date range)",
					"event": [
						{
							"listen": "test",
							"script": {
								"exec": [
									"var responseBody = pm.response.json();",
									"",
									"if(pm.response.code==200)",
									"{",
									"    if(responseBody.object.length==0)",
									"    {",
									"        pm.test(\"Status 200 no records returned for postId \" + pm.request.url.path[2]);",
									"    }",
									"    else",
									"    {",
									"",
									"        pm.test(\"Status 200, for postId \" + pm.request.url.path[2]);",
									"",
									"        //both dates has to be given for call to work",
									"        pm.test(\"Records returned: \" + responseBody.object.length+ \". Records are within date range: \"+pm.request.url.query.toObject().from+\" - \"+pm.request.url.query.toObject().to, function(){",
									"            pm.expect(withinDates(pm.request.url.query.toObject().from, pm.request.url.query.toObject().to)).to.equal(true);",
									"        })",
									"",
									"        //validates if record exist and if it contains the same values given POST call",
									"        //also saves recordID to be able to delete it ",
									"        pm.test(\"Record doesn't exist, hasn't been added\", function(){",
									"            pm.expect(recordExist(responseBody.object, pm.variables.get(\"negNewRecord\"))).to.equal(true);",
									"        })",
									"    }",
									"}",
									"else if(pm.response.code==404)",
									"{",
									"    pm.test(\"Post id not found\", function(){",
									"        pm.expect(responseBody.object).to.equal(null);",
									"    })",
									"",
									"}",
									"else if (pm.response.code == 403) ",
									"{",
									"    pm.test(\"Unauthorised to make call, only allowed for hypetap\");",
									"}",
									"",
									"//-------------Functions",
									"function recordExist(list, record)",
									"{",
									"    for(let i =0; i<list.length; ++i)",
									"    {",
									"        //generate new dates to be able to convert string to date format",
									"        //if they are equal then it's the same record. Only one record can exist for one date",
									"        if(new Date(list[i].dateCreated).getTime() === new Date(record.recordDate).getTime())",
									"        {",
									"            return true;",
									"        }",
									"    }",
									"    return false;",
									"}",
									"",
									"function withinDates(from, to)",
									"{",
									"    for(let i =0; i<responseBody.object.length; ++i)",
									"    {",
									"        if( (new Date(responseBody.object[i].dateCreated).getTime()< new Date(from).getTime() ) &&",
									"            ( new Date(responseBody.object[i].dateCreated).getTime() >new Date(to).getTime() ) )",
									"        {",
									"            return false;",
									"        }",
									"    }",
									"    return true;",
									"",
									"}",
									"// returns false if values doesn't match",
									"function responseMatchesNewRecord(list, record)",
									"{",
									"   ",
									"    for(let i =0; i<list.length; ++i)",
									"    {",
									"        //generate new dates to be able to convert string to date format",
									"        //if they are equal then it's the same record. Only one record can exist for one date",
									"        if(new Date(list[i].dateCreated).getTime() === new Date(record.recordDate).getTime())",
									"        {",
									"            ",
									"            //if likes is given and it's not the same value as response then return false, data doesn't match",
									"            if( (record.record.likes!=undefined) && (record.record.likes!=list[i].likes) )",
									"            {",
									"                return false;",
									"            }",
									"            else if( (record.record.comments!=undefined) && (record.record.comments!=list[i].comments) )",
									"            {",
									"                return false;",
									"            }",
									"            else if( (record.record.impressions!=undefined) && (record.record.impressions!=list[i].impressions) )",
									"            {",
									"                return false;",
									"            }",
									"            else if( (record.record.reach!=undefined) && (record.record.reach!=list[i].reach) )",
									"            {",
									"                return false;",
									"            }",
									"            else if( (record.record.views!=undefined) && (record.record.views!=list[i].views) )",
									"            {",
									"                return false;",
									"            }",
									"            else if( (record.record.saves!=undefined) && (record.record.saves!=list[i].saves) )",
									"            {",
									"                return false;",
									"            }                        ",
									"        }",
									"    }",
									"    return true;    //all match",
									"}"
								],
								"type": "text/javascript"
							}
						}
					],
					"request": {
						"method": "GET",
						"header": [],
						"url": {
							"raw": "{{test}}post/611b5ef1416a8f754181fb0f/record?from=2014-12-31&to=2021-09-29",
							"host": [
								"{{test}}post"
							],
							"path": [
								"611b5ef1416a8f754181fb0f",
								"record"
							],
							"query": [
								{
									"key": "from",
									"value": "2014-12-31"
								},
								{
									"key": "to",
									"value": "2021-09-29",
									"description": "set in pre test script of current folder"
								}
							]
						}
					},
					"response": []
				}
			]
		},
		{
			"name": "GET Calls",
			"item": [
				{
					"name": "BOSS login",
					"event": [
						{
							"listen": "test",
							"script": {
								"exec": [
									"pm.test(\"Status code is 200\", function () {",
									"    pm.response.to.have.status(200);",
									"});"
								],
								"type": "text/javascript"
							}
						}
					],
					"request": {
						"method": "POST",
						"header": [
							{
								"warning": "This is a duplicate header and will be overridden by the Content-Type header generated by Postman.",
								"key": "Content-Type",
								"value": "application/x-www-form-urlencoded",
								"type": "text"
							}
						],
						"body": {
							"mode": "urlencoded",
							"urlencoded": [
								{
									"key": "username",
									"value": "dumbanddummy1+brooke@gmail.com",
									"description": "dumbanddummy1+brooke@gmail.com",
									"type": "text"
								},
								{
									"key": "password",
									"value": "hypetap1",
									"type": "text"
								},
								{
									"key": "remember-me",
									"value": "true",
									"type": "text"
								}
							]
						},
						"url": {
							"raw": "{{test}}login",
							"host": [
								"{{test}}login"
							]
						}
					},
					"response": []
				},
				{
					"name": "List tags matching substring",
					"event": [
						{
							"listen": "test",
							"script": {
								"exec": [
									"var responseBody = pm.response.json();",
									"",
									"",
									"    if(pm.response.code==200)",
									"    {",
									"        //call works without a given subString",
									"        if(pm.request.url.query.toObject().substring!=undefined &&",
									"            responseBody.object.length!==0)",
									"        {",
									"            pm.test(\"Status 200. Result contains substring \"+ pm.request.url.query.toObject().substring, function(){",
									"            pm.expect( containsString(pm.request.url.query.toObject().substring) ).to.equal(true);",
									"            })",
									"        }",
									"        else if(pm.request.url.query.toObject().substring==undefined)",
									"        (",
									"            pm.test(\"Status 200. No substring given returns all tags\" )",
									"        )",
									"        else //given substring but no match",
									"        {",
									"            pm.test(\"Status 200. No match for given substring: \"+   pm.request.url.query.toObject().substring, function(){",
									"                pm.expect( containsString(pm.request.url.query.toObject().substring) ).to.equal(true);",
									"            })",
									"        }   ",
									"    }",
									"    else if(pm.response.code ==403)",
									"    {",
									"        pm.test(\"Not authorised, call only allowed for Hypetap employees\", function(){",
									"            pm.expect(responseBody.notes.hypetap).to.equal(false);",
									"        })",
									"    }",
									"",
									"",
									"",
									"//----------Functions",
									"",
									"function containsString(value)",
									"{",
									"    //searches for substring, case-insensitive",
									"    let regex = new RegExp(\".*\"+value+\".*\", 'i')",
									"    for(let i=0; i< responseBody.object.length; ++i)",
									"    {",
									"        // returns false if there's no match",
									"        if(regex.test(responseBody.object[i].name)==false)",
									"        {",
									"            return false;",
									"        }",
									"    }",
									"    return true;",
									"    ",
									"}"
								],
								"type": "text/javascript"
							}
						}
					],
					"request": {
						"method": "GET",
						"header": [],
						"url": {
							"raw": "{{test}}post/tags?substring=dog",
							"host": [
								"{{test}}post"
							],
							"path": [
								"tags"
							],
							"query": [
								{
									"key": "substring",
									"value": "dog"
								}
							]
						}
					},
					"response": []
				},
				{
					"name": "List records of post {postId}/record",
					"event": [
						{
							"listen": "test",
							"script": {
								"exec": [
									"var responseBody = pm.response.json();",
									"",
									"if(pm.response.code==200)",
									"{",
									"    if(responseBody.object.length==0)",
									"    {",
									"        pm.test(\"Status 200 no records returned for postId \" + pm.request.url.path[2]);",
									"    }",
									"    else",
									"    {",
									"        pm.test(\"Status 200, for postId \" + pm.request.url.path[2]);",
									"",
									"        //both dates has to be given for call to work",
									"        pm.test(\"Records are within date range: \"+pm.request.url.query.toObject().from+\" - \"+pm.request.url.query.toObject().to, function(){",
									"            pm.expect(withinDates(pm.request.url.query.toObject().from, pm.request.url.query.toObject().to)).to.equal(true);",
									"        })",
									"",
									"    }",
									"}",
									"else if(pm.response.code==404)",
									"{",
									"    pm.test(\"Post id not found\", function(){",
									"        pm.expect(responseBody.object).to.equal(null);",
									"    })",
									"",
									"}",
									"else if (pm.response.code == 403) ",
									"{",
									"    pm.test(\"Unauthorised to make call, only allowed for hypetap\");",
									"}",
									"",
									"//-------------Functions",
									"",
									"function withinDates(from, to)",
									"{",
									"    for(let i =0; i<responseBody.object.length; ++i)",
									"    {",
									"        if( (new Date(responseBody.object[i].dateCreated).getTime()< new Date(from).getTime() ) &&",
									"            ( new Date(responseBody.object[i].dateCreated).getTime() >new Date(to).getTime() ) )",
									"        {",
									"            return false;",
									"        }",
									"    }",
									"    return true;",
									"",
									"}",
									""
								],
								"type": "text/javascript"
							}
						}
					],
					"request": {
						"method": "GET",
						"header": [],
						"url": {
							"raw": "{{test}}post/611b5ef1416a8f754181fb0f/record?from=2021-08-17&to=2021-09-01",
							"host": [
								"{{test}}post"
							],
							"path": [
								"611b5ef1416a8f754181fb0f",
								"record"
							],
							"query": [
								{
									"key": "from",
									"value": "2021-08-17"
								},
								{
									"key": "to",
									"value": "2021-09-01"
								}
							]
						}
					},
					"response": []
				},
				{
					"name": "Lists post of a User (used for uploading a post for a campaign)",
					"event": [
						{
							"listen": "test",
							"script": {
								"exec": [
									"",
									"//username required",
									"",
									"var responseBody = pm.response.json();",
									"var searchOptions= [\"platform\", \"status\", \"type\",\"tag\", \"caption\"]; ",
									"",
									"if(pm.response.code==200)",
									"{",
									"    pm.test(\"Status is 200 for username \" + pm.request.url.query.toObject().username+",
									"             \" . Total posts returned: \" +responseBody.object.totalElements);",
									"",
									"    //userId should all be the same, uses the first object to display userId",
									"    pm.test(\"All post belongs to the same userId: \" + responseBody.object.content[0].userId, function(){",
									"        pm.expect(postsOfOneUser(responseBody.object.content ,responseBody.object.content[0].userId)).to.equal(true);",
									"    })",
									"",
									"    for(let i =0; i<searchOptions.length; ++i)",
									"    {",
									"        //will be undefined if not given as a paramater",
									"        if(pm.request.url.query.toObject()[searchOptions[i]]!=undefined)",
									"        {",
									"            //responseMatchesValue() will check for each object returned",
									"            //if it matches any part of the given parameter value (example input for status: AUTO_DETECTED,%20AUTO_APPROVED",
									"            //returns false if it doesn't match",
									"            pm.test(\"Search option '\"+searchOptions[i] +",
									"            \"' with values '\"+pm.request.url.query.toObject()[searchOptions[i]] + \"' matches response\", function(){",
									"                pm.expect(responseMatchesValue(responseBody.object.content, ",
									"                                                searchOptions[i],",
									"                                                pm.request.url.query.toObject()[searchOptions[i]]))",
									"                    .to.equal(true);",
									"            })",
									"        }",
									"    }",
									"}",
									"else if (pm.response.code==400)",
									"{",
									"    if(responseBody.notes.username!=undefined)",
									"    {",
									"        pm.test(\"Status 400. No username given, username is required for this call\", function(){",
									"            pm.expect(responseBody.notes.username).to.equal(false);",
									"        })",
									"    }",
									"    // call only looks for influencers and if username matches a user with profileStatus = influencer",
									"    else if(responseBody.notes.userFound!=undefined)",
									"    {",
									"        pm.test(\"Status 400. A influencer with given username is not found\", function(){",
									"            pm.expect(responseBody.notes.userFound).to.equal(false);",
									"        })",
									"    }       ",
									"}",
									"else if (pm.response.code == 401) ",
									"{",
									"    pm.test(\"Unauthenticated\");",
									"    ",
									"}",
									"",
									"//---------------Functions",
									"//checks if userId is the same for all posts",
									"function postsOfOneUser(list, userId)",
									"{",
									"    for(let i =0; i<list.length; ++i)",
									"    {",
									"        if(list[i].userId!=userId)",
									"        {",
									"            return false;",
									"        }",
									"    }",
									"    return true;",
									"}",
									" ",
									"//list represent contentTags for one obj/post.",
									"//if regexMatch, (regex of given tag input), matches one of the names found in contentTags then function returns true.",
									"//returns false if no name in contentTags match given input for tag",
									"function matchesCcontentTags(list, regexMatch)",
									"{",
									"    for(let i=0; i<list.length; ++i)",
									"    {",
									"        if(regexMatch.test(list[i].name)==true)",
									"        {",
									"            return true;",
									"        }",
									"    }",
									"    //got here means it went through entire list without finding a match",
									"    return false;",
									"}",
									"",
									"// uses response value as regex.",
									"// will return true if regex matches any part of given input ",
									"//example of argument values, list: response objects, field: status ,inputValue: INSTAGRAM ",
									"function responseMatchesValue(list, field, inputValue)",
									"{",
									"    for(let i=0; i < list.length; ++i)",
									"    {",
									"        //console.log(\"regex\", new RegExp(\"(\"+inputValue.replace( /(%20|,%20|,)/g, \"|\")+\")\") )",
									"        if(field===\"caption\" && ",
									"            (new RegExp(\"(\"+inputValue.replace( /(%20|,%20|,)/g, \"|\")+\")\").test(list[i][field]!=true) ) )",
									"        {",
									"            return false;",
									"        }",
									"",
									"        //if tag is given as a parameter and non of the values match the response names then return false",
									"        //captionTags is a list",
									"        //each object in list contains name, for example tag.name:\"Wood\". input tag should match at least one of the names",
									"        else if(field===\"tag\" && ",
									"          (matchesCcontentTags(list[i].contentTags, ",
									"                            (new RegExp(\"(\"+inputValue.replace( /(%20|,%20|,)/g, \"|\")+\")\")  )) ==false) )",
									"        {",
									"            return false;",
									"        }        ",
									"",
									"        //if resoponse fields value, for example the value of status matches any part of the given input then it will return true ",
									"        //returns false if it doesn't match",
									"       // responseRegex = new RegExp(\"(\"+list[i][field]+\")\",\"i\");",
									"        else if(field!=\"caption\" && field!= \"tag\" && ",
									"            (new RegExp(\"(\"+list[i][field]+\")\",\"i\").test(inputValue)!=true) )",
									"        {",
									"            return false;",
									"        }",
									"    }",
									"    return true; ",
									"}"
								],
								"type": "text/javascript"
							}
						}
					],
					"request": {
						"method": "GET",
						"header": [
							{
								"key": "Content-Type",
								"value": "application/json",
								"type": "text"
							}
						],
						"url": {
							"raw": "{{test}}post?platform=INSTAGRAM&username=larryb2&caption=pet, dog",
							"host": [
								"{{test}}post"
							],
							"query": [
								{
									"key": "platform",
									"value": "INSTAGRAM"
								},
								{
									"key": "status",
									"value": "AUTO_DETECTED, AUTO_APPROVED",
									"disabled": true
								},
								{
									"key": "type",
									"value": "STILL",
									"disabled": true
								},
								{
									"key": "page",
									"value": "0",
									"disabled": true
								},
								{
									"key": "size",
									"value": "10000",
									"disabled": true
								},
								{
									"key": "username",
									"value": "larryb2"
								},
								{
									"key": "tag",
									"value": "Wood, Forest, dog",
									"description": "contentTags",
									"disabled": true
								},
								{
									"key": "caption",
									"value": "pet, dog"
								}
							]
						}
					},
					"response": []
				},
				{
					"name": "COPY LOAD POSTS",
					"event": [
						{
							"listen": "test",
							"script": {
								"exec": [
									"//username required",
									"",
									"var responseBody = pm.response.json();",
									"var searchOptions= [\"platform\", \"status\", \"type\",\"tag\", \"caption\"]; ",
									"",
									"if(pm.response.code==200)",
									"{",
									"    pm.test(\"Status is 200 for username \" + pm.request.url.query.toObject().username+",
									"             \" . Total posts returned: \" +responseBody.object.totalElements);",
									"",
									"    //userId should all be the same, uses the first object to display userId",
									"    pm.test(\"All post belongs to the same userId: \" + responseBody.object.content[0].userId, function(){",
									"        pm.expect(postsOfOneUser(responseBody.object.content ,responseBody.object.content[0].userId)).to.equal(true);",
									"    })",
									"",
									"   for(let i =0; i<searchOptions.length; ++i)",
									"    {",
									"        //will be undefined if not given as a paramater",
									"        if(pm.request.url.query.toObject()[searchOptions[i]]!=undefined)",
									"        {",
									"            //responseMatchesValue() will check for each object returned",
									"            //if it matches any part of the given parameter value (example input for status: AUTO_DETECTED,%20AUTO_APPROVED",
									"            //returns false if it doesn't match",
									"            pm.test(\"Search option '\"+searchOptions[i] +",
									"            \"' with values '\"+pm.request.url.query.toObject()[searchOptions[i]] + \"' matches response\", function(){",
									"                pm.expect(responseMatchesValue(responseBody.object.content, ",
									"                                                searchOptions[i],",
									"                                                pm.request.url.query.toObject()[searchOptions[i]]))",
									"                    .to.equal(true);",
									"            })",
									"        }",
									"    }",
									"}",
									"else if (pm.response.code==400)",
									"{",
									"    if(responseBody.notes.username!=undefined)",
									"    {",
									"        pm.test(\"Status 400. No username given, username is required for this call\", function(){",
									"            pm.expect(responseBody.notes.username).to.equal(false);",
									"        })",
									"    }",
									"    // call only looks for influencers and if username matches a user with profileStatus = influencer",
									"    else if(responseBody.notes.userFound!=undefined)",
									"    {",
									"        pm.test(\"Status 400. A influencer with given username is not found\", function(){",
									"            pm.expect(responseBody.notes.userFound).to.equal(false);",
									"        })",
									"    }       ",
									"}",
									"else if (pm.response.code == 401) ",
									"{",
									"    pm.test(\"Unauthenticated\");",
									"    ",
									"}",
									"",
									"//---------------Functions",
									"//checks if userId is the same for all posts",
									"function postsOfOneUser(list, userId)",
									"{",
									"    for(let i =0; i<list.length; ++i)",
									"    {",
									"        if(list[i].userId!=userId)",
									"        {",
									"            return false;",
									"        }",
									"    }",
									"    return true;",
									"}",
									" ",
									"//list represent contentTags for one obj/post.",
									"//if regexMatch, (regex of given tag input), matches one of the names found in contentTags then function returns true.",
									"//returns false if no name in contentTags match given input for tag",
									"function matchesCcontentTags(list, regexMatch)",
									"{",
									"    for(let i=0; i<list.length; ++i)",
									"    {",
									"        if(regexMatch.test(list[i].name)==true)",
									"        {",
									"            return true;",
									"        }",
									"    }",
									"    //got here means it went through entire list without finding a match",
									"    return false;",
									"}",
									"",
									"// uses response value as regex.",
									"// will return true if regex matches any part of given input ",
									"//example of argument values, list: response objects, field: status ,inputValue: INSTAGRAM ",
									"function responseMatchesValue(list, field, inputValue)",
									"{",
									"    for(let i=0; i < list.length; ++i)",
									"    {",
									"        if(field===\"caption\" && ",
									"            (new RegExp(\"(\"+inputValue.replace( /(%20|,%20|,)/g, \"|\")+\")\", \"i\").test(list[i][field]!=true) ) )",
									"        {",
									"            return false;",
									"        }",
									"",
									"        //if tag is given as a parameter and non of the values match the response names then return false",
									"        //captionTags is a list",
									"        //each object in list contains name, for example tag.name:\"Wood\". input tag should match at least one of the names",
									"        else if(field===\"tag\" && ",
									"          (matchesCcontentTags(list[i].contentTags, ",
									"                            (new RegExp(\"(\"+inputValue.replace( /(%20|,%20|,)/g, \"|\")+\")\", \"i\"))) ==false) )",
									"        {",
									"            return false;",
									"        }        ",
									"",
									"        //if resoponse fields value, for example the value of status matches any part of the given input then it will return true ",
									"        //returns false if it doesn't match",
									"       // responseRegex = new RegExp(\"(\"+list[i][field]+\")\",\"i\");",
									"        else if(field!=\"caption\" && field!= \"tag\" && ",
									"            (new RegExp(\"(\"+list[i][field]+\")\",\"i\").test(inputValue)!=true) )",
									"        {",
									"            return false;",
									"        }",
									"    }",
									"    return true; ",
									"}",
									""
								],
								"type": "text/javascript"
							}
						}
					],
					"protocolProfileBehavior": {
						"disableBodyPruning": true
					},
					"request": {
						"method": "GET",
						"header": [],
						"body": {
							"mode": "file",
							"file": {}
						},
						"url": {
							"raw": "{{test}}post?platform=INSTAGRAM&status=AUTO_DETECTED, AUTO_APPROVED&type=STILL&size=10000&username=larryb2&tag=Wood, Forest, dog&caption=pet, dog",
							"host": [
								"{{test}}post"
							],
							"query": [
								{
									"key": "platform",
									"value": "INSTAGRAM"
								},
								{
									"key": "status",
									"value": "AUTO_DETECTED, AUTO_APPROVED"
								},
								{
									"key": "type",
									"value": "STILL"
								},
								{
									"key": "page",
									"value": "0",
									"disabled": true
								},
								{
									"key": "size",
									"value": "10000"
								},
								{
									"key": "username",
									"value": "larryb2"
								},
								{
									"key": "tag",
									"value": "Wood, Forest, dog",
									"description": "contentTags"
								},
								{
									"key": "caption",
									"value": "pet, dog"
								}
							]
						}
					},
					"response": []
				},
				{
					"name": "Lists Content of a User",
					"event": [
						{
							"listen": "test",
							"script": {
								"exec": [
									"// return 500 if username is not given and if invalid",
									"// returns 500 if not the right typ for example instagram is requested instead of INSTAGRAM",
									"",
									"var responseBody = pm.response.json();",
									"var searchOptions= [\"platform\", \"type\",\"tag\", \"caption\"]; ",
									"",
									"if(pm.response.code==200)",
									"{",
									"    pm.test(\"Status is 200 for username \" + pm.request.url.query.toObject().username+",
									"             \" . Total returned: \" +responseBody.page.totalElements);",
									"",
									"    for(let i =0; i<searchOptions.length; ++i)",
									"    {",
									"        //will be undefined if not given as a paramater",
									"        if(pm.request.url.query.toObject()[searchOptions[i]]!=undefined)        //.replaceAll((/'\"'/g),\"\")]!=undefined)",
									"        {",
									"        ",
									"            //(platform not in response uses url to validate platform)",
									"            //responseMatchesValue() will check for each object returned",
									"            //if it matches any part of the given parameter value (example input for status: AUTO_DETECTED,%20AUTO_APPROVED",
									"            //returns false if it doesn't match",
									"            pm.test(\"Search option '\"+searchOptions[i] +",
									"            \"' with values '\"+pm.request.url.query.toObject()[searchOptions[i]] + \"' matches response\", function(){",
									"                pm.expect(responseMatchesValue(responseBody.page.content, ",
									"                                                searchOptions[i],",
									"                                                pm.request.url.query.toObject()[searchOptions[i]]))",
									"                    .to.equal(true);",
									"            })",
									"        }",
									"    }",
									"}",
									"else if (pm.response.code==400)",
									"{",
									"    if(responseBody.notes.username!=undefined)",
									"    {",
									"        pm.test(\"Status 400. No username given, username is required for this call\", function(){",
									"            pm.expect(responseBody.notes.username).to.equal(false);",
									"        })",
									"    }",
									"    // call only looks for influencers and if username matches a user with profileStatus = influencer",
									"    else if(responseBody.notes.userFound!=undefined)",
									"    {",
									"        pm.test(\"Status 400. A influencer with given username is not found\", function(){",
									"            pm.expect(responseBody.notes.userFound).to.equal(false);",
									"        })",
									"    }       ",
									"}",
									"else if (pm.response.code == 401) ",
									"{",
									"    pm.test(\"Unauthenticated\");",
									"    ",
									"}",
									"",
									"//---------------Functions",
									"//checks if userId is the same for all posts",
									"function postsOfOneUser(list, userId)",
									"{",
									"    for(let i =0; i<list.length; ++i)",
									"    {",
									"        if(list[i].userId!=userId)",
									"        {",
									"            return false;",
									"        }",
									"    }",
									"    return true;",
									"}",
									" ",
									"//list represent contentTags for one obj/post.",
									"//if regexMatch, (regex of given tag input), matches one of the names found in contentTags then function returns true.",
									"//returns false if no name in contentTags match given input for tag",
									"function matchesCcontentTags(list, regexMatch)",
									"{",
									"    for(let i=0; i<list.length; ++i)",
									"    {",
									"        if(regexMatch.test(list[i].name)==true)",
									"        {",
									"            return true;",
									"        }",
									"    }",
									"    //got here means it went through entire list without finding a match",
									"    return false;",
									"}",
									"",
									"// uses response value as regex.",
									"// will return true if regex matches any part of given input ",
									"//example of argument values, list: response objects, field: status ,inputValue: INSTAGRAM ",
									"function responseMatchesValue(list, field, inputValue)",
									"{",
									"    for(let i=0; i < list.length; ++i)",
									"    {",
									"        if(field===\"caption\" && ",
									"            (new RegExp(\"(\"+inputValue.replace( /(%20|,%20|,)/g, \"|\")+\")\", \"i\").test(list[i][field]!=true) ) )",
									"        {",
									"            return false;",
									"        }",
									"",
									"        //if tag is given as a parameter and non of the values match the response names then return false",
									"        //captionTags is a list",
									"        //each object in list contains name, for example tag.name:\"Wood\". input tag should match at least one of the names",
									"        else if(field===\"tag\" && ",
									"          (matchesCcontentTags(list[i].contentTags, ",
									"                            (new RegExp(\"(\"+inputValue.replace( /(%20|,%20|,)/g, \"|\")+\")\", \"i\"))) ==false) )",
									"        {",
									"            return false;",
									"        }        ",
									"",
									"        // platform is not returned in response so check if url contains instagram",
									"        //platform is not a list",
									"       // responseRegex = new RegExp(\"(\"+list[i][field]+\")\",\"i\");",
									"        else if(field=== \"platform\" && ",
									"            (new RegExp(\"(\"+inputValue+\")\",\"i\").test(list[i].url)!=true) )",
									"        {",
									"            return false;",
									"        }",
									"    }",
									"    return true; ",
									"}",
									""
								],
								"type": "text/javascript"
							}
						}
					],
					"request": {
						"method": "GET",
						"header": [],
						"url": {
							"raw": "{{test}}post/content?platform=INSTAGRAM&size=10000&username=larryb2&caption=dog, pet",
							"host": [
								"{{test}}post"
							],
							"path": [
								"content"
							],
							"query": [
								{
									"key": "platform",
									"value": "INSTAGRAM",
									"description": "500 if incorrect format"
								},
								{
									"key": "size",
									"value": "10000"
								},
								{
									"key": "page",
									"value": "0",
									"disabled": true
								},
								{
									"key": "username",
									"value": "larryb2"
								},
								{
									"key": "caption",
									"value": "dog, pet"
								},
								{
									"key": "tag",
									"value": "Wood",
									"disabled": true
								}
							]
						}
					},
					"response": []
				},
				{
					"name": "Get Instagram thumbnail of a post",
					"event": [
						{
							"listen": "test",
							"script": {
								"exec": [
									"//returns 500 if postId is not found or if userId is not found for post",
									"//no limitation on who can make call",
									"",
									"if(pm.response.code==200)",
									"{",
									"    pm.test(\"Status code is 200 for postId \"+ pm.request.url.path[3]);",
									"}",
									"//will return 400 if platform of post is not INSTAGRAM or if",
									"// the user of the post doesn't have an instagramProfile",
									"else if(pm.response.code==400)",
									"{",
									"    var responseBody = pm.response.json();",
									"    pm.test(\"Status 400. userMessage: \" +responseBody.notes.userMessage);",
									"}",
									""
								],
								"type": "text/javascript"
							}
						}
					],
					"request": {
						"method": "GET",
						"header": [],
						"url": {
							"raw": "{{test}}post/thumbnail/61266997416a8f75419efcde",
							"host": [
								"{{test}}post"
							],
							"path": [
								"thumbnail",
								"61266997416a8f75419efcde"
							]
						}
					},
					"response": []
				}
			]
		},
		{
			"name": "STAGING NEG Update Post (Username Not Provided)",
			"item": [
				{
					"name": "BOSS login",
					"event": [
						{
							"listen": "test",
							"script": {
								"exec": [
									"pm.test(\"Status code is 200\", function () {",
									"    pm.response.to.have.status(200);",
									"});"
								],
								"type": "text/javascript"
							}
						}
					],
					"request": {
						"method": "POST",
						"header": [
							{
								"warning": "This is a duplicate header and will be overridden by the Content-Type header generated by Postman.",
								"key": "Content-Type",
								"value": "application/x-www-form-urlencoded",
								"type": "text"
							}
						],
						"body": {
							"mode": "urlencoded",
							"urlencoded": [
								{
									"key": "username",
									"value": "dumbanddummy1+brooke@gmail.com",
									"description": "dumbanddummy1+brooke@gmail.com",
									"type": "text"
								},
								{
									"key": "password",
									"value": "hypetap1",
									"type": "text"
								},
								{
									"key": "remember-me",
									"value": "true",
									"type": "text"
								}
							]
						},
						"url": {
							"raw": "https://titan.mel.hypetap.net/hypetap/login",
							"protocol": "https",
							"host": [
								"titan",
								"mel",
								"hypetap",
								"net"
							],
							"path": [
								"hypetap",
								"login"
							]
						}
					},
					"response": []
				},
				{
					"name": "Upload Instagram Posts",
					"event": [
						{
							"listen": "test",
							"script": {
								"exec": [
									"var responseBody = pm.response.json();",
									"var requestBody = JSON.parse(pm.request.body.raw);",
									"",
									"pm.test(\"Required field 'platform' is given in the requestbody\", function(){",
									"    pm.expect(requestBody.platform).to.not.equal(undefined);",
									"})",
									"",
									"if(pm.response.code==200)",
									"{",
									"   if(responseBody.object.numberOfElements!=0)",
									"   {",
									"        //userId should all be the same, uses the first object to display userId",
									"        pm.test(\"Status 200. All post belongs to the same userId: \" + responseBody.object.content[0].userId, function(){",
									"            pm.expect(postsOfOneUser(responseBody.object.content ,responseBody.object.content[0].userId)).to.equal(true);",
									"        })",
									"",
									"        pm.test(\"Required field 'platform' is given in the requestbody\", function(){",
									"            pm.expect(requestBody.platform).to.not.equal(undefined);",
									"        })",
									"",
									"   }",
									"   else",
									"   {",
									"       pm.test(\"Status 200. No results.\");",
									"   }",
									"",
									"}",
									"else if (pm.response.code==400)",
									"{",
									"    if(responseBody.notes.username!=undefined)",
									"    {",
									"        //username has to be given if logged in user isn't an influencer",
									"        pm.test(\"Status 400. Username not found or not given in request when it's required\", function(){",
									"            pm.expect(responseBody.notes.username).to.equal(false);",
									"        })",
									"    }",
									"    else if (responseBody.notes.userMessage!=undefined)",
									"    {",
									"        pm.test(\"Status 400. userMessage: \"+responseBody.notes.userMessage);",
									"    }",
									"    else",
									"    {   //will return 400 if user doesn't have facebook and it's given in the reguest",
									"        pm.test(\"Make sure user has the social profile given \")",
									"    }",
									"",
									"}",
									"",
									"",
									"//---------------Functions",
									"//checks if userId is the same for all posts",
									"function postsOfOneUser(list, userId)",
									"{",
									"    for(let i =0; i<list.length; ++i)",
									"    {",
									"        if(list[i].userId!=userId)",
									"        {",
									"            return false;",
									"        }",
									"    }",
									"    return true;",
									"}",
									" "
								],
								"type": "text/javascript"
							}
						}
					],
					"request": {
						"method": "PUT",
						"header": [],
						"body": {
							"mode": "raw",
							"raw": "{\n    \"platform\":\"INSTAGRAM\",\n    \"types\":[\"STILL\"]\n}",
							"options": {
								"raw": {
									"language": "json"
								}
							}
						},
						"url": {
							"raw": "https://titan.mel.hypetap.net/hypetap/post/update?size=10000",
							"protocol": "https",
							"host": [
								"titan",
								"mel",
								"hypetap",
								"net"
							],
							"path": [
								"hypetap",
								"post",
								"update"
							],
							"query": [
								{
									"key": "size",
									"value": "10000"
								}
							]
						}
					},
					"response": []
				}
			]
		},
		{
			"name": "STAGING Update Post (Post/Update)",
			"item": [
				{
					"name": "BOSS login",
					"event": [
						{
							"listen": "test",
							"script": {
								"exec": [
									"pm.test(\"Status code is 200\", function () {",
									"    pm.response.to.have.status(200);",
									"});"
								],
								"type": "text/javascript"
							}
						}
					],
					"request": {
						"method": "POST",
						"header": [
							{
								"warning": "This is a duplicate header and will be overridden by the Content-Type header generated by Postman.",
								"key": "Content-Type",
								"value": "application/x-www-form-urlencoded",
								"type": "text"
							}
						],
						"body": {
							"mode": "urlencoded",
							"urlencoded": [
								{
									"key": "username",
									"value": "dumbanddummy1+brooke@gmail.com",
									"description": "dumbanddummy1+melbournejade@gmail.com, dumbanddummy1+brooke@gmail.com",
									"type": "text"
								},
								{
									"key": "password",
									"value": "hypetap1",
									"type": "text"
								},
								{
									"key": "remember-me",
									"value": "true",
									"type": "text"
								}
							]
						},
						"url": {
							"raw": "https://titan.mel.hypetap.net/hypetap/login",
							"protocol": "https",
							"host": [
								"titan",
								"mel",
								"hypetap",
								"net"
							],
							"path": [
								"hypetap",
								"login"
							]
						}
					},
					"response": []
				},
				{
					"name": "Upload Instagram Posts",
					"event": [
						{
							"listen": "test",
							"script": {
								"exec": [
									"var responseBody = pm.response.json();",
									"var requestBody = JSON.parse(pm.request.body.raw);",
									"",
									"",
									"pm.test(\"Required field 'platform' is given in the requestbody\", function(){",
									"    pm.expect(requestBody.platform).to.not.equal(undefined);",
									"})",
									"",
									"if(pm.response.code==200)",
									"{",
									"   if(responseBody.object.numberOfElements!=0)",
									"   {",
									"        //userId should all be the same, uses the first object to display userId",
									"        pm.test(\"Status 200. All post belongs to the same userId: \" + responseBody.object.content[0].userId, function(){",
									"            pm.expect(postsOfOneUser(responseBody.object.content ,responseBody.object.content[0].userId)).to.equal(true);",
									"        })",
									"",
									"   }",
									"   else",
									"   {",
									"       pm.test(\"Status 200. No results.\");",
									"   }",
									"",
									"}",
									"else if (pm.response.code==400)",
									"{",
									"    if(responseBody.notes.username!=undefined)",
									"    {",
									"        //username has to be given if logged in user isn't an influencer",
									"        pm.test(\"Status 400. Username not found or not given in request when it's required\", function(){",
									"            pm.expect(responseBody.notes.username).to.equal(false);",
									"        })",
									"    }",
									"    else if (responseBody.notes.userMessage!=undefined)",
									"    {",
									"        pm.test(\"Status 400. userMessage: \"+responseBody.notes.userMessage);",
									"    }",
									"    else",
									"    {   //will return 400 if user doesn't have facebook and it's given in the reguest",
									"        pm.test(\"Make sure user has the social profile given \")",
									"    }",
									"",
									"}",
									"",
									"",
									"//---------------Functions",
									"//checks if userId is the same for all posts",
									"function postsOfOneUser(list, userId)",
									"{",
									"    for(let i =0; i<list.length; ++i)",
									"    {",
									"        if(list[i].userId!=userId)",
									"        {",
									"            return false;",
									"        }",
									"    }",
									"    return true;",
									"}",
									" "
								],
								"type": "text/javascript"
							}
						}
					],
					"request": {
						"method": "PUT",
						"header": [],
						"body": {
							"mode": "raw",
							"raw": "{\n    \"platform\":\"INSTAGRAM\",\n    \"username\":\"tarahelizabeth_\",\n    \"types\":[\"STILL\"]\n}",
							"options": {
								"raw": {
									"language": "json"
								}
							}
						},
						"url": {
							"raw": "https://titan.mel.hypetap.net/hypetap/post/update?size=10000",
							"protocol": "https",
							"host": [
								"titan",
								"mel",
								"hypetap",
								"net"
							],
							"path": [
								"hypetap",
								"post",
								"update"
							],
							"query": [
								{
									"key": "size",
									"value": "10000"
								}
							]
						}
					},
					"response": []
				}
			],
			"event": [
				{
					"listen": "prerequest",
					"script": {
						"type": "text/javascript",
						"exec": [
							""
						]
					}
				},
				{
					"listen": "test",
					"script": {
						"type": "text/javascript",
						"exec": [
							""
						]
					}
				}
			]
		},
		{
			"name": "STAGING Update Post (No Username)",
			"item": [
				{
					"name": "BOSS login Copy",
					"event": [
						{
							"listen": "test",
							"script": {
								"exec": [
									"pm.test(\"Status code is 200\", function () {",
									"    pm.response.to.have.status(200);",
									"});"
								],
								"type": "text/javascript"
							}
						}
					],
					"request": {
						"method": "POST",
						"header": [
							{
								"warning": "This is a duplicate header and will be overridden by the Content-Type header generated by Postman.",
								"key": "Content-Type",
								"value": "application/x-www-form-urlencoded",
								"type": "text"
							}
						],
						"body": {
							"mode": "urlencoded",
							"urlencoded": [
								{
									"key": "username",
									"value": "dumbanddummy1+brooke@gmail.com",
									"description": "dumbanddummy1+melbournejade@gmail.com, dumbanddummy1+brooke@gmail.com",
									"type": "text"
								},
								{
									"key": "password",
									"value": "hypetap1",
									"type": "text"
								},
								{
									"key": "remember-me",
									"value": "true",
									"type": "text"
								}
							]
						},
						"url": {
							"raw": "https://titan.mel.hypetap.net/hypetap/login",
							"protocol": "https",
							"host": [
								"titan",
								"mel",
								"hypetap",
								"net"
							],
							"path": [
								"hypetap",
								"login"
							]
						}
					},
					"response": []
				},
				{
					"name": "Validate posts, Saves postIds of melbournejade",
					"event": [
						{
							"listen": "test",
							"script": {
								"exec": [
									"//username required",
									"",
									"var responseBody = pm.response.json();",
									"var searchOptions= [\"platform\", \"status\", \"type\",\"tag\", \"caption\"]; ",
									"const idsList=[];",
									"",
									"if(pm.response.code==200)",
									"{",
									"    pm.test(\"Status is 200 for username \" + pm.request.url.query.toObject().username+",
									"             \" . Total posts returned: \" +responseBody.object.totalElements);",
									"",
									"    //userId should all be the same, uses the first object to display userId",
									"    pm.test(\"All post belongs to the same userId: \" + responseBody.object.content[0].userId, function(){",
									"        pm.expect(postsOfOneUser(responseBody.object.content ,responseBody.object.content[0].userId)).to.equal(true);",
									"    })",
									"    ",
									"    //saves postIds in list",
									"    pm.variables.set(\"postIdsList\",idsList);",
									"",
									"    for(let i =0; i<searchOptions.length; ++i)",
									"    {",
									"        //will be undefined if not given as a paramater",
									"        if(pm.request.url.query.toObject()[searchOptions[i].replaceAll((/'\"'/g),\"\")]!=undefined)",
									"        {",
									"            //responseMatchesValue() will check for each object returned",
									"            //if it matches any part of the given parameter value (example input for status: AUTO_DETECTED,%20AUTO_APPROVED",
									"            //returns false if it doesn't match",
									"            pm.test(\"Search option '\"+searchOptions[i] +",
									"            \"' with values '\"+pm.request.url.query.toObject()[searchOptions[i]] + \"' matches response\", function(){",
									"                pm.expect(responseMatchesValue(responseBody.object.content, ",
									"                                                searchOptions[i],",
									"                                                pm.request.url.query.toObject()[searchOptions[i]]))",
									"                    .to.equal(true);",
									"            })",
									"        }",
									"    }",
									"}",
									"else if (pm.response.code==400)",
									"{",
									"    if(responseBody.notes.username!=undefined)",
									"    {",
									"        pm.test(\"Status 400. No username given, username is required for this call\", function(){",
									"            pm.expect(responseBody.notes.username).to.equal(false);",
									"        })",
									"    }",
									"    // call only looks for influencers and if username matches a user with profileStatus = influencer",
									"    else if(responseBody.notes.userFound!=undefined)",
									"    {",
									"        pm.test(\"Status 400. A influencer with given username is not found\", function(){",
									"            pm.expect(responseBody.notes.userFound).to.equal(false);",
									"        })",
									"    }       ",
									"}",
									"else if (pm.response.code == 401) ",
									"{",
									"    pm.test(\"Unauthenticated\");",
									"    ",
									"}",
									"",
									"//---------------Functions",
									"",
									"//checks if userId is the same for all posts",
									"function postsOfOneUser(list, userId)",
									"{",
									"",
									"    for(let i =0; i<list.length; ++i)",
									"    {",
									"        //saves postIds in a list",
									"        const length =idsList.length;",
									"        idsList[length]=list[i].id;",
									"",
									"        if(list[i].userId!=userId)",
									"        {",
									"            return false;",
									"        }",
									"    }",
									"    return true;",
									"}",
									" ",
									"//list represent contentTags for one obj/post.",
									"//if regexMatch, (regex of given tag input), matches one of the names found in contentTags then function returns true.",
									"//returns false if no name in contentTags match given input for tag",
									"function matchesCcontentTags(list, regexMatch)",
									"{",
									"    for(let i=0; i<list.length; ++i)",
									"    {",
									"        if(regexMatch.test(list[i].name)==true)",
									"        {",
									"            return true;",
									"        }",
									"    }",
									"    //got here means it went through entire list without finding a match",
									"    return false;",
									"}",
									"",
									"// uses response value as regex.",
									"// will return true if regex matches any part of given input ",
									"//example of argument values, list: response objects, field: status ,inputValue: INSTAGRAM ",
									"function responseMatchesValue(list, field, inputValue)",
									"{",
									"    for(let i=0; i < list.length; ++i)",
									"    {",
									"        if(field===\"caption\" && ",
									"            (new RegExp(\"(\"+inputValue.replaceAll( /(%20|,%20|,)/g, \"|\")+\")\", \"i\").test(list[i][field]!=true) ) )",
									"        {",
									"            return false;",
									"        }",
									"",
									"        //if tag is given as a parameter and non of the values match the response names then return false",
									"        //captionTags is a list",
									"        //each object in list contains name, for example tag.name:\"Wood\". input tag should match at least one of the names",
									"        else if(field===\"tag\" && ",
									"          (matchesCcontentTags(list[i].contentTags, ",
									"                            (new RegExp(\"(\"+inputValue.replaceAll( /(%20|,%20|,)/g, \"|\")+\")\", \"i\"))) ==false) )",
									"        {",
									"            return false;",
									"        }        ",
									"",
									"        //if resoponse fields value, for example the value of status matches any part of the given input then it will return true ",
									"        //returns false if it doesn't match",
									"       // responseRegex = new RegExp(\"(\"+list[i][field]+\")\",\"i\");",
									"        else if(field!=\"caption\" && field!= \"tag\" && ",
									"            (new RegExp(\"(\"+list[i][field]+\")\",\"i\").test(inputValue)!=true) )",
									"        {",
									"            return false;",
									"        }",
									"    }",
									"    return true; ",
									"}",
									""
								],
								"type": "text/javascript"
							}
						}
					],
					"protocolProfileBehavior": {
						"disableBodyPruning": true
					},
					"request": {
						"method": "GET",
						"header": [],
						"body": {
							"mode": "file",
							"file": {}
						},
						"url": {
							"raw": "https://titan.mel.hypetap.net/hypetap/post?platform=INSTAGRAM&status=AUTO_DETECTED&type=CAROUSEL&size=10000&username=melbournejade",
							"protocol": "https",
							"host": [
								"titan",
								"mel",
								"hypetap",
								"net"
							],
							"path": [
								"hypetap",
								"post"
							],
							"query": [
								{
									"key": "platform",
									"value": "INSTAGRAM"
								},
								{
									"key": "status",
									"value": "AUTO_DETECTED"
								},
								{
									"key": "type",
									"value": "CAROUSEL"
								},
								{
									"key": "page",
									"value": "0",
									"disabled": true
								},
								{
									"key": "size",
									"value": "10000"
								},
								{
									"key": "username",
									"value": "melbournejade"
								},
								{
									"key": "tag",
									"value": "Wood, Forest, dog",
									"description": "contentTags",
									"disabled": true
								},
								{
									"key": "caption",
									"value": "pet, dog",
									"disabled": true
								}
							]
						}
					},
					"response": []
				},
				{
					"name": "Influencer login",
					"event": [
						{
							"listen": "test",
							"script": {
								"exec": [
									"pm.test(\"Status code is 200\", function () {",
									"    pm.response.to.have.status(200);",
									"});"
								],
								"type": "text/javascript"
							}
						}
					],
					"request": {
						"method": "POST",
						"header": [
							{
								"warning": "This is a duplicate header and will be overridden by the Content-Type header generated by Postman.",
								"key": "Content-Type",
								"value": "application/x-www-form-urlencoded",
								"type": "text"
							}
						],
						"body": {
							"mode": "urlencoded",
							"urlencoded": [
								{
									"key": "username",
									"value": "dumbanddummy1+melbournejade@gmail.com",
									"description": "dumbanddummy1+melbournejade@gmail.com, dumbanddummy1+brooke@gmail.com",
									"type": "text"
								},
								{
									"key": "password",
									"value": "hypetap1",
									"type": "text"
								},
								{
									"key": "remember-me",
									"value": "true",
									"type": "text"
								}
							]
						},
						"url": {
							"raw": "https://titan.mel.hypetap.net/hypetap/login",
							"protocol": "https",
							"host": [
								"titan",
								"mel",
								"hypetap",
								"net"
							],
							"path": [
								"hypetap",
								"login"
							]
						}
					},
					"response": []
				},
				{
					"name": "Upload Instagram Posts",
					"event": [
						{
							"listen": "test",
							"script": {
								"exec": [
									"var responseBody = pm.response.json();",
									"var requestBody = JSON.parse(pm.request.body.raw);",
									"",
									"pm.test(\"Required field 'platform' is given in the requestbody\", function(){",
									"    pm.expect(requestBody.platform).to.not.equal(undefined);",
									"})",
									"",
									"if(pm.response.code==200)",
									"{",
									"   if(responseBody.object.numberOfElements!=0)",
									"   {",
									"        //userId is not returned if session user is an influencer",
									"        pm.test(\"Status 200. Required platform is given in the requestbody\", function(){",
									"            pm.expect(requestBody.platform).to.not.equal(undefined);",
									"        })",
									"",
									"        //userId is not returned for an influencer",
									"        //compares postIds from \"Validate posts\", (GET posts) and returned postIds",
									"        //returns true postIds are found",
									"        pm.test(\"Status 200. All post belongs to the same user\", function(){",
									"            pm.expect(postsOfOneUser(responseBody.object.content ,pm.variables.get(\"postIdsList\"))).to.equal(true);",
									"        })",
									"   }",
									"   else",
									"   {",
									"       pm.test(\"Status 200. No results.\");",
									"   }",
									"",
									"}",
									"else if (pm.response.code==400)",
									"{",
									"    if(responseBody.notes.username!=undefined)",
									"    {",
									"        //username has to be given if logged in user isn't an influencer",
									"        pm.test(\"Status 400. Username not found or not given in request when it's required\", function(){",
									"            pm.expect(responseBody.notes.username).to.equal(false);",
									"        })",
									"    }",
									"    else if (responseBody.notes.userMessage!=undefined)",
									"    {",
									"        pm.test(\"Status 400. userMessage: \"+responseBody.notes.userMessage);",
									"    }",
									"    else",
									"    {   //will return 400 if user doesn't have facebook and it's given in the reguest",
									"        pm.test(\"Make sure user has the social profile given \")",
									"    }",
									"",
									"}",
									"",
									"",
									"//---------------Functions",
									"//checks if userId is the same for all posts",
									"function postsOfOneUser(list, postIds)",
									"{",
									"    for(let i =0; i<list.length; ++i)",
									"    {",
									"        if(postIds.includes(list[i].id)!=true)",
									"        {",
									"            return false;",
									"        }",
									"    }",
									"    return true;",
									"}",
									" "
								],
								"type": "text/javascript"
							}
						}
					],
					"request": {
						"method": "PUT",
						"header": [],
						"body": {
							"mode": "raw",
							"raw": "{\n    \"platform\":\"INSTAGRAM\",\n    \"types\":[\"CAROUSEL\"]\n}",
							"options": {
								"raw": {
									"language": "json"
								}
							}
						},
						"url": {
							"raw": "https://titan.mel.hypetap.net/hypetap/post/update?size=10000",
							"protocol": "https",
							"host": [
								"titan",
								"mel",
								"hypetap",
								"net"
							],
							"path": [
								"hypetap",
								"post",
								"update"
							],
							"query": [
								{
									"key": "size",
									"value": "10000"
								}
							]
						}
					},
					"response": []
				}
			]
		}
	],
	"event": [
		{
			"listen": "prerequest",
			"script": {
				"type": "text/javascript",
				"exec": [
					""
				]
			}
		},
		{
			"listen": "test",
			"script": {
				"type": "text/javascript",
				"exec": [
					"timeSoFar=parseInt(pm.variables.get(\"accumulateResponseTime\"));",
					"newTime = timeSoFar+pm.response.responseTime;",
					"",
					"pm.variables.set(\"accumulateResponseTime\", newTime);",
					"pm.test(\"Accumulative Response Time: \"+ pm.variables.get(\"accumulateResponseTime\")+\"ms\");"
				]
			}
		}
	],
	"variable": [
		{
			"key": "id",
			"value": "611b5ef1416a8f754181fb0f"
		},
		{
			"key": "negAPPROVEDPostRecordId",
			"value": "61283916416a8f7541a337c0"
		},
		{
			"key": "accumulateResponseTime",
			"value": "0"
		},
		{
			"key": "postIdInstaVIDEO",
			"value": "611b5ef1416a8f754181fb0f"
		},
		{
			"key": "negUpdateRecordId",
			"value": "2"
		},
		{
			"key": "updateRecordId",
			"value": "611b5ef1416a8f754181faf6"
		},
		{
			"key": "postIdIGTV",
			"value": "60a32a132181376ed986ffa9"
		},
		{
			"key": "postIdREELS",
			"value": "6088e95e218137074814fd35"
		},
		{
			"key": "postIdTIKTOK",
			"value": "60a324e92181376ed9862ce9"
		}
	]
}